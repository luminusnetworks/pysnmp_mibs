# PySNMP SMI module. Autogenerated from smidump -f python CISCO-IPSEC-FLOW-MONITOR-MIB
# by libsmi2pysnmp-0.1.3 at Fri May 23 09:12:07 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( cmgwIndex, ) = mibBuilder.importSymbols("CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Counter64, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( DisplayString, TextualConvention, TimeInterval, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeInterval", "TimeStamp", "TruthValue")

# Types

class AuthAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,3,2,)
    namedValues = NamedValues(("none", 1), ("hmacMd5", 2), ("hmacSha", 3), )
    
class CompAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("none", 1), ("ldf", 2), )
    
class DiffHellmanGrp(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,3,)
    namedValues = NamedValues(("none", 1), ("dhGroup1", 2), ("dhGroup2", 3), )
    
class EncapMode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("tunnel", 1), ("transport", 2), )
    
class EncryptAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,3,)
    namedValues = NamedValues(("none", 1), ("des", 2), ("des3", 3), )
    
class EndPtType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,3,1,)
    namedValues = NamedValues(("singleIpAddr", 1), ("ipAddrRange", 2), ("ipSubnet", 3), )
    
class IPSIpAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ConstraintsUnion(ValueSizeConstraint(4,4),ValueSizeConstraint(16,16),)
    
class IkeAuthMethod(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,4,5,3,)
    namedValues = NamedValues(("none", 1), ("preSharedKey", 2), ("rsaSig", 3), ("rsaEncrypt", 4), ("revPublicKey", 5), )
    
class IkeHashAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,3,2,)
    namedValues = NamedValues(("none", 1), ("md5", 2), ("sha", 3), )
    
class IkeNegoMode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("main", 1), ("aggressive", 2), )
    
class IkePeerType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("ipAddrPeer", 1), ("namePeer", 2), )
    
class KeyType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("ike", 1), ("manual", 2), )
    
class TrapStatus(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("enabled", 1), ("disabled", 2), )
    
class TunnelStatus(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("active", 1), ("destroy", 2), )
    

# Objects

ciscoIpSecFlowMonitorMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 171)).setRevisions(("2007-10-24 00:00","2004-10-12 00:00","2000-10-13 18:00","2000-08-17 12:59",))
if mibBuilder.loadTexts: ciscoIpSecFlowMonitorMIB.setOrganization("Tivoli Systems and Cisco Systems")
if mibBuilder.loadTexts: ciscoIpSecFlowMonitorMIB.setContactInfo("Tivoli Systems\nResearch Triangle Park, NC\n\nCisco Systems\n170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\nE-mail: cs-ipsecurity@cisco.com")
if mibBuilder.loadTexts: ciscoIpSecFlowMonitorMIB.setDescription("This is a MIB Module for monitoring the\nstructures in IPSec-based Virtual Private Networks.\nThe MIB has been designed to be adopted as an IETF\nstandard. Hence Cisco-specific features of IPSec\nprotocol are excluded from this MIB. \n\nAcronyms\nThe following acronyms are used in this document:\n\n IPSec:      Secure IP Protocol\n\n VPN:        Virtual Private Network\n\n ISAKMP:     Internet Security Association and Key Exchange\n             Protocol\n\n IKE:        Internet Key Exchange Protocol\n\n SA:         Security Association\n\n MM:         Main Mode - the process of setting up\n             a Phase 1 SA to secure the exchanges\n             required to setup Phase 2 SAs\n\n QM:         Quick Mode - the process of setting up\n             Phase 2 Security Associations using \n             a Phase 1 SA.\n\n\n Overview of IPsec MIB\n\nThe MIB contains six major groups of objects which are\nused to manage the IPSec Protocol. These groups include\na Levels Group, a Phase-1 Group, a Phase-2 Group,\na History Group, a Failure Group and a TRAP Control Group.\nThe following table illustrates the structure of the\nIPSec MIB.\n\nThe Phase 1 group models objects pertaining to\nIKE negotiations and tunnels.\n\nThe Phase 2 group models objects pertaining to\nIPSec data tunnels.\n\nThe History group is to aid applications that do\ntrending analysis.\n\nThe Failure group is to enable an operator to\ndo troubleshooting and debugging of the VPN Router.\nFurther, counters are supported to aid Intrusion \nDetection.\n\nIn addition to the five major MIB Groups, there are\na number of Notifications. The following table\nillustrates the name and description of the \nIPSec TRAPs.\n\nFor a detailed discussion, please refer to the IETF\ndraft draft-ietf-ipsec-flow-monitoring-mib-00.txt.")
cipSecMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1))
cipSecLevels = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 1))
cipSecMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecMibLevel.setDescription("The level of the IPsec MIB.")
cipSecPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2))
cikeGlobalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1))
cikeGlobalActiveTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeGlobalActiveTunnels.setDescription("The number of currently active IPsec\nPhase-1 IKE Tunnels.")
cikeGlobalPreviousTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly").setUnits("SAs")
if mibBuilder.loadTexts: cikeGlobalPreviousTunnels.setDescription("The total number of previously active\nIPsec Phase-1 IKE Tunnels.")
cikeGlobalInOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cikeGlobalInOctets.setDescription("The total number of octets received by all currently\nand previously active IPsec Phase-1 IKE Tunnels.")
cikeGlobalInPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cikeGlobalInPkts.setDescription("The total number of packets received by all\ncurrently and previously active IPsec \nPhase-1 IKE Tunnels.")
cikeGlobalInDropPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cikeGlobalInDropPkts.setDescription("The total number of packets which were\ndropped during receive processing by all \ncurrently and previously\n active IPsec Phase-1 IKE Tunnels.")
cikeGlobalInNotifys = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly").setUnits("Notification Payloads")
if mibBuilder.loadTexts: cikeGlobalInNotifys.setDescription("The total number of notifys received by\nall currently and previously active IPsec \nPhase-1 IKE Tunnels.")
cikeGlobalInP2Exchgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly").setUnits("SA Payloads")
if mibBuilder.loadTexts: cikeGlobalInP2Exchgs.setDescription("The total number of IPsec Phase-2 exchanges\nreceived by all currently and previously \nactive IPsec Phase-1 IKE Tunnels.")
cikeGlobalInP2ExchgInvalids = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly").setUnits("SA Payloads")
if mibBuilder.loadTexts: cikeGlobalInP2ExchgInvalids.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were received and found to be invalid \nby all currently and previously active IPsec \nPhase-1 IKE Tunnels.")
cikeGlobalInP2ExchgRejects = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly").setUnits("SA Payloads")
if mibBuilder.loadTexts: cikeGlobalInP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were received and rejected by all \ncurrently and previously active IPsec Phase-1 \nIKE Tunnels.")
cikeGlobalInP2SaDelRequests = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly").setUnits("Notification Payloads")
if mibBuilder.loadTexts: cikeGlobalInP2SaDelRequests.setDescription("The total number of IPsec Phase-2 security\nassociation delete requests received by all \ncurrently and previously\n active and IPsec Phase-1 IKE Tunnels.")
cikeGlobalOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cikeGlobalOutOctets.setDescription("The total number of octets sent by all currently\nand previously active and IPsec Phase-1 \nIKE Tunnels.")
cikeGlobalOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cikeGlobalOutPkts.setDescription("The total number of packets sent by all currently\nand previously active and IPsec Phase-1 \nTunnels.")
cikeGlobalOutDropPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cikeGlobalOutDropPkts.setDescription("The total number of packets which were dropped\nduring send processing by all currently \nand previously\n active IPsec Phase-1 IKE Tunnels.")
cikeGlobalOutNotifys = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly").setUnits("Notification Payloads")
if mibBuilder.loadTexts: cikeGlobalOutNotifys.setDescription("The total number of notifys sent by all currently\nand previously active IPsec Phase-1 IKE Tunnels.")
cikeGlobalOutP2Exchgs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly").setUnits("SA Payloads")
if mibBuilder.loadTexts: cikeGlobalOutP2Exchgs.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were sent by all currently and previously \nactive IPsec Phase-1 IKE Tunnels.")
cikeGlobalOutP2ExchgInvalids = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly").setUnits("SA Payloads")
if mibBuilder.loadTexts: cikeGlobalOutP2ExchgInvalids.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were sent and found to be invalid by \nall currently and previously active IPsec Phase-1 \nTunnels.")
cikeGlobalOutP2ExchgRejects = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly").setUnits("SA Payloads")
if mibBuilder.loadTexts: cikeGlobalOutP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were sent and rejected by all currently and\n previously active IPsec Phase-1 IKE Tunnels.")
cikeGlobalOutP2SaDelRequests = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly").setUnits("Notification Payloads")
if mibBuilder.loadTexts: cikeGlobalOutP2SaDelRequests.setDescription("The total number of IPsec Phase-2 SA\ndelete requests sent by all currently and \npreviously active IPsec Phase-1 IKE Tunnels.")
cikeGlobalInitTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly").setUnits("SAs")
if mibBuilder.loadTexts: cikeGlobalInitTunnels.setDescription("The total number of IPsec Phase-1 IKE\nTunnels which were locally initiated.")
cikeGlobalInitTunnelFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly").setUnits("SAs")
if mibBuilder.loadTexts: cikeGlobalInitTunnelFails.setDescription("The total number of IPsec Phase-1 IKE Tunnels\nwhich were locally initiated and failed to activate.")
cikeGlobalRespTunnelFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly").setUnits("SAs")
if mibBuilder.loadTexts: cikeGlobalRespTunnelFails.setDescription("The total number of IPsec Phase-1 IKE Tunnels\nwhich were remotely initiated and failed to activate.")
cikeGlobalSysCapFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cikeGlobalSysCapFails.setDescription("The total number of system capacity failures\nwhich occurred during processing of all current \nand previously active IPsec Phase-1 IKE Tunnels.")
cikeGlobalAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cikeGlobalAuthFails.setDescription("The total number of authentications which ended\nin failure by all current and previous IPsec Phase-1\nIKE Tunnels.")
cikeGlobalDecryptFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cikeGlobalDecryptFails.setDescription("The total number of decryptions which ended\nin failure by all current and previous IPsec Phase-1\nIKE Tunnels.")
cikeGlobalHashValidFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 25), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cikeGlobalHashValidFails.setDescription("The total number of hash validations which ended\nin failure by all current and previous IPsec Phase-1\nIKE Tunnels.")
cikeGlobalNoSaFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 1, 26), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cikeGlobalNoSaFails.setDescription("The total number of non-existent Security Association\nin failures which occurred during processing of \nall current and previous IPsec Phase-1 IKE Tunnels.")
cikePeerTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2))
if mibBuilder.loadTexts: cikePeerTable.setDescription("The IPsec Phase-1 Internet Key Exchange Peer Table.\nThere is one entry in this table for each IPsec\nPhase-1 IKE peer association which is currently\nassociated with an active IPsec Phase-1 Tunnel.\nThe IPsec Phase-1 IKE Tunnel associated with this\nIPsec Phase-1 IKE peer association may or may not\nbe currently active.")
cikePeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalType"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalValue"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteType"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteValue"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerIntIndex"))
if mibBuilder.loadTexts: cikePeerEntry.setDescription("Each entry contains the attributes associated\nwith an IPsec Phase-1 IKE peer association.")
cikePeerLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 1), IkePeerType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerLocalType.setDescription("The type of local peer identity.  The local peer\nmay be identified by:\n1. an IP address, or\n2. a host name.")
cikePeerLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 2), DisplayString()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerLocalValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is a host name, then this is\nthe host name used to identify the local peer.")
cikePeerRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 3), IkePeerType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerRemoteType.setDescription("The type of remote peer identity.  The remote peer\nmay be identified by:\n1. an IP address, or\n2. a host name.")
cikePeerRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 4), DisplayString()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerRemoteValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is a host name, then this is\nthe host name used to identify the remote peer.")
cikePeerIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerIntIndex.setDescription("The internal index of the local-remote\npeer association.  This internal index is used \nto uniquely identify multiple associations between \nthe local and remote peer.")
cikePeerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 6), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePeerLocalAddr.setDescription("The IP address of the local peer.")
cikePeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 7), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePeerRemoteAddr.setDescription("The IP address of the remote peer.")
cikePeerActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 8), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePeerActiveTime.setDescription("The length of time that the peer association has\nexisted in hundredths of a second.")
cikePeerActiveTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePeerActiveTunnelIndex.setDescription("The index of the active IPsec Phase-1 IKE Tunnel\n(cikeTunIndex in the cikeTunnelTable) for this peer\nassociation.  If an IPsec Phase-1 IKE Tunnel is\nnot currently active, then the value of this\nobject will be zero.")
cikeTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3))
if mibBuilder.loadTexts: cikeTunnelTable.setDescription("The IPsec Phase-1 Internet Key Exchange Tunnel Table.\nThere is one entry in this table for each active IPsec\nPhase-1 IKE Tunnel.")
cikeTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunIndex"))
if mibBuilder.loadTexts: cikeTunnelEntry.setDescription("Each entry contains the attributes associated with\nan active IPsec Phase-1 IKE Tunnel.")
cikeTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikeTunIndex.setDescription("The index of the IPsec Phase-1 IKE Tunnel Table.\nThe value of the index is a number which begins \nat one and is incremented with each tunnel that \nis created. The value of this object will \nwrap at 2,147,483,647.")
cikeTunLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 2), IkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunLocalType.setDescription("The type of local peer identity.  The local\npeer may be identified by:\n 1. an IP address, or\n 2. a host name.")
cikeTunLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunLocalValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is a host name, then this is\nthe host name used to identify the local peer.")
cikeTunLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 4), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunLocalAddr.setDescription("The IP address of the local endpoint for the IPsec\nPhase-1 IKE Tunnel.")
cikeTunLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunLocalName.setDescription("The DNS name of the local IP address for\nthe IPsec Phase-1 IKE Tunnel. If the DNS \nname associated with the local tunnel endpoint \nis not known, then the value of this\n object will be a NULL string.")
cikeTunRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 6), IkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunRemoteType.setDescription("The type of remote peer identity.\nThe remote peer may be identified by:\n 1. an IP address, or\n 2. a host name.")
cikeTunRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunRemoteValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is a host name, then \nthis is the host name used to identify the \nremote peer.")
cikeTunRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 8), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunRemoteAddr.setDescription("The IP address of the remote endpoint for the IPsec\nPhase-1 IKE Tunnel.")
cikeTunRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunRemoteName.setDescription("The DNS name of the remote IP address of IPsec Phase-1\nIKE Tunnel. If the DNS name associated with the remote\ntunnel endpoint is not known, then the value of this\nobject will be a NULL string.")
cikeTunNegoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 10), IkeNegoMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunNegoMode.setDescription("The negotiation mode of the IPsec Phase-1 IKE Tunnel.")
cikeTunDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 11), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunDiffHellmanGrp.setDescription("The Diffie Hellman Group used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 12), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunEncryptAlgo.setDescription("The encryption algorithm used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunHashAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 13), IkeHashAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHashAlgo.setDescription("The hash algorithm used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 14), IkeAuthMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunAuthMethod.setDescription("The authentication method used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-1 IKE Tunnel\nin seconds.")
cikeTunActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 16), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunActiveTime.setDescription("The length of time the IPsec Phase-1 IKE tunnel has been\nactive in hundredths of seconds.")
cikeTunSaRefreshThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunSaRefreshThreshold.setDescription("The security association refresh threshold in seconds.")
cikeTunTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunTotalRefreshes.setDescription("The total number of security associations\nrefreshes performed.")
cikeTunInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInOctets.setDescription("The total number of octets received by\nthis IPsec Phase-1 IKE Tunnel.")
cikeTunInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInPkts.setDescription("The total number of packets received by\nthis IPsec Phase-1 IKE Tunnel.")
cikeTunInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInDropPkts.setDescription("The total number of packets dropped\nby this IPsec Phase-1 IKE Tunnel during \nreceive processing.")
cikeTunInNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInNotifys.setDescription("The total number of notifys received by\nthis IPsec Phase-1 IKE Tunnel.")
cikeTunInP2Exchgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInP2Exchgs.setDescription("The total number of IPsec Phase-2\nexchanges received by\n this IPsec Phase-1 IKE Tunnel.")
cikeTunInP2ExchgInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInP2ExchgInvalids.setDescription("The total number of IPsec Phase-2\nexchanges received and found to be invalid \nby this IPsec Phase-1 IKE Tunnel.")
cikeTunInP2ExchgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges\nreceived and rejected by this IPsec Phase-1 \nTunnel.")
cikeTunInP2SaDelRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunInP2SaDelRequests.setDescription("The total number of IPsec Phase-2\nsecurity association delete requests received \nby this IPsec Phase-1 IKE Tunnel.")
cikeTunOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutOctets.setDescription("The total number of octets sent by this IPsec Phase-1\nIKE Tunnel.")
cikeTunOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutPkts.setDescription("The total number of packets sent by this IPsec Phase-1\nIKE Tunnel.")
cikeTunOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutDropPkts.setDescription("The total number of packets dropped by this\nIPsec Phase-1 IKE Tunnel during send processing.")
cikeTunOutNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutNotifys.setDescription("The total number of notifys sent by this\nIPsec Phase-1 Tunnel.")
cikeTunOutP2Exchgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutP2Exchgs.setDescription("The total number of IPsec Phase-2 exchanges sent by\nthis IPsec Phase-1 IKE Tunnel.")
cikeTunOutP2ExchgInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutP2ExchgInvalids.setDescription("The total number of IPsec Phase-2 exchanges sent and\nfound to be invalid by this IPsec Phase-1 IKE Tunnel.")
cikeTunOutP2ExchgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges sent and\nrejected by this IPsec Phase-1 IKE Tunnel.")
cikeTunOutP2SaDelRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunOutP2SaDelRequests.setDescription("The total number of IPsec Phase-2 security association\ndelete requests sent by this IPsec Phase-1 IKE Tunnel.")
cikeTunStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 3, 1, 35), TunnelStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cikeTunStatus.setDescription("The status of the MIB table row.\n\nThis object can be used to bring the tunnel down \nby setting value of this object to destroy(2).\n\nThis object cannot be used to create \na MIB table row.")
cikePeerCorrTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4))
if mibBuilder.loadTexts: cikePeerCorrTable.setDescription("The IPsec Phase-1 Internet Key Exchange Peer\nAssociation to IPsec Phase-2 Tunnel\nCorrelation Table. There is one entry in\nthis table for each active IPsec Phase-2\nTunnel.")
cikePeerCorrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrLocalType"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrLocalValue"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrRemoteType"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrRemoteValue"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrIntIndex"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrSeqNum"))
if mibBuilder.loadTexts: cikePeerCorrEntry.setDescription("Each entry contains the attributes of an\nIPsec Phase-1 IKE Peer Association to IPsec\nPhase-2 Tunnel Correlation.")
cikePeerCorrLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 1), IkePeerType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerCorrLocalType.setDescription("The type of local peer identity. The local peer\nmay be identified by:\n1. an IP address, or\n2. a host name.")
cikePeerCorrLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 2), DisplayString()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerCorrLocalValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is a host name, then this is\nthe host name used to identify the local peer.")
cikePeerCorrRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 3), IkePeerType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerCorrRemoteType.setDescription("The type of remote peer identity. The remote peer\nmay be identified by:\n1. an IP address, or\n2. a host name.")
cikePeerCorrRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 4), DisplayString()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerCorrRemoteValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is a host name, then this is\nthe host name used to identify the remote peer.")
cikePeerCorrIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerCorrIntIndex.setDescription("The internal index of the local-remote\npeer association.  This internal index is \nused to uniquely identify multiple associations \nbetween the local and remote peer.")
cikePeerCorrSeqNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikePeerCorrSeqNum.setDescription("The sequence number of the local-remote\npeer association.  This sequence number is \nused to uniquely identify multiple instances \nof an unique association between\n the local and remote peer.")
cikePeerCorrIpSecTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePeerCorrIpSecTunIndex.setDescription("The index of the active IPsec Phase-2 Tunnel\n(cipSecTunIndex in the cipSecTunnelTable) for this\nIPsec Phase-1 IKE Peer Association.")
cikePhase1GWStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5))
if mibBuilder.loadTexts: cikePhase1GWStatsTable.setDescription("Phase-1 IKE stats information is included in this table.\nEach entry is related to a specific gateway which is \nidentified by 'cmgwIndex'.")
cikePhase1GWStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1)).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"))
if mibBuilder.loadTexts: cikePhase1GWStatsEntry.setDescription("Each entry contains the attributes of an Phase-1 IKE stats\ninformation for the related gateway.\n\nThere is only one entry for each gateway. The entry \nis created when a gateway up and cannot be deleted.")
cikePhase1GWActiveTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWActiveTunnels.setDescription("The number of currently active IPsec\nPhase-1 IKE Tunnels.")
cikePhase1GWPreviousTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWPreviousTunnels.setDescription("The total number of previously active\nIPsec Phase-1 IKE Tunnels.")
cikePhase1GWInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInOctets.setDescription("The total number of octets received by all currently\nand previously active IPsec Phase-1 IKE Tunnels.")
cikePhase1GWInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInPkts.setDescription("The total number of packets received by all\ncurrently and previously active IPsec \nPhase-1 IKE Tunnels.")
cikePhase1GWInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInDropPkts.setDescription("The total number of packets which were\ndropped during receive processing by all \ncurrently and previously\nactive IPsec Phase-1 IKE Tunnels.")
cikePhase1GWInNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInNotifys.setDescription("The total number of notifys received by\nall currently and previously active IPsec \nPhase-1 IKE Tunnels.")
cikePhase1GWInP2Exchgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInP2Exchgs.setDescription("The total number of IPsec Phase-2 exchanges\nreceived by all currently and previously \nactive IPsec Phase-1 IKE Tunnels.")
cikePhase1GWInP2ExchgInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInP2ExchgInvalids.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were received and found to be invalid \nby all currently and previously active IPsec \nPhase-1 IKE Tunnels.")
cikePhase1GWInP2ExchgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were received and rejected by all \ncurrently and previously active IPsec Phase-1 \nIKE Tunnels.")
cikePhase1GWInP2SaDelRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInP2SaDelRequests.setDescription("The total number of IPsec Phase-2 'Security\nAssociation' delete requests received by all \ncurrently and previously active and IPsec \nPhase-1 IKE Tunnels.")
cikePhase1GWOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutOctets.setDescription("The total number of octets sent by all currently\nand previously active and IPsec Phase-1 \nIKE Tunnels.")
cikePhase1GWOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutPkts.setDescription("The total number of packets sent by all currently\nand previously active and IPsec Phase-1 \nTunnels.")
cikePhase1GWOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutDropPkts.setDescription("The total number of packets which were dropped\nduring send processing by all currently \nand previously\nactive IPsec Phase-1 IKE Tunnels.")
cikePhase1GWOutNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutNotifys.setDescription("The total number of notifys sent by all currently\nand previously active IPsec Phase-1 IKE Tunnels.")
cikePhase1GWOutP2Exchgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutP2Exchgs.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were sent by all currently and previously \nactive IPsec Phase-1 IKE Tunnels.")
cikePhase1GWOutP2ExchgInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutP2ExchgInvalids.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were sent and found to be invalid by \nall currently and previously active IPsec Phase-1 \nTunnels.")
cikePhase1GWOutP2ExchgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges\nwhich were sent and rejected by all currently and\npreviously active IPsec Phase-1 IKE Tunnels.")
cikePhase1GWOutP2SaDelRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWOutP2SaDelRequests.setDescription("The total number of IPsec Phase-2 SA\ndelete requests sent by all currently and \npreviously active IPsec Phase-1 IKE Tunnels.")
cikePhase1GWInitTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInitTunnels.setDescription("The total number of IPsec Phase-1 IKE\nTunnels which were locally initiated.")
cikePhase1GWInitTunnelFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWInitTunnelFails.setDescription("The total number of IPsec Phase-1 IKE Tunnels\nwhich were locally initiated and failed to activate.")
cikePhase1GWRespTunnelFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWRespTunnelFails.setDescription("The total number of IPsec Phase-1 IKE Tunnels\nwhich were remotely initiated and failed to activate.")
cikePhase1GWSysCapFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWSysCapFails.setDescription("The total number of system capacity failures\nwhich occurred during processing of all current \nand previously active IPsec Phase-1 IKE Tunnels.")
cikePhase1GWAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWAuthFails.setDescription("The total number of authentications which ended\nin failure by all current and previous IPsec Phase-1\nIKE Tunnels.")
cikePhase1GWDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWDecryptFails.setDescription("The total number of decryptions which ended\nin failure by all current and previous IPsec Phase-1\nIKE Tunnels.")
cikePhase1GWHashValidFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWHashValidFails.setDescription("The total number of hash validations which ended\nin failure by all current and previous IPsec Phase-1\nIKE Tunnels.")
cikePhase1GWNoSaFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 2, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikePhase1GWNoSaFails.setDescription("The total number of non-existent 'Security Association'\nfailures occurred during processing of current and \nprevious IPsec Phase-1 IKE Tunnels.")
cipSecPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3))
cipSecGlobalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1))
cipSecGlobalActiveTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecGlobalActiveTunnels.setDescription("The total number of currently active\nIPsec Phase-2 Tunnels.")
cipSecGlobalPreviousTunnels = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly").setUnits("Phase-2 Tunnels")
if mibBuilder.loadTexts: cipSecGlobalPreviousTunnels.setDescription("The total number of previously active\nIPsec Phase-2 Tunnels.")
cipSecGlobalInOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cipSecGlobalInOctets.setDescription("The total number of octets received by all\ncurrent and previous IPsec Phase-2 Tunnels. \nThis value is\naccumulated BEFORE determining whether or not\nthe packet should be decompressed. See also\ncipSecGlobalInOctWraps for the number of times\nthis counter has wrapped.")
cipSecGlobalHcInOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecGlobalHcInOctets.setDescription("A high capacity count of the total number of\noctets received by all current and previous\nIPsec Phase-2 Tunnels. This value is accumulated\nBEFORE determining whether or not the packet\nshould be decompressed.")
cipSecGlobalInOctWraps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly").setUnits("Integral units")
if mibBuilder.loadTexts: cipSecGlobalInOctWraps.setDescription("The number of times the global octets received\ncounter (cipSecGlobalInOctets) has wrapped.")
cipSecGlobalInDecompOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cipSecGlobalInDecompOctets.setDescription("The total number of decompressed octets received\nby all current and previous IPsec Phase-2 Tunnels.  \nThis value is accumulated AFTER the packet is \ndecompressed. If compression is not being used, \nthis value will match the value of cipSecGlobalInOctets. \nSee also cipSecGlobalInDecompOctWraps\n for the number of times this counter has wrapped.")
cipSecGlobalHcInDecompOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecGlobalHcInDecompOctets.setDescription("A high capacity count of the total number\nof decompressed octets received by all current \nand previous IPsec Phase-2 Tunnels.  This value \nis accumulated AFTER the packet is decompressed.\n If compression is not being used, this value \n will match the value of cipSecGlobalHcInOctets.")
cipSecGlobalInDecompOctWraps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly").setUnits("Integral units")
if mibBuilder.loadTexts: cipSecGlobalInDecompOctWraps.setDescription("The number of times the global decompressed\noctets received counter\n (cipSecGlobalInDecompOctets) has wrapped.")
cipSecGlobalInPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalInPkts.setDescription("The total number of packets received\nby all current and previous\n IPsec Phase-2 Tunnels.")
cipSecGlobalInDrops = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalInDrops.setDescription("The total number of packets dropped\nduring receive processing by all current and previous \nIPsec Phase-2 Tunnels. This count does\nNOT include packets dropped due to \nAnti-Replay processing.")
cipSecGlobalInReplayDrops = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalInReplayDrops.setDescription("The total number of packets dropped during\nreceive processing due to Anti-Replay \nprocessing by all current and previous IPsec\n Phase-2 Tunnels.")
cipSecGlobalInAuths = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly").setUnits("Events")
if mibBuilder.loadTexts: cipSecGlobalInAuths.setDescription("The total number of inbound authentication's\nperformed by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecGlobalInAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cipSecGlobalInAuthFails.setDescription("The total number of inbound authentication's\nwhich ended in failure by all current and previous \nIPsec Phase-2 Tunnels.")
cipSecGlobalInDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalInDecrypts.setDescription("The total number of inbound decryption's\nperformed by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecGlobalInDecryptFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalInDecryptFails.setDescription("The total number of inbound decryption's\nwhich ended in failure by all current and \nprevious IPsec Phase-2 Tunnels.")
cipSecGlobalOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cipSecGlobalOutOctets.setDescription("The total number of octets sent by all\ncurrent and previous IPsec Phase-2 Tunnels.  \nThis value is accumulated AFTER determining \nwhether or not the packet should be compressed.  \nSee also cipSecGlobalOutOctWraps for the\n number of times this counter has wrapped.")
cipSecGlobalHcOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecGlobalHcOutOctets.setDescription("A high capacity count of the total number\nof octets sent by all current and previous \nIPsec Phase-2 Tunnels.  This value is accumulated \nAFTER determining whether or not the packet should \nbe compressed.")
cipSecGlobalOutOctWraps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly").setUnits("Integral units")
if mibBuilder.loadTexts: cipSecGlobalOutOctWraps.setDescription("The number of times the global octets sent counter\n(cipSecGlobalOutOctets) has wrapped.")
cipSecGlobalOutUncompOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cipSecGlobalOutUncompOctets.setDescription("The total number of uncompressed octets sent\nby all current and previous IPsec Phase-2 Tunnels.  \nThis value is accumulated BEFORE the packet is \ncompressed. If compression is not being used, this \nvalue will match the value of cipSecGlobalOutOctets. \nSee also cipSecGlobalOutDecompOctWraps for the number \nof times this counter has wrapped.")
cipSecGlobalHcOutUncompOctets = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 20), Counter64()).setMaxAccess("readonly").setUnits("Octets")
if mibBuilder.loadTexts: cipSecGlobalHcOutUncompOctets.setDescription("A high capacity count of the total number of\nuncompressed octets sent by all current and previous \nIPsec Phase-2 Tunnels.  This value is accumulated \nBEFORE the packet is compressed.  If compression is \nnot being used, this value will match the\n      value of cipSecGlobalHcOutOctets.")
cipSecGlobalOutUncompOctWraps = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 21), Counter32()).setMaxAccess("readonly").setUnits("Integral units")
if mibBuilder.loadTexts: cipSecGlobalOutUncompOctWraps.setDescription("The number of times the global uncompressed\noctets sent counter (cipSecGlobalOutUncompOctets) \nhas wrapped.")
cipSecGlobalOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 22), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalOutPkts.setDescription("The total number of packets sent by all\ncurrent and previous\n IPsec Phase-2 Tunnels.")
cipSecGlobalOutDrops = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 23), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalOutDrops.setDescription("The total number of packets dropped during send\nprocessing by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecGlobalOutAuths = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 24), Counter32()).setMaxAccess("readonly").setUnits("Events")
if mibBuilder.loadTexts: cipSecGlobalOutAuths.setDescription("The total number of outbound authentication's\nperformed by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecGlobalOutAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 25), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cipSecGlobalOutAuthFails.setDescription("The total number of outbound authentication's\nwhich ended in failure\n by all current and previous IPsec Phase-2 Tunnels.")
cipSecGlobalOutEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 26), Counter32()).setMaxAccess("readonly").setUnits("Packets")
if mibBuilder.loadTexts: cipSecGlobalOutEncrypts.setDescription("The total number of outbound encryption's performed\nby all current and previous IPsec Phase-2 Tunnels.")
cipSecGlobalOutEncryptFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 27), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cipSecGlobalOutEncryptFails.setDescription("The total number of outbound encryption's\nwhich ended in failure by all current and \nprevious IPsec Phase-2 Tunnels.")
cipSecGlobalProtocolUseFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 28), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cipSecGlobalProtocolUseFails.setDescription("The total number of protocol use failures\nwhich occurred during processing of all current \nand previously active IPsec Phase-2 Tunnels.")
cipSecGlobalNoSaFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 29), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cipSecGlobalNoSaFails.setDescription("The total number of non-existent\nSecurity Association in failures which occurred \nduring processing of all current\n and previous IPsec Phase-2 Tunnels.")
cipSecGlobalSysCapFails = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 1, 30), Counter32()).setMaxAccess("readonly").setUnits("Failures")
if mibBuilder.loadTexts: cipSecGlobalSysCapFails.setDescription("The total number of system capacity failures\nwhich occurred during processing of all current \nand previously active IPsec Phase-2 Tunnels.")
cipSecTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2))
if mibBuilder.loadTexts: cipSecTunnelTable.setDescription("The IPsec Phase-2 Tunnel Table.\nThere is one entry in this table for \neach active IPsec Phase-2 Tunnel.")
cipSecTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunIndex"))
if mibBuilder.loadTexts: cipSecTunnelEntry.setDescription("Each entry contains the attributes\nassociated with an active IPsec Phase-2 Tunnel.")
cipSecTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cipSecTunIndex.setDescription("The index of the IPsec Phase-2 Tunnel Table.\nThe value of the index is a number which begins \nat one and is incremented with each tunnel that \nis created. The value of this object will wrap \nat 2,147,483,647.")
cipSecTunIkeTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunIkeTunnelIndex.setDescription("The index of the associated IPsec Phase-1\nIKE Tunnel.\n (cikeTunIndex in the cikeTunnelTable)")
cipSecTunIkeTunnelAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunIkeTunnelAlive.setDescription("An indicator which specifies whether or not the\nIPsec Phase-1 IKE Tunnel currently exists.")
cipSecTunLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 4), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunLocalAddr.setDescription("The IP address of the local endpoint for the IPsec\nPhase-2 Tunnel.")
cipSecTunRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 5), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunRemoteAddr.setDescription("The IP address of the remote endpoint for the IPsec\nPhase-2 Tunnel.")
cipSecTunKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 6), KeyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunKeyType.setDescription("The type of key used by the IPsec Phase-2 Tunnel.")
cipSecTunEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 7), EncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunEncapMode.setDescription("The encapsulation mode used by the\nIPsec Phase-2 Tunnel.")
cipSecTunLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunLifeSize.setDescription("The negotiated LifeSize of the\nIPsec Phase-2 Tunnel in kilobytes.")
cipSecTunLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunLifeTime.setDescription("The negotiated LifeTime of the\nIPsec Phase-2 Tunnel in seconds.")
cipSecTunActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 10), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunActiveTime.setDescription("The length of time the IPsec Phase-2\nTunnel has been\n active in hundredths of seconds.")
cipSecTunSaLifeSizeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunSaLifeSizeThreshold.setDescription("The security association LifeSize refresh\nthreshold in kilobytes.")
cipSecTunSaLifeTimeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunSaLifeTimeThreshold.setDescription("The security association LifeTime refresh\nthreshold in seconds.")
cipSecTunTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunTotalRefreshes.setDescription("The total number of security\nassociation refreshes performed.")
cipSecTunExpiredSaInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunExpiredSaInstances.setDescription("The total number of security associations\nwhich have expired.")
cipSecTunCurrentSaInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunCurrentSaInstances.setDescription("The number of security associations\nwhich are currently active or expiring.")
cipSecTunInSaDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 16), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInSaDiffHellmanGrp.setDescription("The Diffie Hellman Group used\nby the inbound security association of the \nIPsec Phase-2 Tunnel.")
cipSecTunInSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 17), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInSaEncryptAlgo.setDescription("The encryption algorithm used by the inbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunInSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 18), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInSaAhAuthAlgo.setDescription("The authentication algorithm used by the inbound\nauthentication header (AH) security association of\nthe IPsec Phase-2 Tunnel.")
cipSecTunInSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 19), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInSaEspAuthAlgo.setDescription("The authentication algorithm used by the inbound\nencapsulation security protocol (ESP) security \nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunInSaDecompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 20), CompAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInSaDecompAlgo.setDescription("The decompression algorithm used by the inbound\nsecurity association of the IPsec Phase-2 Tunnel.")
cipSecTunOutSaDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 21), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutSaDiffHellmanGrp.setDescription("The Diffie Hellman Group used by the outbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunOutSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 22), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutSaEncryptAlgo.setDescription("The encryption algorithm used by the outbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunOutSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 23), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutSaAhAuthAlgo.setDescription("The authentication algorithm used by the outbound\nauthentication header (AH) security association of\nthe IPsec Phase-2 Tunnel.")
cipSecTunOutSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 24), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutSaEspAuthAlgo.setDescription("The authentication algorithm used by the inbound\nencapsulation security protocol (ESP) \nsecurity association of the IPsec Phase-2 Tunnel.")
cipSecTunOutSaCompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 25), CompAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutSaCompAlgo.setDescription("The compression algorithm used by the inbound\nsecurity association of the IPsec Phase-2 Tunnel.")
cipSecTunInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInOctets.setDescription("The total number of octets received by this IPsec\nPhase-2 Tunnel.  This value is accumulated\nBEFORE determining whether or not the packet should be\ndecompressed.  See also cipSecTunInOctWraps for the\nnumber of times this counter has wrapped.")
cipSecTunHcInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHcInOctets.setDescription("A high capacity count of the total number of octets\nreceived by this IPsec Phase-2 Tunnel.  This value is\naccumulated BEFORE determining whether or not the packet\nshould be decompressed.")
cipSecTunInOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInOctWraps.setDescription("The number of times the octets received counter\n(cipSecTunInOctets) has wrapped.")
cipSecTunInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInDecompOctets.setDescription("The total number of decompressed octets received\nby this IPsec Phase-2 Tunnel. This value is \naccumulated AFTER the packet is decompressed. \nIf compression is not being\n used, this value will match the value of \n cipSecTunInOctets.  See also cipSecTunInDecompOctWraps \n for the number of times\n this counter has wrapped.")
cipSecTunHcInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHcInDecompOctets.setDescription("A high capacity count of the total number of decompressed\noctets received by this IPsec Phase-2 Tunnel.  This value\nis accumulated AFTER the packet is decompressed. If\ncompression is not being used, this value will match the\nvalue of cipSecTunHcInOctets.")
cipSecTunInDecompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInDecompOctWraps.setDescription("The number of times the decompressed\noctets received counter\n (cipSecTunInDecompOctets) has wrapped.")
cipSecTunInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInPkts.setDescription("The total number of packets received\nby this IPsec Phase-2 Tunnel.")
cipSecTunInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInDropPkts.setDescription("The total number of packets dropped\nduring receive processing by this IPsec Phase-2 \nTunnel. This count does NOT include\n packets dropped due to Anti-Replay processing.")
cipSecTunInReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInReplayDropPkts.setDescription("The total number of packets dropped during\nreceive processing due to Anti-Replay processing \nby this IPsec Phase-2 Tunnel.")
cipSecTunInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInAuths.setDescription("The total number of inbound\nauthentication's performed by this \nIPsec Phase-2 Tunnel.")
cipSecTunInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInAuthFails.setDescription("The total number of inbound authentication's\nwhich ended in\n failure by this IPsec Phase-2 Tunnel .")
cipSecTunInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInDecrypts.setDescription("The total number of inbound decryption's performed\nby this IPsec Phase-2 Tunnel.")
cipSecTunInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunInDecryptFails.setDescription("The total number of inbound decryption's\nwhich ended in failure\n by this IPsec Phase-2 Tunnel.")
cipSecTunOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutOctets.setDescription("The total number of octets sent by this IPsec\nPhase-2 Tunnel.  This value is accumulated\nAFTER determining whether or not the packet should \nbe compressed.  See also cipSecTunOutOctWraps for\nthe number of times this counter has wrapped.")
cipSecTunHcOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 40), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHcOutOctets.setDescription("A high capacity count of the total number of octets\nsent by this IPsec Phase-2 Tunnel.  This value is\naccumulated AFTER determining whether or not the \npacket\nshould be compressed.")
cipSecTunOutOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutOctWraps.setDescription("The number of times the out octets counter\n(cipSecTunOutOctets) has wrapped.")
cipSecTunOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutUncompOctets.setDescription("The total number of uncompressed octets sent\nby this IPsec Phase-2 Tunnel.  This value \nis accumulated BEFORE the packet is compressed. \nIf compression is not being used, this value \nwill match the value of cipSecTunOutOctets.\n See also cipSecTunOutDecompOctWraps for the \n number of times this counter has wrapped.")
cipSecTunHcOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 43), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHcOutUncompOctets.setDescription("A high capacity count of the total number\nof uncompressed octets sent by this IPsec \nPhase-2 Tunnel.  This value is accumulated BEFORE \nthe packet is compressed. If compression\n is not being used, this value will match the value\n of cipSecTunHcOutOctets.")
cipSecTunOutUncompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutUncompOctWraps.setDescription("The number of times the uncompressed octets sent\ncounter (cipSecTunOutUncompOctets) has wrapped.")
cipSecTunOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutPkts.setDescription("The total number of packets sent by this\nIPsec Phase-2 Tunnel.")
cipSecTunOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutDropPkts.setDescription("The total number of packets dropped during\nsend processing by this IPsec Phase-2 Tunnel.")
cipSecTunOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutAuths.setDescription("The total number of outbound authentication's performed\nby this IPsec Phase-2 Tunnel.")
cipSecTunOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutAuthFails.setDescription("The total number of outbound\nauthentication's which ended in failure \nby this IPsec Phase-2 Tunnel.")
cipSecTunOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutEncrypts.setDescription("The total number of outbound encryption's performed\nby this IPsec Phase-2 Tunnel.")
cipSecTunOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunOutEncryptFails.setDescription("The total number of outbound encryption's\nwhich ended in failure by this IPsec Phase-2 Tunnel.")
cipSecTunStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 2, 1, 51), TunnelStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTunStatus.setDescription("The status of the MIB table row.\n\nThis object can be used to bring the tunnel down\nby setting value of this object to destroy(2).\nWhen the value is set to destroy(2), the SA\nbundle is destroyed and this row is deleted\nfrom this table.\n\nWhen this MIB value is queried, the value of\nactive(1) is always returned, if the instance \nexists.\n\nThis object cannot be used to create a MIB \ntable row.")
cipSecEndPtTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3))
if mibBuilder.loadTexts: cipSecEndPtTable.setDescription("The IPsec Phase-2 Tunnel Endpoint Table.\nThis table contains an entry for each \nactive endpoint associated with an IPsec\n Phase-2 Tunnel.")
cipSecEndPtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunIndex"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtIndex"))
if mibBuilder.loadTexts: cipSecEndPtEntry.setDescription("An IPsec Phase-2 Tunnel Endpoint entry.")
cipSecEndPtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cipSecEndPtIndex.setDescription("The number of the Endpoint associated with the\nIPsec Phase-2 Tunnel Table.  The value of this\nindex is a number which begins at one and \nis incremented with each Endpoint associated \nwith an IPsec Phase-2 Tunnel.\nThe value of this object will wrap at 2,147,483,647.")
cipSecEndPtLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtLocalName.setDescription("The DNS name of the local Endpoint.")
cipSecEndPtLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 3), EndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtLocalType.setDescription("The type of identity for the local Endpoint.\nPossible values are:\n1) a single IP address, or\n2) an IP address range, or\n3) an IP subnet.")
cipSecEndPtLocalAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 4), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtLocalAddr1.setDescription("The local Endpoint's first IP address specification.\n\nIf the local Endpoint type is single IP address, \nthen this is the value of the IP address.\n\nIf the local Endpoint type is IP subnet, then this\nis the value of the subnet.\n\nIf the local Endpoint type is IP address range, \nthen this is the value of beginning IP address \nof the range.")
cipSecEndPtLocalAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 5), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtLocalAddr2.setDescription("The local Endpoint's second IP address specification.\n\nIf the local Endpoint type is single IP address, \nthen this is the value of the IP address.\n\nIf the local Endpoint type is IP subnet, then this\nis the value of the subnet mask.\n\nIf the local Endpoint type is IP address range, \nthen this is the value of ending IP address \nof the range.")
cipSecEndPtLocalProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtLocalProtocol.setDescription("The protocol number of the local Endpoint's traffic.")
cipSecEndPtLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtLocalPort.setDescription("The port number of the local Endpoint's traffic.")
cipSecEndPtRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtRemoteName.setDescription("The DNS name of the remote Endpoint.")
cipSecEndPtRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 9), EndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtRemoteType.setDescription("The type of identity for the remote Endpoint.\nPossible values are:\n1) a single IP address, or\n2) an IP address range, or\n3) an IP subnet.")
cipSecEndPtRemoteAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 10), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtRemoteAddr1.setDescription("The remote Endpoint's first IP address specification.\n\nIf the remote Endpoint type is single IP address, \nthen this is the value of the IP address.\n\nIf the remote Endpoint type is IP subnet, then this\nis the value of the subnet.\n\nIf the remote Endpoint type is IP address range, \nthen this is the value of beginning IP address \nof the range.")
cipSecEndPtRemoteAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 11), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtRemoteAddr2.setDescription("The remote Endpoint's second IP address specification.\n\nIf the remote Endpoint type is single IP address, \nthen this is the value of the IP address.\n\nIf the remote Endpoint type is IP subnet, then this\nis the value of the subnet mask.\n\nIf the remote Endpoint type is IP address range, \nthen this is the value of ending IP address of \nthe range.")
cipSecEndPtRemoteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtRemoteProtocol.setDescription("The protocol number of the remote Endpoint's traffic.")
cipSecEndPtRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtRemotePort.setDescription("The port number of the remote Endpoint's traffic.")
cipSecSpiTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4))
if mibBuilder.loadTexts: cipSecSpiTable.setDescription("The IPsec Phase-2 Security Protection Index Table.\nThis table contains an entry for each active \nand expiring security\n association.")
cipSecSpiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunIndex"), (0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiIndex"))
if mibBuilder.loadTexts: cipSecSpiEntry.setDescription("Each entry contains the attributes associated with\nactive and expiring IPsec Phase-2 \nsecurity associations.")
cipSecSpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cipSecSpiIndex.setDescription("The number of the SPI associated with the\nPhase-2 Tunnel Table.  The value of this \nindex is a number which begins at one and is \nincremented with each SPI associated with an \nIPsec Phase-2 Tunnel.  The value of this \nobject will wrap at 2,147,483,647.")
cipSecSpiDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("in", 1), ("out", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecSpiDirection.setDescription("The direction of the SPI.")
cipSecSpiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecSpiValue.setDescription("The value of the SPI.")
cipSecSpiProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("ah", 1), ("esp", 2), ("ipcomp", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecSpiProtocol.setDescription("The protocol of the SPI.")
cipSecSpiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 4, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("active", 1), ("expiring", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecSpiStatus.setDescription("The status of the SPI.")
cipSecPhase2GWStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5))
if mibBuilder.loadTexts: cipSecPhase2GWStatsTable.setDescription("Phase-2 IPsec stats information is included in this table.\nEach entry is related to a specific gateway which is \nidentified by 'cmgwIndex'")
cipSecPhase2GWStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1)).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"))
if mibBuilder.loadTexts: cipSecPhase2GWStatsEntry.setDescription("Each entry contains the attributes of an Phase-2 IPsec stats\ninformation for the related gateway.\n\nThere is only one entry for each gateway. The entry \nis created when a gateway up and cannot be deleted.")
cipSecPhase2GWActiveTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWActiveTunnels.setDescription("The total number of currently active\nIPsec Phase-2 Tunnels.")
cipSecPhase2GWPreviousTunnels = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWPreviousTunnels.setDescription("The total number of previously active\nIPsec Phase-2 Tunnels.")
cipSecPhase2GWInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInOctets.setDescription("The total number of octets received by all\ncurrent and previous IPsec Phase-2 Tunnels. \nThis value is accumulated BEFORE determining \nwhether or not the packet should be decompressed. \nSee also cipSecGlobalInOctWraps for the number\nof times this counter has wrapped.")
cipSecPhase2GWInOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInOctWraps.setDescription("The number of times the global octets received\ncounter (cipSecGlobalInOctets) has wrapped.")
cipSecPhase2GWInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInDecompOctets.setDescription("The total number of decompressed octets received\nby all current and previous IPsec Phase-2 Tunnels.  \nThis value is accumulated AFTER the packet is \ndecompressed. If compression is not being used, \nthis value will match the value of cipSecGlobalInOctets. \nSee also cipSecGlobalInDecompOctWraps\nfor the number of times this counter has wrapped.")
cipSecPhase2GWInDecompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInDecompOctWraps.setDescription("The number of times the global decompressed\noctets received counter (cipSecGlobalInDecompOctets) \nhas wrapped.")
cipSecPhase2GWInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInPkts.setDescription("The total number of packets received\nby all current and previous IPsec Phase-2 Tunnels.")
cipSecPhase2GWInDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInDrops.setDescription("The total number of packets dropped\nduring receive processing by all current and previous \nIPsec Phase-2 Tunnels. This count does NOT include \npackets dropped due to Anti-Replay processing.")
cipSecPhase2GWInReplayDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInReplayDrops.setDescription("The total number of packets dropped during\nreceive processing due to Anti-Replay \nprocessing by all current and previous IPsec\nPhase-2 Tunnels.")
cipSecPhase2GWInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInAuths.setDescription("The total number of inbound authentication's\nperformed by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecPhase2GWInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInAuthFails.setDescription("The total number of inbound authentication's\nwhich ended in failure by all current and previous \nIPsec Phase-2 Tunnels.")
cipSecPhase2GWInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInDecrypts.setDescription("The total number of inbound decryption's\nperformed by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecPhase2GWInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWInDecryptFails.setDescription("The total number of inbound decryption's\nwhich ended in failure by all current and \nprevious IPsec Phase-2 Tunnels.")
cipSecPhase2GWOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutOctets.setDescription("The total number of octets sent by all\ncurrent and previous IPsec Phase-2 Tunnels.  \nThis value is accumulated AFTER determining \nwhether or not the packet should be compressed.  \nSee also cipSecGlobalOutOctWraps for the\nnumber of times this counter has wrapped.")
cipSecPhase2GWOutOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutOctWraps.setDescription("The number of times the global octets sent counter\n(cipSecGlobalOutOctets) has wrapped.")
cipSecPhase2GWOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutUncompOctets.setDescription("The total number of uncompressed octets sent\nby all current and previous IPsec Phase-2 Tunnels.  \nThis value is accumulated BEFORE the packet is \ncompressed. If compression is not being used, this \nvalue will match the value of cipSecGlobalOutOctets. \nSee also cipSecGlobalOutDecompOctWraps for the number \nof times this counter has wrapped.")
cipSecPhase2GWOutUncompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutUncompOctWraps.setDescription("The number of times the global uncompressed\noctets sent counter (cipSecGlobalOutUncompOctets) \nhas wrapped.")
cipSecPhase2GWOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutPkts.setDescription("The total number of packets sent by all\ncurrent and previous IPsec Phase-2 \nTunnels.")
cipSecPhase2GWOutDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutDrops.setDescription("The total number of packets dropped during send\nprocessing by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecPhase2GWOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutAuths.setDescription("The total number of outbound authentication's\nperformed by all current and previous IPsec \nPhase-2 Tunnels.")
cipSecPhase2GWOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutAuthFails.setDescription("The total number of outbound authentication's\nwhich ended in failure\nby all current and previous IPsec Phase-2 Tunnels.")
cipSecPhase2GWOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutEncrypts.setDescription("The total number of outbound encryption's performed\nby all current and previous IPsec Phase-2 Tunnels.")
cipSecPhase2GWOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWOutEncryptFails.setDescription("The total number of outbound encryption's\nwhich ended in failure by all current and \nprevious IPsec Phase-2 Tunnels.")
cipSecPhase2GWProtocolUseFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWProtocolUseFails.setDescription("The total number of protocol use failures\nwhich occurred during processing of all current \nand previously active IPsec Phase-2 Tunnels.")
cipSecPhase2GWNoSaFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWNoSaFails.setDescription("The total number of non-existent\nSecurity Association in failures which occurred \nduring processing of all current\nand previous IPsec Phase-2 Tunnels.")
cipSecPhase2GWSysCapFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 3, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecPhase2GWSysCapFails.setDescription("The total number of system capacity failures\nwhich occurred during processing of all current \nand previously active IPsec Phase-2 Tunnels.")
cipSecHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4))
cipSecHistGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 1))
cipSecHistGlobalCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 1, 1))
cipSecHistTableSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecHistTableSize.setDescription("The window size of the IPsec Phase-1 and Phase-2\nHistory Tables.\n\nThe IPsec Phase-1 and Phase-2 History Tables are\nimplemented as a sliding window in which only the\nlast n entries are maintained.  This object is used\nspecify the number of entries which will be \nmaintained in the IPsec Phase-1 and \nPhase-2 History Tables.\n\nAn implementation may choose suitable minimum and \nmaximum values for this element based on the local \npolicy and available resources. If an SNMP SET request \nspecifies a value outside this window for this element, \na BAD VALUE may be returned.")
cipSecHistCheckPoint = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("ready", 1), ("checkPoint", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecHistCheckPoint.setDescription("The current state of check point processing.\n\nThis object will return ready when the agent is \nready to create on-demand history entries for \nactive IPsec Tunnels or checkPoint when the \nagent is currently creating on-demand history \nentries for active IPsec Tunnels.\n\nBy setting this value to checkPoint, the agent \nwill create:\na) an entry in the IPsec Phase-1 Tunnel History \n   for each active IPsec Phase-1 Tunnel and\nb) an entry in the IPsec Phase-2 Tunnel History \n   Table and an entry in the IPsec Phase-2 \n   Tunnel EndPoint History Table\n   for each active IPsec Phase-2 Tunnel.")
cipSecHistPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2))
cikeTunnelHistTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1))
if mibBuilder.loadTexts: cikeTunnelHistTable.setDescription("The IPsec Phase-1 Internet Key Exchange Tunnel\nHistory Table.  This table is implemented as a \nsliding window in which only the last n entries \nare maintained.  The maximum number of entries\n is specified by the cipSecHistTableSize object.")
cikeTunnelHistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistIndex"))
if mibBuilder.loadTexts: cikeTunnelHistEntry.setDescription("Each entry contains the attributes\nassociated with a previously active IPsec \nPhase-1 IKE Tunnel.")
cikeTunHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikeTunHistIndex.setDescription("The index of the IPsec Phase-1 IKE Tunnel History\nTable.  The value of the index is a number which \nbegins at one and is incremented with each \ntunnel that ends. The value of this object \nwill wrap at 2,147,483,647.")
cikeTunHistTermReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,4,6,7,2,3,5,)).subtype(namedValues=NamedValues(("other", 1), ("normal", 2), ("operRequest", 3), ("peerDelRequest", 4), ("peerLost", 5), ("localFailure", 6), ("checkPointReg", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistTermReason.setDescription("The reason the IPsec Phase-1 IKE Tunnel was terminated.\nPossible reasons include:\n1 = other\n2 = normal termination\n3 = operator request\n4 = peer delete request was received\n5 = contact with peer was lost\n6 = local failure occurred.\n7 = operator initiated check point request")
cikeTunHistActiveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistActiveIndex.setDescription("The index of the previously active IPsec\nPhase-1 IKE Tunnel.")
cikeTunHistPeerLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 4), IkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistPeerLocalType.setDescription("The type of local peer identity.  The local peer\nmay be identified by:\n 1. an IP address, or\n 2. a host name.")
cikeTunHistPeerLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistPeerLocalValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is a host name, then this is\nthe host name used to identify the local peer.")
cikeTunHistPeerIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistPeerIntIndex.setDescription("The internal index of the local-remote peer\nassociation.  This internal index is used to \nuniquely identify multiple associations between \nthe local and remote peer.")
cikeTunHistPeerRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 7), IkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistPeerRemoteType.setDescription("The type of remote peer identity.  The remote\npeer may be identified by:\n 1. an IP address, or\n 2. a host name.")
cikeTunHistPeerRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistPeerRemoteValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is a host name, then this is\nthe host name used to identify the remote peer.")
cikeTunHistLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 9), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistLocalAddr.setDescription("The IP address of the local endpoint for the IPsec\nPhase-1 IKE Tunnel.")
cikeTunHistLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistLocalName.setDescription("The DNS name of the local IP address for\nthe IPsec Phase-1 IKE Tunnel. If the DNS \nname associated with the local tunnel endpoint \nis not known, then the value of this\n object will be a NULL string.")
cikeTunHistRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 11), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistRemoteAddr.setDescription("The IP address of the remote endpoint for the IPsec\nPhase-1 IKE Tunnel.")
cikeTunHistRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistRemoteName.setDescription("The DNS name of the remote IP address of IPsec Phase-1\nIKE Tunnel. If the DNS name associated with the remote\ntunnel endpoint is not known, then the value of this\nobject will be a NULL string.")
cikeTunHistNegoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 13), IkeNegoMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistNegoMode.setDescription("The negotiation mode of the IPsec Phase-1 IKE Tunnel.")
cikeTunHistDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 14), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistDiffHellmanGrp.setDescription("The Diffie Hellman Group used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunHistEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 15), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistEncryptAlgo.setDescription("The encryption algorithm used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunHistHashAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 16), IkeHashAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistHashAlgo.setDescription("The hash algorithm used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunHistAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 17), IkeAuthMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistAuthMethod.setDescription("The authentication method used in IPsec Phase-1 IKE\nnegotiations.")
cikeTunHistLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-1 IKE Tunnel\nin seconds.")
cikeTunHistStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 19), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistStartTime.setDescription("The value of sysUpTime in hundredths of seconds\nwhen the IPsec Phase-1 IKE tunnel was started.")
cikeTunHistActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 20), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistActiveTime.setDescription("The length of time the IPsec Phase-1 IKE tunnel was been\nactive in hundredths of seconds.")
cikeTunHistTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistTotalRefreshes.setDescription("The total number of security associations\nrefreshes performed.")
cikeTunHistTotalSas = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistTotalSas.setDescription("The total number of security associations\nused during the\n life of the IPsec Phase-1 IKE Tunnel.")
cikeTunHistInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInOctets.setDescription("The total number of octets\nreceived by this IPsec Phase-1\n IKE Tunnel.")
cikeTunHistInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInPkts.setDescription("The total number of packets received\nby this IPsec Phase-1\n IKE Tunnel.")
cikeTunHistInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInDropPkts.setDescription("The total number of packets dropped\nby this IPsec Phase-1\n IKE Tunnel during receive processing.")
cikeTunHistInNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInNotifys.setDescription("The total number of notifys received\nby this IPsec Phase-1\n IKE Tunnel.")
cikeTunHistInP2Exchgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInP2Exchgs.setDescription("The total number of IPsec Phase-2\nexchanges received by\n this IPsec Phase-1 IKE Tunnel.")
cikeTunHistInP2ExchgInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInP2ExchgInvalids.setDescription("The total number of IPsec Phase-2\nexchanges received and\n found to be invalid by this IPsec Phase-1 IKE Tunnel.")
cikeTunHistInP2ExchgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInP2ExchgRejects.setDescription("The total number of IPsec Phase-2\nexchanges received and\n rejected by this IPsec Phase-1 IKE Tunnel.")
cikeTunHistInP2SaDelRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistInP2SaDelRequests.setDescription("The total number of IPsec Phase-2 security association\ndelete requests received by this IPsec \nPhase-1 IKE Tunnel.")
cikeTunHistOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutOctets.setDescription("The total number of octets sent by this IPsec Phase-1\nIKE Tunnel.")
cikeTunHistOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutPkts.setDescription("The total number of packets sent by this IPsec Phase-1\nIKE Tunnel.")
cikeTunHistOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutDropPkts.setDescription("The total number of packets dropped\nby this IPsec Phase-1\n IKE Tunnel during send processing.")
cikeTunHistOutNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutNotifys.setDescription("The total number of notifys sent by this IPsec Phase-1\nIKE Tunnel.")
cikeTunHistOutP2Exchgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutP2Exchgs.setDescription("The total number of IPsec Phase-2 exchanges sent by\nthis IPsec Phase-1 IKE Tunnel.")
cikeTunHistOutP2ExchgInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutP2ExchgInvalids.setDescription("The total number of IPsec Phase-2 exchanges sent and\nfound to be invalid by this IPsec Phase-1 IKE Tunnel.")
cikeTunHistOutP2ExchgRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutP2ExchgRejects.setDescription("The total number of IPsec Phase-2 exchanges sent and\nrejected by this IPsec Phase-1 IKE Tunnel.")
cikeTunHistOutP2SaDelRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 2, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeTunHistOutP2SaDelRequests.setDescription("The total number of IPsec Phase-2 security association\ndelete requests sent by this IPsec Phase-1 IKE Tunnel.")
cipSecHistPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3))
cipSecTunnelHistTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1))
if mibBuilder.loadTexts: cipSecTunnelHistTable.setDescription("The IPsec Phase-2 Tunnel History Table.\nThis table is implemented as a sliding \nwindow in which only the\nlast n entries are maintained.  The maximum number \nof entries\nis specified by the cipSecHistTableSize object.")
cipSecTunnelHistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistIndex"))
if mibBuilder.loadTexts: cipSecTunnelHistEntry.setDescription("Each entry contains the attributes associated with\na previously active IPsec Phase-2 Tunnel.")
cipSecTunHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cipSecTunHistIndex.setDescription("The index of the IPsec Phase-2 Tunnel History Table.\nThe value of the index is a number which \nbegins at one and is incremented with each tunnel \nthat ends. The value\nof this object will wrap at 2,147,483,647.")
cipSecTunHistTermReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,4,6,2,3,5,7,)).subtype(namedValues=NamedValues(("other", 1), ("normal", 2), ("operRequest", 3), ("peerDelRequest", 4), ("peerLost", 5), ("seqNumRollOver", 6), ("checkPointReq", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistTermReason.setDescription("The reason the IPsec Phase-2 Tunnel was terminated.\nPossible reasons include:\n1 = other\n2 = normal termination\n3 = operator request\n4 = peer delete request was received\n5 = contact with peer was lost\n6 = local failure occurred\n7 = operator initiated check point request")
cipSecTunHistActiveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistActiveIndex.setDescription("The index of the previously active\nIPsec Phase-2 Tunnel.")
cipSecTunHistIkeTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistIkeTunnelIndex.setDescription("The index of the associated IPsec Phase-1 Tunnel\n(cikeTunIndex in the cikeTunnelTable).")
cipSecTunHistLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 5), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistLocalAddr.setDescription("The IP address of the local endpoint for the IPsec\nPhase-2 Tunnel.")
cipSecTunHistRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 6), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistRemoteAddr.setDescription("The IP address of the remote endpoint for the IPsec\nPhase-2 Tunnel.")
cipSecTunHistKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 7), KeyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistKeyType.setDescription("The type of key used by the IPsec Phase-2 Tunnel.")
cipSecTunHistEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 8), EncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistEncapMode.setDescription("The encapsulation mode used by the\nIPsec Phase-2 Tunnel.")
cipSecTunHistLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistLifeSize.setDescription("The negotiated LifeSize of the IPsec Phase-2 Tunnel in\nkilobytes.")
cipSecTunHistLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-2 Tunnel in\nseconds.")
cipSecTunHistStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistStartTime.setDescription("The value of sysUpTime in hundredths of seconds\nwhen the IPsec Phase-2 Tunnel was started.")
cipSecTunHistActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 12), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistActiveTime.setDescription("The length of time the IPsec Phase-2 Tunnel has been\nactive in hundredths of seconds.")
cipSecTunHistTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistTotalRefreshes.setDescription("The total number of security association refreshes\nperformed.")
cipSecTunHistTotalSas = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistTotalSas.setDescription("The total number of security associations used\nduring the\n life of the IPsec Phase-2 Tunnel.")
cipSecTunHistInSaDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 15), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInSaDiffHellmanGrp.setDescription("The Diffie Hellman Group used by the inbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunHistInSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 16), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInSaEncryptAlgo.setDescription("The encryption algorithm used by the inbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunHistInSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 17), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInSaAhAuthAlgo.setDescription("The authentication algorithm used by the inbound\nauthentication header (AH) security association of\nthe IPsec Phase-2 Tunnel.")
cipSecTunHistInSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 18), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInSaEspAuthAlgo.setDescription("The authentication algorithm used by the inbound\nencapsulation security protocol (ESP) \nsecurity association of\nthe IPsec Phase-2 Tunnel.")
cipSecTunHistInSaDecompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 19), CompAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInSaDecompAlgo.setDescription("The decompression algorithm used by the inbound\nsecurity association of the IPsec Phase-2 Tunnel.")
cipSecTunHistOutSaDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 20), DiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutSaDiffHellmanGrp.setDescription("The Diffie Hellman Group used by the outbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunHistOutSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 21), EncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutSaEncryptAlgo.setDescription("The encryption algorithm used by the outbound security\nassociation of the IPsec Phase-2 Tunnel.")
cipSecTunHistOutSaAhAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 22), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutSaAhAuthAlgo.setDescription("The authentication algorithm used by the outbound\nauthentication header (AH) security association of\nthe IPsec Phase-2 Tunnel.")
cipSecTunHistOutSaEspAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 23), AuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutSaEspAuthAlgo.setDescription("The authentication algorithm used by the inbound\nencapsulation security protocol (ESP) \nsecurity association of the IPsec Phase-2 Tunnel.")
cipSecTunHistOutSaCompAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 24), CompAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutSaCompAlgo.setDescription("The compression algorithm used by the inbound\nsecurity association of the IPsec Phase-2 Tunnel.")
cipSecTunHistInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInOctets.setDescription("The total number of octets received by this IPsec\nPhase-2 Tunnel.  This value is accumulated\nBEFORE determining whether or not the packet should \nbe decompressed.  See also cipSecTunInOctWraps for \nthe number of times this counter has wrapped.")
cipSecTunHistHcInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistHcInOctets.setDescription("A high capacity count of the total number of octets\nreceived by this IPsec Phase-2 Tunnel.  This value is\naccumulated BEFORE determining whether or not \nthe packet should be decompressed.")
cipSecTunHistInOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInOctWraps.setDescription("The number of times the octets received counter\n(cipSecTunInOctets) has wrapped.")
cipSecTunHistInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInDecompOctets.setDescription("The total number of decompressed octets received by this\nIPsec Phase-2 Tunnel.  This value is accumulated AFTER\nthe packet is decompressed. If compression is not being\nused, this value will match the value of cipSecTunHistInOctets.\nSee also cipSecTunInDecompOctWraps for the number of times\nthis counter has wrapped.")
cipSecTunHistHcInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistHcInDecompOctets.setDescription("A high capacity count of the total number of decompressed\noctets received by this IPsec Phase-2 Tunnel.  This value\nis accumulated AFTER the packet is decompressed. If\ncompression is not being used, this value will match the\nvalue of cipSecTunHistHcInOctets.")
cipSecTunHistInDecompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInDecompOctWraps.setDescription("The number of times the decompressed octets\nreceived counter (cipSecTunInDecompOctets) has wrapped.")
cipSecTunHistInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInPkts.setDescription("The total number of packets received by this\nIPsec Phase-2 Tunnel.")
cipSecTunHistInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInDropPkts.setDescription("The total number of packets dropped during\nreceive processing by this IPsec Phase-2 Tunnel. \nThis count does NOT include packets\n dropped due to Anti-Replay processing.")
cipSecTunHistInReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInReplayDropPkts.setDescription("The total number of packets dropped during\nreceive processing due to Anti-Replay processing \nby this IPsec Phase-2 Tunnel.")
cipSecTunHistInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInAuths.setDescription("The total number of inbound authentication's\nperformed\n by this IPsec Phase-2 Tunnel.")
cipSecTunHistInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInAuthFails.setDescription("The total number of inbound authentication's\nwhich ended in\n failure by this IPsec Phase-2 Tunnel .")
cipSecTunHistInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInDecrypts.setDescription("The total number of inbound decryption's performed\nby this IPsec Phase-2 Tunnel.")
cipSecTunHistInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistInDecryptFails.setDescription("The total number of inbound decryption's\nwhich ended in failure\n by this IPsec Phase-2 Tunnel.")
cipSecTunHistOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutOctets.setDescription("The total number of octets sent by this IPsec\nPhase-2 Tunnel.  This value is accumulated\nAFTER determining whether or not the \npacket should be\ncompressed.  See also cipSecTunOutOctWraps for the\nnumber of times this counter has wrapped.")
cipSecTunHistHcOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 39), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistHcOutOctets.setDescription("A high capacity count of the total number of octets\nsent by this IPsec Phase-2 Tunnel.  This value \nis accumulated AFTER determining whether or not \nthe packet should be\ncompressed.")
cipSecTunHistOutOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutOctWraps.setDescription("The number of times the octets sent counter\n(cipSecTunOutOctets) has wrapped.")
cipSecTunHistOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutUncompOctets.setDescription("The total number of uncompressed octets sent by this\nIPsec Phase-2 Tunnel.  This value is accumulated BEFORE\nthe packet is compressed. If compression is not being\nused, this value will match the value of \ncipSecTunHistOutOctets.  See also \ncipSecTunOutDecompOctWraps for the number of times\nthis counter has wrapped.")
cipSecTunHistHcOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 42), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistHcOutUncompOctets.setDescription("A high capacity count of the total\nnumber of uncompressed octets sent by this \nIPsec Phase-2 Tunnel.  This value is accumulated \nBEFORE the packet is compressed. If compression\nis not being used, this value will match the value of\ncipSecTunHistHcOutOctets.")
cipSecTunHistOutUncompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutUncompOctWraps.setDescription("The number of times the uncompressed octets sent counter\n(cipSecTunOutUncompOctets) has wrapped.")
cipSecTunHistOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutPkts.setDescription("The total number of packets sent by this\nIPsec Phase-2 Tunnel.")
cipSecTunHistOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutDropPkts.setDescription("The total number of packets dropped\nduring send processing\n by this IPsec Phase-2 Tunnel.")
cipSecTunHistOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutAuths.setDescription("The total number of outbound authentication's performed\nby this IPsec Phase-2 Tunnel.")
cipSecTunHistOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutAuthFails.setDescription("The total number of outbound authentication's\nwhich ended in\n failure by this IPsec Phase-2 Tunnel.")
cipSecTunHistOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutEncrypts.setDescription("The total number of outbound encryption's performed\nby this IPsec Phase-2 Tunnel.")
cipSecTunHistOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 1, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecTunHistOutEncryptFails.setDescription("The total number of outbound encryption's\nwhich ended in failure\n by this IPsec Phase-2 Tunnel.")
cipSecEndPtHistTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2))
if mibBuilder.loadTexts: cipSecEndPtHistTable.setDescription("The IPsec Phase-2 Tunnel Endpoint History Table.\nThis table is implemented as a \nsliding window in which only the\nlast n entries are maintained.  \nThe maximum number of entries\nis specified by the cipSecHistTableSize object.")
cipSecEndPtHistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistIndex"))
if mibBuilder.loadTexts: cipSecEndPtHistEntry.setDescription("Each entry contains the attributes associated with\na previously active IPsec Phase-2 Tunnel Endpoint.")
cipSecEndPtHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cipSecEndPtHistIndex.setDescription("The number of the previously active\nEndpoint associated\n with a IPsec Phase-2 Tunnel Table.  The value \n of this index is a number which begins at \n one and is incremented with each Endpoint \n associated with an IPsec Phase-2 Tunnel.\n The value of this object will wrap at 2,147,483,647.")
cipSecEndPtHistTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistTunIndex.setDescription("The index  of the previously active IPsec\nPhase-2 Tunnel Table.")
cipSecEndPtHistActiveIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistActiveIndex.setDescription("The index  of the previously active Endpoint.")
cipSecEndPtHistLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistLocalName.setDescription("The DNS name of the local Endpoint.")
cipSecEndPtHistLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 5), EndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistLocalType.setDescription("The type of identity for the local Endpoint.\nPossible values are:\n1) a single IP address, or\n2) an IP address range, or\n3) an IP subnet.")
cipSecEndPtHistLocalAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 6), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistLocalAddr1.setDescription("The local Endpoint's first IP address specification.\n\nIf the local Endpoint type is single IP address, \nthen this is the value of the IP address.\n\nIf the local Endpoint type is IP subnet, then this\nis the value of the subnet.\n\nIf the local Endpoint type is IP address range, \nthen this is the value of beginning IP address of \nthe range.")
cipSecEndPtHistLocalAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 7), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistLocalAddr2.setDescription("The local Endpoint's second IP address specification.\n\nIf the local Endpoint type is single IP address, \nthen this is the value of the IP address.\n\nIf the local Endpoint type is IP subnet, then this\nis the value of the subnet mask.\n\nIf the local Endpoint type is IP address range, \nthen this\nis the value of ending IP address of the range.")
cipSecEndPtHistLocalProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistLocalProtocol.setDescription("The protocol number of the local Endpoint's traffic.")
cipSecEndPtHistLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistLocalPort.setDescription("The port number of the local Endpoint's traffic.")
cipSecEndPtHistRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistRemoteName.setDescription("The DNS name of the remote Endpoint.")
cipSecEndPtHistRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 11), EndPtType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistRemoteType.setDescription("The type of identity for the remote Endpoint.\nPossible values are:\n1) a single IP address, or\n2) an IP address range, or\n3) an IP subnet.")
cipSecEndPtHistRemoteAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 12), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistRemoteAddr1.setDescription("The remote Endpoint's first IP address specification.\n\nIf the remote Endpoint type is single IP address, \nthen this\nis the value of the IP address.\n\nIf the remote Endpoint type is IP subnet, then this\nis the value of the subnet.\n\nIf the remote Endpoint type is IP address range, \nthen this\nis the value of beginning IP address of the range.")
cipSecEndPtHistRemoteAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 13), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistRemoteAddr2.setDescription("The remote Endpoint's second IP address specification.\n\nIf the remote Endpoint type is single IP address, \nthen this\nis the value of the IP address.\n\nIf the remote Endpoint type is IP subnet, then this\nis the value of the subnet mask.\n\nIf the remote Endpoint type is IP address range, \nthen this\nis the value of ending IP address of the range.")
cipSecEndPtHistRemoteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistRemoteProtocol.setDescription("The protocol number of the remote Endpoint's traffic.")
cipSecEndPtHistRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 4, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecEndPtHistRemotePort.setDescription("The port number of the remote Endpoint's traffic.")
cipSecFailures = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5))
cipSecFailGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 1))
cipSecFailGlobalCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 1, 1))
cipSecFailTableSize = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecFailTableSize.setDescription("The window size of the IPsec Phase-1 and Phase-2\nFailure Tables.\n\nThe IPsec Phase-1 and Phase-2 Failure Tables are\nimplemented as a sliding window in which only the\nlast n entries are maintained.  This object is used\nspecify the number of entries which will be \nmaintained in the IPsec Phase-1 and Phase-2 Failure \nTables.\n\nAn implementation may choose suitable minimum and \nmaximum values for this element based on the local \npolicy and available resources. If an SNMP SET request \nspecifies a value outside this window for this element, \na BAD VALUE may be returned.")
cipSecFailPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2))
cikeFailTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1))
if mibBuilder.loadTexts: cikeFailTable.setDescription("The IPsec Phase-1 Failure Table.\nThis table is implemented as a sliding \nwindow in which only the last n entries are \nmaintained.  The maximum number of entries\nis specified by the cipSecFailTableSize object.")
cikeFailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailIndex"))
if mibBuilder.loadTexts: cikeFailEntry.setDescription("Each entry contains the attributes associated\nwith\n an IPsec Phase-1 failure.")
cikeFailIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cikeFailIndex.setDescription("The IPsec Phase-1 Failure Table index.\nThe value of the index is a number which \nbegins at one and is incremented with each \nIPsec Phase-1 failure. The value\nof this object will wrap at 2,147,483,647.")
cikeFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(9,7,10,12,8,5,17,3,14,1,2,4,15,16,11,13,6,)).subtype(namedValues=NamedValues(("other", 1), ("proposalFailure", 10), ("peerCertUnavailable", 11), ("peerCertNotValid", 12), ("localCertExpired", 13), ("crlFailure", 14), ("peerEncodingError", 15), ("nonExistentSa", 16), ("operRequest", 17), ("peerDelRequest", 2), ("peerLost", 3), ("localFailure", 4), ("authFailure", 5), ("hashValidation", 6), ("encryptFailure", 7), ("internalError", 8), ("sysCapExceeded", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailReason.setDescription("The reason for the failure.  Possible reasons include:\n1 = other\n2 = peer delete request was received\n3 = contact with peer was lost\n4 = local failure occurred\n5 = authentication failure\n6 = hash validation failure\n7 = encryption failure\n8 = internal error occurred\n9 = system capacity failure\n10 = proposal failure\n11 = peer's certificate is unavailable\n12 = peer's certificate was found invalid\n13 = local certificate expired\n14 = certificate revoke list (crl) failure\n15 = peer encoding error\n16 = non-existent security association\n17 = operator requested termination.")
cikeFailTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailTime.setDescription("The value of sysUpTime in hundredths of seconds\nat the time of the failure.")
cikeFailLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 4), IkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailLocalType.setDescription("The type of local peer identity.  The local peer\nmay be identified by:\n 1. an IP address, or\n 2. a host name.")
cikeFailLocalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailLocalValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is a host name, then this is\nthe host name used to identify the local peer.")
cikeFailRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 6), IkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailRemoteType.setDescription("The type of remote peer identity.  The remote\npeer may be identified by:\n 1. an IP address, or\n 2. a host name.")
cikeFailRemoteValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailRemoteValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is a host name, then this is\nthe host name used to identify the remote peer.")
cikeFailLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 8), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailLocalAddr.setDescription("The IP address of the local peer.")
cikeFailRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 2, 1, 1, 9), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cikeFailRemoteAddr.setDescription("The IP address of the remote peer.")
cipSecFailPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3))
cipSecFailTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1))
if mibBuilder.loadTexts: cipSecFailTable.setDescription("The IPsec Phase-2 Failure Table.\nThis table is implemented as a sliding window \nin which only the last n entries are maintained.  \nThe maximum number of entries\nis specified by the cipSecFailTableSize object.")
cipSecFailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1)).setIndexNames((0, "CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailIndex"))
if mibBuilder.loadTexts: cipSecFailEntry.setDescription("Each entry contains the attributes associated with\nan IPsec Phase-1 failure.")
cipSecFailIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cipSecFailIndex.setDescription("The IPsec Phase-2 Failure Table index.\nThe value of the index is a number which \nbegins at one and is incremented with each \nIPsec Phase-1 failure. The value\nof this object will wrap at 2,147,483,647.")
cipSecFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(12,8,9,5,7,2,4,16,14,1,13,3,6,15,10,11,)).subtype(namedValues=NamedValues(("other", 1), ("outAuthFailure", 10), ("compression", 11), ("sysCapExceeded", 12), ("peerDelRequest", 13), ("peerLost", 14), ("seqNumRollOver", 15), ("operRequest", 16), ("internalError", 2), ("peerEncodingError", 3), ("proposalFailure", 4), ("protocolUseFail", 5), ("nonExistentSa", 6), ("decryptFailure", 7), ("encryptFailure", 8), ("inAuthFailure", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecFailReason.setDescription("The reason for the failure.  Possible reasons\ninclude:\n  1 = other\n  2 = internal error occurred\n  3 = peer encoding error\n  4 = proposal failure\n  5 = protocol use failure\n  6 = non-existent security association\n  7 = decryption failure\n  8 = encryption failure\n  9 = inbound authentication failure\n 10 = outbound authentication failure\n 11 = compression failure\n 12 = system capacity failure\n 13 = peer delete request was received\n 14 = contact with peer was lost\n 15 = sequence number rolled over\n 16 = operator requested termination.")
cipSecFailTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecFailTime.setDescription("The value of sysUpTime in hundredths of seconds\nat the time of the failure.")
cipSecFailTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecFailTunnelIndex.setDescription("The Phase-2 Tunnel index (cipSecTunIndex).")
cipSecFailSaSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecFailSaSpi.setDescription("The security association SPI value.")
cipSecFailPktSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 6), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecFailPktSrcAddr.setDescription("The packet's source IP address.")
cipSecFailPktDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 5, 3, 1, 1, 7), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cipSecFailPktDstAddr.setDescription("The packet's destination IP address.")
cipSecTrapCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6))
cipSecTrapCntlIkeTunnelStart = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 1), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIkeTunnelStart.setDescription("This object defines the administrative state of\nsending the IPsec IKE Phase-1 Tunnel Start TRAP")
cipSecTrapCntlIkeTunnelStop = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 2), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIkeTunnelStop.setDescription("This object defines the administrative state\nof sending the\n IPsec IKE Phase-1 Tunnel Stop TRAP")
cipSecTrapCntlIkeSysFailure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 3), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIkeSysFailure.setDescription("This object defines the administrative state\nof sending the\n IPsec IKE Phase-1 System Failure TRAP")
cipSecTrapCntlIkeCertCrlFailure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 4), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIkeCertCrlFailure.setDescription("This object defines the administrative\nstate of sending the\n IPsec IKE Phase-1 Certificate/CRL Failure TRAP")
cipSecTrapCntlIkeProtocolFail = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 5), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIkeProtocolFail.setDescription("This object defines the administrative\nstate of sending the\n IPsec IKE Phase-1 Protocol Failure TRAP")
cipSecTrapCntlIkeNoSa = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 6), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIkeNoSa.setDescription("This object defines the administrative\nstate of sending the\n IPsec IKE Phase-1 No Security Association TRAP")
cipSecTrapCntlIpSecTunnelStart = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 7), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecTunnelStart.setDescription("This object defines the administrative state\nof sending the IPsec\n Phase-2 Tunnel Start TRAP")
cipSecTrapCntlIpSecTunnelStop = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 8), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecTunnelStop.setDescription("This object defines the administrative\nstate of sending the IPsec\n Phase-2 Tunnel Stop TRAP")
cipSecTrapCntlIpSecSysFailure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 9), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecSysFailure.setDescription("This object defines the administrative state\nof sending the IPsec\n Phase-2 System Failure TRAP")
cipSecTrapCntlIpSecSetUpFailure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 10), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecSetUpFailure.setDescription("This object defines the administrative state\nof sending the IPsec\n Phase-2 Set Up Failure TRAP")
cipSecTrapCntlIpSecEarlyTunTerm = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 11), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecEarlyTunTerm.setDescription("This object defines the administrative state\nof sending the IPsec\n Phase-2 Early Tunnel Termination TRAP")
cipSecTrapCntlIpSecProtocolFail = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 12), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecProtocolFail.setDescription("This object defines the administrative state\nof sending the IPsec\n Phase-2 Protocol Failure TRAP")
cipSecTrapCntlIpSecNoSa = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 171, 1, 6, 13), TrapStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipSecTrapCntlIpSecNoSa.setDescription("This object defines the administrative state\nof sending the IPsec\n Phase-2  No Security Association TRAP")
cipSecMIBNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 2))
cipSecMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0))
cipSecMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 3))
cipSecMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1))
cipSecMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 2))

# Augmentions

# Notifications

cikeTunnelStart = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 1)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunLifeTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cikeTunnelStart.setDescription("This notification is generated when an IPsec Phase-1\nIKE Tunnel becomes active.")
cikeTunnelStop = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 2)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cikeTunnelStop.setDescription("This notification is generated when an IPsec Phase-1\nIKE Tunnel becomes inactive.")
cikeSysFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 3)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cikeSysFailure.setDescription("This notification is generated when the processing for\nan IPsec Phase-1 IKE Tunnel experiences an internal\nor system capacity error.")
cikeCertCrlFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 4)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cikeCertCrlFailure.setDescription("This notification is generated when the processing for\nan IPsec Phase-1 IKE Tunnel experiences a Certificate\nor a Certificate Revoke List (CRL) related error.")
cikeProtocolFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 5)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cikeProtocolFailure.setDescription("This notification is generated when the processing for\nan IPsec Phase-1 IKE Tunnel experiences a protocol\nrelated error.")
cikeNoSa = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 6)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cikeNoSa.setDescription("This notification is generated when the processing for\nan IPsec Phase-1 IKE Tunnel experiences a non-existent\nsecurity association error.")
cipSecTunnelStart = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 7)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunLifeSize"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunLifeTime"), ) )
if mibBuilder.loadTexts: cipSecTunnelStart.setDescription("This notification is generated when an IPsec Phase-2\nTunnel becomes active.")
cipSecTunnelStop = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 8)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunActiveTime"), ) )
if mibBuilder.loadTexts: cipSecTunnelStop.setDescription("This notification is generated when an IPsec Phase-2\nTunnel becomes inactive.")
cipSecSysFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 9)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cipSecSysFailure.setDescription("This notification is generated when the processing for\nan IPsec Phase-2 Tunnel experiences an internal\nor system capacity error.")
cipSecSetUpFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 10)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ) )
if mibBuilder.loadTexts: cipSecSetUpFailure.setDescription("This notification is generated when the setup for\nan IPsec Phase-2 Tunnel fails.")
cipSecEarlyTunTerm = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 11)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunActiveTime"), ) )
if mibBuilder.loadTexts: cipSecEarlyTunTerm.setDescription("This notification is generated when an an IPsec Phase-2\nTunnel is terminated earily or before expected.")
cipSecProtocolFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 12)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunActiveTime"), ) )
if mibBuilder.loadTexts: cipSecProtocolFailure.setDescription("This notification is generated when the processing for\nan IPsec Phase-2 Tunnel experiences a protocol\nrelated error.")
cipSecNoSa = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 171, 2, 0, 13)).setObjects(*() )
if mibBuilder.loadTexts: cipSecNoSa.setDescription("This notification is generated when the processing for\nan IPsec Phase-2 Tunnel experiences a non-existent\nsecurity association error.")

# Groups

cipSecLevelsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 1)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecMibLevel"), ) )
if mibBuilder.loadTexts: cipSecLevelsGroup.setDescription("This group consists of a:\n1) IPsec MIB Level")
cipSecPhaseOneGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 2)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunRemoteType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunDiffHellmanGrp"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerActiveTunnelIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalDecryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunLocalValue"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunLocalName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunRemoteName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalHashValidFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalSysCapFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInitTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunNegoMode"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunLifeTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHashAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunStatus"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunAuthMethod"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunSaRefreshThreshold"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalOutNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalRespTunnelFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInitTunnelFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunEncryptAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalInP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunRemoteValue"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalActiveTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunLocalType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalNoSaFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerRemoteAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePeerCorrIpSecTunIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeGlobalPreviousTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunRemoteAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunOutP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunTotalRefreshes"), ) )
if mibBuilder.loadTexts: cipSecPhaseOneGroup.setDescription("This group consists of:\n1) IPsec Phase-1 Global Objects\n2) IPsec Phase-1 Peer Table\n3) IPsec Phase-1 Tunnel Table\n4) IPsec Phase-1 Correlation Table")
cipSecPhaseTwoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 3)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutDrops"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunSaLifeTimeThreshold"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunTotalRefreshes"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutSaDiffHellmanGrp"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunRemoteAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunKeyType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalHcOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtLocalType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutEncrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInDecrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiDirection"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInReplayDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInDecryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInReplayDrops"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInSaDiffHellmanGrp"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunLifeTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtLocalAddr1"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunEncapMode"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHcOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHcOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtLocalAddr2"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtLocalName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalActiveTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtRemoteProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalProtocolUseFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutSaEspAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunExpiredSaInstances"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalNoSaFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtRemoteAddr1"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtRemoteAddr2"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiStatus"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutUncompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunLifeSize"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtLocalPort"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalSysCapFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalHcOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunIkeTunnelAlive"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInSaAhAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHcInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutEncryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunSaLifeSizeThreshold"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInDecompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtRemoteName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInSaEncryptAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunCurrentSaInstances"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalHcInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInDrops"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInSaDecompAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunIkeTunnelIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHcInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutEncryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunStatus"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutSaEncryptAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInDecrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutSaAhAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutSaCompAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtLocalProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInDecompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtRemotePort"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunOutDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalHcInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInSaEspAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtRemoteType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalPreviousTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutUncompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSpiValue"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunInDecryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGlobalOutEncrypts"), ) )
if mibBuilder.loadTexts: cipSecPhaseTwoGroup.setDescription("This group consists of:\n1) IPsec Phase-2 Global Statistics\n2) IPsec Phase-2 Tunnel Table\n3) IPsec Phase-2 Endpoint Table\n4) IPsec Phase-2 Security Protection Index Table")
cipSecHistoryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 4)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistPeerRemoteType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistActiveIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistDiffHellmanGrp"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistEncryptAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistTunIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistLocalAddr2"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistLocalAddr1"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInSaEspAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInSaAhAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistRemoteAddr1"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistRemoteProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistRemoteAddr2"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInSaDecompAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistTotalRefreshes"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistTermReason"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutSaEncryptAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistLocalPort"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistPeerRemoteValue"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInDecrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistNegoMode"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutSaEspAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistTotalSas"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistStartTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistActiveIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInDecompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutUncompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistTotalSas"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInSaDiffHellmanGrp"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistHcInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistLifeTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistLocalName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistActiveIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistAuthMethod"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistLifeTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInReplayDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistLocalName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistRemoteName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutSaAhAuthAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistIkeTunnelIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistTermReason"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInDecryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecHistCheckPoint"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistRemotePort"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistActiveTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistPeerIntIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistRemoteType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistRemoteAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutSaDiffHellmanGrp"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistRemoteName"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistEncapMode"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutEncryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistHashAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistTotalRefreshes"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInSaEncryptAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistPeerLocalValue"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutSaCompAlgo"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecHistTableSize"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutEncrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistLocalProtocol"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistHcInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistHcOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistOutAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistPeerLocalType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEndPtHistLocalType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistStartTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistKeyType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistLifeSize"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunHistHcOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistInP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistRemoteAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunHistOutNotifys"), ) )
if mibBuilder.loadTexts: cipSecHistoryGroup.setDescription("This group consists of:\n1) IPsec History Global Objects\n2) IPsec Phase-1 History Objects\n3) IPsec Phase-2 History Objects")
cipSecFailuresGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 5)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailTunnelIndex"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailPktSrcAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailLocalAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailRemoteType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailTableSize"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailSaSpi"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailPktDstAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailReason"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailTime"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailLocalType"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailRemoteAddr"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailLocalValue"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecFailReason"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeFailRemoteValue"), ) )
if mibBuilder.loadTexts: cipSecFailuresGroup.setDescription("This group consists of:\n1) IPsec Failure Global Objects\n2) IPsec Phase-1 Tunnel Failure Table\n3) IPsec Phase-2 Tunnel Failure Table")
cipSecTrapCntlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 6)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecEarlyTunTerm"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIkeSysFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecTunnelStart"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecProtocolFail"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIkeTunnelStop"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIkeProtocolFail"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIkeCertCrlFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecSysFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecSetUpFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIkeTunnelStart"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIkeNoSa"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecNoSa"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTrapCntlIpSecTunnelStop"), ) )
if mibBuilder.loadTexts: cipSecTrapCntlGroup.setDescription("This group of objects controls the sending of IPsec TRAPs.")
cipSecNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 7)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecEarlyTunTerm"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunnelStop"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSetUpFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeProtocolFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunnelStop"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeTunnelStart"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeSysFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecNoSa"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeNoSa"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecSysFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecProtocolFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikeCertCrlFailure"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecTunnelStart"), ) )
if mibBuilder.loadTexts: cipSecNotificationGroup.setDescription("This group contains the notifications for the IPsec MIB.")
cipSecGWStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 1, 8)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInDecompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWHashValidFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWSysCapFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutUncompOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInitTunnelFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWPreviousTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInDecryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInDrops"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWPreviousTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWActiveTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutEncrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutEncryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWSysCapFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWRespTunnelFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInDecrypts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInReplayDrops"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutUncompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInNotifys"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWProtocolUseFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInitTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInP2ExchgRejects"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWNoSaFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInAuthFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInDecompOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutDrops"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutDropPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWActiveTunnels"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInP2SaDelRequests"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInAuths"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWOutP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWOutPkts"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInP2Exchgs"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWDecryptFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInP2ExchgInvalids"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWInOctWraps"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWInOctets"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhase2GWNoSaFails"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cikePhase1GWAuthFails"), ) )
if mibBuilder.loadTexts: cipSecGWStatsGroup.setDescription("")

# Compliances

cipSecMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 2, 1)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhaseTwoGroup"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhaseOneGroup"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecLevelsGroup"), ) )
if mibBuilder.loadTexts: cipSecMIBCompliance.setDescription("The compliance statement for SNMP entities\nthe IP Security Protocol.\nThis has been replaced by cipSecMIBComplianceRev1.")
cipSecMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 171, 3, 2, 2)).setObjects(*(("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecGWStatsGroup"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhaseTwoGroup"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecPhaseOneGroup"), ("CISCO-IPSEC-FLOW-MONITOR-MIB", "cipSecLevelsGroup"), ) )
if mibBuilder.loadTexts: cipSecMIBComplianceRev1.setDescription("The compliance statement for SNMP entities\nthe IP Security Protocol.")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", PYSNMP_MODULE_ID=ciscoIpSecFlowMonitorMIB)

# Types
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", AuthAlgo=AuthAlgo, CompAlgo=CompAlgo, DiffHellmanGrp=DiffHellmanGrp, EncapMode=EncapMode, EncryptAlgo=EncryptAlgo, EndPtType=EndPtType, IPSIpAddress=IPSIpAddress, IkeAuthMethod=IkeAuthMethod, IkeHashAlgo=IkeHashAlgo, IkeNegoMode=IkeNegoMode, IkePeerType=IkePeerType, KeyType=KeyType, TrapStatus=TrapStatus, TunnelStatus=TunnelStatus)

# Objects
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", ciscoIpSecFlowMonitorMIB=ciscoIpSecFlowMonitorMIB, cipSecMIBObjects=cipSecMIBObjects, cipSecLevels=cipSecLevels, cipSecMibLevel=cipSecMibLevel, cipSecPhaseOne=cipSecPhaseOne, cikeGlobalStats=cikeGlobalStats, cikeGlobalActiveTunnels=cikeGlobalActiveTunnels, cikeGlobalPreviousTunnels=cikeGlobalPreviousTunnels, cikeGlobalInOctets=cikeGlobalInOctets, cikeGlobalInPkts=cikeGlobalInPkts, cikeGlobalInDropPkts=cikeGlobalInDropPkts, cikeGlobalInNotifys=cikeGlobalInNotifys, cikeGlobalInP2Exchgs=cikeGlobalInP2Exchgs, cikeGlobalInP2ExchgInvalids=cikeGlobalInP2ExchgInvalids, cikeGlobalInP2ExchgRejects=cikeGlobalInP2ExchgRejects, cikeGlobalInP2SaDelRequests=cikeGlobalInP2SaDelRequests, cikeGlobalOutOctets=cikeGlobalOutOctets, cikeGlobalOutPkts=cikeGlobalOutPkts, cikeGlobalOutDropPkts=cikeGlobalOutDropPkts, cikeGlobalOutNotifys=cikeGlobalOutNotifys, cikeGlobalOutP2Exchgs=cikeGlobalOutP2Exchgs, cikeGlobalOutP2ExchgInvalids=cikeGlobalOutP2ExchgInvalids, cikeGlobalOutP2ExchgRejects=cikeGlobalOutP2ExchgRejects, cikeGlobalOutP2SaDelRequests=cikeGlobalOutP2SaDelRequests, cikeGlobalInitTunnels=cikeGlobalInitTunnels, cikeGlobalInitTunnelFails=cikeGlobalInitTunnelFails, cikeGlobalRespTunnelFails=cikeGlobalRespTunnelFails, cikeGlobalSysCapFails=cikeGlobalSysCapFails, cikeGlobalAuthFails=cikeGlobalAuthFails, cikeGlobalDecryptFails=cikeGlobalDecryptFails, cikeGlobalHashValidFails=cikeGlobalHashValidFails, cikeGlobalNoSaFails=cikeGlobalNoSaFails, cikePeerTable=cikePeerTable, cikePeerEntry=cikePeerEntry, cikePeerLocalType=cikePeerLocalType, cikePeerLocalValue=cikePeerLocalValue, cikePeerRemoteType=cikePeerRemoteType, cikePeerRemoteValue=cikePeerRemoteValue, cikePeerIntIndex=cikePeerIntIndex, cikePeerLocalAddr=cikePeerLocalAddr, cikePeerRemoteAddr=cikePeerRemoteAddr, cikePeerActiveTime=cikePeerActiveTime, cikePeerActiveTunnelIndex=cikePeerActiveTunnelIndex, cikeTunnelTable=cikeTunnelTable, cikeTunnelEntry=cikeTunnelEntry, cikeTunIndex=cikeTunIndex, cikeTunLocalType=cikeTunLocalType, cikeTunLocalValue=cikeTunLocalValue, cikeTunLocalAddr=cikeTunLocalAddr, cikeTunLocalName=cikeTunLocalName, cikeTunRemoteType=cikeTunRemoteType, cikeTunRemoteValue=cikeTunRemoteValue, cikeTunRemoteAddr=cikeTunRemoteAddr, cikeTunRemoteName=cikeTunRemoteName, cikeTunNegoMode=cikeTunNegoMode, cikeTunDiffHellmanGrp=cikeTunDiffHellmanGrp, cikeTunEncryptAlgo=cikeTunEncryptAlgo, cikeTunHashAlgo=cikeTunHashAlgo, cikeTunAuthMethod=cikeTunAuthMethod, cikeTunLifeTime=cikeTunLifeTime, cikeTunActiveTime=cikeTunActiveTime, cikeTunSaRefreshThreshold=cikeTunSaRefreshThreshold, cikeTunTotalRefreshes=cikeTunTotalRefreshes, cikeTunInOctets=cikeTunInOctets, cikeTunInPkts=cikeTunInPkts, cikeTunInDropPkts=cikeTunInDropPkts, cikeTunInNotifys=cikeTunInNotifys, cikeTunInP2Exchgs=cikeTunInP2Exchgs, cikeTunInP2ExchgInvalids=cikeTunInP2ExchgInvalids, cikeTunInP2ExchgRejects=cikeTunInP2ExchgRejects, cikeTunInP2SaDelRequests=cikeTunInP2SaDelRequests, cikeTunOutOctets=cikeTunOutOctets, cikeTunOutPkts=cikeTunOutPkts, cikeTunOutDropPkts=cikeTunOutDropPkts, cikeTunOutNotifys=cikeTunOutNotifys, cikeTunOutP2Exchgs=cikeTunOutP2Exchgs, cikeTunOutP2ExchgInvalids=cikeTunOutP2ExchgInvalids, cikeTunOutP2ExchgRejects=cikeTunOutP2ExchgRejects, cikeTunOutP2SaDelRequests=cikeTunOutP2SaDelRequests, cikeTunStatus=cikeTunStatus, cikePeerCorrTable=cikePeerCorrTable, cikePeerCorrEntry=cikePeerCorrEntry, cikePeerCorrLocalType=cikePeerCorrLocalType, cikePeerCorrLocalValue=cikePeerCorrLocalValue, cikePeerCorrRemoteType=cikePeerCorrRemoteType, cikePeerCorrRemoteValue=cikePeerCorrRemoteValue, cikePeerCorrIntIndex=cikePeerCorrIntIndex, cikePeerCorrSeqNum=cikePeerCorrSeqNum, cikePeerCorrIpSecTunIndex=cikePeerCorrIpSecTunIndex, cikePhase1GWStatsTable=cikePhase1GWStatsTable, cikePhase1GWStatsEntry=cikePhase1GWStatsEntry, cikePhase1GWActiveTunnels=cikePhase1GWActiveTunnels, cikePhase1GWPreviousTunnels=cikePhase1GWPreviousTunnels, cikePhase1GWInOctets=cikePhase1GWInOctets, cikePhase1GWInPkts=cikePhase1GWInPkts, cikePhase1GWInDropPkts=cikePhase1GWInDropPkts, cikePhase1GWInNotifys=cikePhase1GWInNotifys, cikePhase1GWInP2Exchgs=cikePhase1GWInP2Exchgs, cikePhase1GWInP2ExchgInvalids=cikePhase1GWInP2ExchgInvalids, cikePhase1GWInP2ExchgRejects=cikePhase1GWInP2ExchgRejects, cikePhase1GWInP2SaDelRequests=cikePhase1GWInP2SaDelRequests, cikePhase1GWOutOctets=cikePhase1GWOutOctets, cikePhase1GWOutPkts=cikePhase1GWOutPkts, cikePhase1GWOutDropPkts=cikePhase1GWOutDropPkts, cikePhase1GWOutNotifys=cikePhase1GWOutNotifys, cikePhase1GWOutP2Exchgs=cikePhase1GWOutP2Exchgs, cikePhase1GWOutP2ExchgInvalids=cikePhase1GWOutP2ExchgInvalids, cikePhase1GWOutP2ExchgRejects=cikePhase1GWOutP2ExchgRejects, cikePhase1GWOutP2SaDelRequests=cikePhase1GWOutP2SaDelRequests, cikePhase1GWInitTunnels=cikePhase1GWInitTunnels, cikePhase1GWInitTunnelFails=cikePhase1GWInitTunnelFails, cikePhase1GWRespTunnelFails=cikePhase1GWRespTunnelFails, cikePhase1GWSysCapFails=cikePhase1GWSysCapFails, cikePhase1GWAuthFails=cikePhase1GWAuthFails, cikePhase1GWDecryptFails=cikePhase1GWDecryptFails, cikePhase1GWHashValidFails=cikePhase1GWHashValidFails, cikePhase1GWNoSaFails=cikePhase1GWNoSaFails, cipSecPhaseTwo=cipSecPhaseTwo, cipSecGlobalStats=cipSecGlobalStats, cipSecGlobalActiveTunnels=cipSecGlobalActiveTunnels, cipSecGlobalPreviousTunnels=cipSecGlobalPreviousTunnels, cipSecGlobalInOctets=cipSecGlobalInOctets, cipSecGlobalHcInOctets=cipSecGlobalHcInOctets, cipSecGlobalInOctWraps=cipSecGlobalInOctWraps, cipSecGlobalInDecompOctets=cipSecGlobalInDecompOctets, cipSecGlobalHcInDecompOctets=cipSecGlobalHcInDecompOctets)
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", cipSecGlobalInDecompOctWraps=cipSecGlobalInDecompOctWraps, cipSecGlobalInPkts=cipSecGlobalInPkts, cipSecGlobalInDrops=cipSecGlobalInDrops, cipSecGlobalInReplayDrops=cipSecGlobalInReplayDrops, cipSecGlobalInAuths=cipSecGlobalInAuths, cipSecGlobalInAuthFails=cipSecGlobalInAuthFails, cipSecGlobalInDecrypts=cipSecGlobalInDecrypts, cipSecGlobalInDecryptFails=cipSecGlobalInDecryptFails, cipSecGlobalOutOctets=cipSecGlobalOutOctets, cipSecGlobalHcOutOctets=cipSecGlobalHcOutOctets, cipSecGlobalOutOctWraps=cipSecGlobalOutOctWraps, cipSecGlobalOutUncompOctets=cipSecGlobalOutUncompOctets, cipSecGlobalHcOutUncompOctets=cipSecGlobalHcOutUncompOctets, cipSecGlobalOutUncompOctWraps=cipSecGlobalOutUncompOctWraps, cipSecGlobalOutPkts=cipSecGlobalOutPkts, cipSecGlobalOutDrops=cipSecGlobalOutDrops, cipSecGlobalOutAuths=cipSecGlobalOutAuths, cipSecGlobalOutAuthFails=cipSecGlobalOutAuthFails, cipSecGlobalOutEncrypts=cipSecGlobalOutEncrypts, cipSecGlobalOutEncryptFails=cipSecGlobalOutEncryptFails, cipSecGlobalProtocolUseFails=cipSecGlobalProtocolUseFails, cipSecGlobalNoSaFails=cipSecGlobalNoSaFails, cipSecGlobalSysCapFails=cipSecGlobalSysCapFails, cipSecTunnelTable=cipSecTunnelTable, cipSecTunnelEntry=cipSecTunnelEntry, cipSecTunIndex=cipSecTunIndex, cipSecTunIkeTunnelIndex=cipSecTunIkeTunnelIndex, cipSecTunIkeTunnelAlive=cipSecTunIkeTunnelAlive, cipSecTunLocalAddr=cipSecTunLocalAddr, cipSecTunRemoteAddr=cipSecTunRemoteAddr, cipSecTunKeyType=cipSecTunKeyType, cipSecTunEncapMode=cipSecTunEncapMode, cipSecTunLifeSize=cipSecTunLifeSize, cipSecTunLifeTime=cipSecTunLifeTime, cipSecTunActiveTime=cipSecTunActiveTime, cipSecTunSaLifeSizeThreshold=cipSecTunSaLifeSizeThreshold, cipSecTunSaLifeTimeThreshold=cipSecTunSaLifeTimeThreshold, cipSecTunTotalRefreshes=cipSecTunTotalRefreshes, cipSecTunExpiredSaInstances=cipSecTunExpiredSaInstances, cipSecTunCurrentSaInstances=cipSecTunCurrentSaInstances, cipSecTunInSaDiffHellmanGrp=cipSecTunInSaDiffHellmanGrp, cipSecTunInSaEncryptAlgo=cipSecTunInSaEncryptAlgo, cipSecTunInSaAhAuthAlgo=cipSecTunInSaAhAuthAlgo, cipSecTunInSaEspAuthAlgo=cipSecTunInSaEspAuthAlgo, cipSecTunInSaDecompAlgo=cipSecTunInSaDecompAlgo, cipSecTunOutSaDiffHellmanGrp=cipSecTunOutSaDiffHellmanGrp, cipSecTunOutSaEncryptAlgo=cipSecTunOutSaEncryptAlgo, cipSecTunOutSaAhAuthAlgo=cipSecTunOutSaAhAuthAlgo, cipSecTunOutSaEspAuthAlgo=cipSecTunOutSaEspAuthAlgo, cipSecTunOutSaCompAlgo=cipSecTunOutSaCompAlgo, cipSecTunInOctets=cipSecTunInOctets, cipSecTunHcInOctets=cipSecTunHcInOctets, cipSecTunInOctWraps=cipSecTunInOctWraps, cipSecTunInDecompOctets=cipSecTunInDecompOctets, cipSecTunHcInDecompOctets=cipSecTunHcInDecompOctets, cipSecTunInDecompOctWraps=cipSecTunInDecompOctWraps, cipSecTunInPkts=cipSecTunInPkts, cipSecTunInDropPkts=cipSecTunInDropPkts, cipSecTunInReplayDropPkts=cipSecTunInReplayDropPkts, cipSecTunInAuths=cipSecTunInAuths, cipSecTunInAuthFails=cipSecTunInAuthFails, cipSecTunInDecrypts=cipSecTunInDecrypts, cipSecTunInDecryptFails=cipSecTunInDecryptFails, cipSecTunOutOctets=cipSecTunOutOctets, cipSecTunHcOutOctets=cipSecTunHcOutOctets, cipSecTunOutOctWraps=cipSecTunOutOctWraps, cipSecTunOutUncompOctets=cipSecTunOutUncompOctets, cipSecTunHcOutUncompOctets=cipSecTunHcOutUncompOctets, cipSecTunOutUncompOctWraps=cipSecTunOutUncompOctWraps, cipSecTunOutPkts=cipSecTunOutPkts, cipSecTunOutDropPkts=cipSecTunOutDropPkts, cipSecTunOutAuths=cipSecTunOutAuths, cipSecTunOutAuthFails=cipSecTunOutAuthFails, cipSecTunOutEncrypts=cipSecTunOutEncrypts, cipSecTunOutEncryptFails=cipSecTunOutEncryptFails, cipSecTunStatus=cipSecTunStatus, cipSecEndPtTable=cipSecEndPtTable, cipSecEndPtEntry=cipSecEndPtEntry, cipSecEndPtIndex=cipSecEndPtIndex, cipSecEndPtLocalName=cipSecEndPtLocalName, cipSecEndPtLocalType=cipSecEndPtLocalType, cipSecEndPtLocalAddr1=cipSecEndPtLocalAddr1, cipSecEndPtLocalAddr2=cipSecEndPtLocalAddr2, cipSecEndPtLocalProtocol=cipSecEndPtLocalProtocol, cipSecEndPtLocalPort=cipSecEndPtLocalPort, cipSecEndPtRemoteName=cipSecEndPtRemoteName, cipSecEndPtRemoteType=cipSecEndPtRemoteType, cipSecEndPtRemoteAddr1=cipSecEndPtRemoteAddr1, cipSecEndPtRemoteAddr2=cipSecEndPtRemoteAddr2, cipSecEndPtRemoteProtocol=cipSecEndPtRemoteProtocol, cipSecEndPtRemotePort=cipSecEndPtRemotePort, cipSecSpiTable=cipSecSpiTable, cipSecSpiEntry=cipSecSpiEntry, cipSecSpiIndex=cipSecSpiIndex, cipSecSpiDirection=cipSecSpiDirection, cipSecSpiValue=cipSecSpiValue, cipSecSpiProtocol=cipSecSpiProtocol, cipSecSpiStatus=cipSecSpiStatus, cipSecPhase2GWStatsTable=cipSecPhase2GWStatsTable, cipSecPhase2GWStatsEntry=cipSecPhase2GWStatsEntry, cipSecPhase2GWActiveTunnels=cipSecPhase2GWActiveTunnels, cipSecPhase2GWPreviousTunnels=cipSecPhase2GWPreviousTunnels, cipSecPhase2GWInOctets=cipSecPhase2GWInOctets, cipSecPhase2GWInOctWraps=cipSecPhase2GWInOctWraps, cipSecPhase2GWInDecompOctets=cipSecPhase2GWInDecompOctets, cipSecPhase2GWInDecompOctWraps=cipSecPhase2GWInDecompOctWraps, cipSecPhase2GWInPkts=cipSecPhase2GWInPkts, cipSecPhase2GWInDrops=cipSecPhase2GWInDrops, cipSecPhase2GWInReplayDrops=cipSecPhase2GWInReplayDrops, cipSecPhase2GWInAuths=cipSecPhase2GWInAuths, cipSecPhase2GWInAuthFails=cipSecPhase2GWInAuthFails, cipSecPhase2GWInDecrypts=cipSecPhase2GWInDecrypts, cipSecPhase2GWInDecryptFails=cipSecPhase2GWInDecryptFails, cipSecPhase2GWOutOctets=cipSecPhase2GWOutOctets, cipSecPhase2GWOutOctWraps=cipSecPhase2GWOutOctWraps, cipSecPhase2GWOutUncompOctets=cipSecPhase2GWOutUncompOctets, cipSecPhase2GWOutUncompOctWraps=cipSecPhase2GWOutUncompOctWraps, cipSecPhase2GWOutPkts=cipSecPhase2GWOutPkts, cipSecPhase2GWOutDrops=cipSecPhase2GWOutDrops, cipSecPhase2GWOutAuths=cipSecPhase2GWOutAuths, cipSecPhase2GWOutAuthFails=cipSecPhase2GWOutAuthFails, cipSecPhase2GWOutEncrypts=cipSecPhase2GWOutEncrypts, cipSecPhase2GWOutEncryptFails=cipSecPhase2GWOutEncryptFails, cipSecPhase2GWProtocolUseFails=cipSecPhase2GWProtocolUseFails, cipSecPhase2GWNoSaFails=cipSecPhase2GWNoSaFails, cipSecPhase2GWSysCapFails=cipSecPhase2GWSysCapFails, cipSecHistory=cipSecHistory)
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", cipSecHistGlobal=cipSecHistGlobal, cipSecHistGlobalCntl=cipSecHistGlobalCntl, cipSecHistTableSize=cipSecHistTableSize, cipSecHistCheckPoint=cipSecHistCheckPoint, cipSecHistPhaseOne=cipSecHistPhaseOne, cikeTunnelHistTable=cikeTunnelHistTable, cikeTunnelHistEntry=cikeTunnelHistEntry, cikeTunHistIndex=cikeTunHistIndex, cikeTunHistTermReason=cikeTunHistTermReason, cikeTunHistActiveIndex=cikeTunHistActiveIndex, cikeTunHistPeerLocalType=cikeTunHistPeerLocalType, cikeTunHistPeerLocalValue=cikeTunHistPeerLocalValue, cikeTunHistPeerIntIndex=cikeTunHistPeerIntIndex, cikeTunHistPeerRemoteType=cikeTunHistPeerRemoteType, cikeTunHistPeerRemoteValue=cikeTunHistPeerRemoteValue, cikeTunHistLocalAddr=cikeTunHistLocalAddr, cikeTunHistLocalName=cikeTunHistLocalName, cikeTunHistRemoteAddr=cikeTunHistRemoteAddr, cikeTunHistRemoteName=cikeTunHistRemoteName, cikeTunHistNegoMode=cikeTunHistNegoMode, cikeTunHistDiffHellmanGrp=cikeTunHistDiffHellmanGrp, cikeTunHistEncryptAlgo=cikeTunHistEncryptAlgo, cikeTunHistHashAlgo=cikeTunHistHashAlgo, cikeTunHistAuthMethod=cikeTunHistAuthMethod, cikeTunHistLifeTime=cikeTunHistLifeTime, cikeTunHistStartTime=cikeTunHistStartTime, cikeTunHistActiveTime=cikeTunHistActiveTime, cikeTunHistTotalRefreshes=cikeTunHistTotalRefreshes, cikeTunHistTotalSas=cikeTunHistTotalSas, cikeTunHistInOctets=cikeTunHistInOctets, cikeTunHistInPkts=cikeTunHistInPkts, cikeTunHistInDropPkts=cikeTunHistInDropPkts, cikeTunHistInNotifys=cikeTunHistInNotifys, cikeTunHistInP2Exchgs=cikeTunHistInP2Exchgs, cikeTunHistInP2ExchgInvalids=cikeTunHistInP2ExchgInvalids, cikeTunHistInP2ExchgRejects=cikeTunHistInP2ExchgRejects, cikeTunHistInP2SaDelRequests=cikeTunHistInP2SaDelRequests, cikeTunHistOutOctets=cikeTunHistOutOctets, cikeTunHistOutPkts=cikeTunHistOutPkts, cikeTunHistOutDropPkts=cikeTunHistOutDropPkts, cikeTunHistOutNotifys=cikeTunHistOutNotifys, cikeTunHistOutP2Exchgs=cikeTunHistOutP2Exchgs, cikeTunHistOutP2ExchgInvalids=cikeTunHistOutP2ExchgInvalids, cikeTunHistOutP2ExchgRejects=cikeTunHistOutP2ExchgRejects, cikeTunHistOutP2SaDelRequests=cikeTunHistOutP2SaDelRequests, cipSecHistPhaseTwo=cipSecHistPhaseTwo, cipSecTunnelHistTable=cipSecTunnelHistTable, cipSecTunnelHistEntry=cipSecTunnelHistEntry, cipSecTunHistIndex=cipSecTunHistIndex, cipSecTunHistTermReason=cipSecTunHistTermReason, cipSecTunHistActiveIndex=cipSecTunHistActiveIndex, cipSecTunHistIkeTunnelIndex=cipSecTunHistIkeTunnelIndex, cipSecTunHistLocalAddr=cipSecTunHistLocalAddr, cipSecTunHistRemoteAddr=cipSecTunHistRemoteAddr, cipSecTunHistKeyType=cipSecTunHistKeyType, cipSecTunHistEncapMode=cipSecTunHistEncapMode, cipSecTunHistLifeSize=cipSecTunHistLifeSize, cipSecTunHistLifeTime=cipSecTunHistLifeTime, cipSecTunHistStartTime=cipSecTunHistStartTime, cipSecTunHistActiveTime=cipSecTunHistActiveTime, cipSecTunHistTotalRefreshes=cipSecTunHistTotalRefreshes, cipSecTunHistTotalSas=cipSecTunHistTotalSas, cipSecTunHistInSaDiffHellmanGrp=cipSecTunHistInSaDiffHellmanGrp, cipSecTunHistInSaEncryptAlgo=cipSecTunHistInSaEncryptAlgo, cipSecTunHistInSaAhAuthAlgo=cipSecTunHistInSaAhAuthAlgo, cipSecTunHistInSaEspAuthAlgo=cipSecTunHistInSaEspAuthAlgo, cipSecTunHistInSaDecompAlgo=cipSecTunHistInSaDecompAlgo, cipSecTunHistOutSaDiffHellmanGrp=cipSecTunHistOutSaDiffHellmanGrp, cipSecTunHistOutSaEncryptAlgo=cipSecTunHistOutSaEncryptAlgo, cipSecTunHistOutSaAhAuthAlgo=cipSecTunHistOutSaAhAuthAlgo, cipSecTunHistOutSaEspAuthAlgo=cipSecTunHistOutSaEspAuthAlgo, cipSecTunHistOutSaCompAlgo=cipSecTunHistOutSaCompAlgo, cipSecTunHistInOctets=cipSecTunHistInOctets, cipSecTunHistHcInOctets=cipSecTunHistHcInOctets, cipSecTunHistInOctWraps=cipSecTunHistInOctWraps, cipSecTunHistInDecompOctets=cipSecTunHistInDecompOctets, cipSecTunHistHcInDecompOctets=cipSecTunHistHcInDecompOctets, cipSecTunHistInDecompOctWraps=cipSecTunHistInDecompOctWraps, cipSecTunHistInPkts=cipSecTunHistInPkts, cipSecTunHistInDropPkts=cipSecTunHistInDropPkts, cipSecTunHistInReplayDropPkts=cipSecTunHistInReplayDropPkts, cipSecTunHistInAuths=cipSecTunHistInAuths, cipSecTunHistInAuthFails=cipSecTunHistInAuthFails, cipSecTunHistInDecrypts=cipSecTunHistInDecrypts, cipSecTunHistInDecryptFails=cipSecTunHistInDecryptFails, cipSecTunHistOutOctets=cipSecTunHistOutOctets, cipSecTunHistHcOutOctets=cipSecTunHistHcOutOctets, cipSecTunHistOutOctWraps=cipSecTunHistOutOctWraps, cipSecTunHistOutUncompOctets=cipSecTunHistOutUncompOctets, cipSecTunHistHcOutUncompOctets=cipSecTunHistHcOutUncompOctets, cipSecTunHistOutUncompOctWraps=cipSecTunHistOutUncompOctWraps, cipSecTunHistOutPkts=cipSecTunHistOutPkts, cipSecTunHistOutDropPkts=cipSecTunHistOutDropPkts, cipSecTunHistOutAuths=cipSecTunHistOutAuths, cipSecTunHistOutAuthFails=cipSecTunHistOutAuthFails, cipSecTunHistOutEncrypts=cipSecTunHistOutEncrypts, cipSecTunHistOutEncryptFails=cipSecTunHistOutEncryptFails, cipSecEndPtHistTable=cipSecEndPtHistTable, cipSecEndPtHistEntry=cipSecEndPtHistEntry, cipSecEndPtHistIndex=cipSecEndPtHistIndex, cipSecEndPtHistTunIndex=cipSecEndPtHistTunIndex, cipSecEndPtHistActiveIndex=cipSecEndPtHistActiveIndex, cipSecEndPtHistLocalName=cipSecEndPtHistLocalName, cipSecEndPtHistLocalType=cipSecEndPtHistLocalType, cipSecEndPtHistLocalAddr1=cipSecEndPtHistLocalAddr1, cipSecEndPtHistLocalAddr2=cipSecEndPtHistLocalAddr2, cipSecEndPtHistLocalProtocol=cipSecEndPtHistLocalProtocol, cipSecEndPtHistLocalPort=cipSecEndPtHistLocalPort, cipSecEndPtHistRemoteName=cipSecEndPtHistRemoteName, cipSecEndPtHistRemoteType=cipSecEndPtHistRemoteType, cipSecEndPtHistRemoteAddr1=cipSecEndPtHistRemoteAddr1, cipSecEndPtHistRemoteAddr2=cipSecEndPtHistRemoteAddr2, cipSecEndPtHistRemoteProtocol=cipSecEndPtHistRemoteProtocol, cipSecEndPtHistRemotePort=cipSecEndPtHistRemotePort, cipSecFailures=cipSecFailures, cipSecFailGlobal=cipSecFailGlobal, cipSecFailGlobalCntl=cipSecFailGlobalCntl, cipSecFailTableSize=cipSecFailTableSize, cipSecFailPhaseOne=cipSecFailPhaseOne, cikeFailTable=cikeFailTable, cikeFailEntry=cikeFailEntry, cikeFailIndex=cikeFailIndex, cikeFailReason=cikeFailReason, cikeFailTime=cikeFailTime, cikeFailLocalType=cikeFailLocalType, cikeFailLocalValue=cikeFailLocalValue, cikeFailRemoteType=cikeFailRemoteType)
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", cikeFailRemoteValue=cikeFailRemoteValue, cikeFailLocalAddr=cikeFailLocalAddr, cikeFailRemoteAddr=cikeFailRemoteAddr, cipSecFailPhaseTwo=cipSecFailPhaseTwo, cipSecFailTable=cipSecFailTable, cipSecFailEntry=cipSecFailEntry, cipSecFailIndex=cipSecFailIndex, cipSecFailReason=cipSecFailReason, cipSecFailTime=cipSecFailTime, cipSecFailTunnelIndex=cipSecFailTunnelIndex, cipSecFailSaSpi=cipSecFailSaSpi, cipSecFailPktSrcAddr=cipSecFailPktSrcAddr, cipSecFailPktDstAddr=cipSecFailPktDstAddr, cipSecTrapCntl=cipSecTrapCntl, cipSecTrapCntlIkeTunnelStart=cipSecTrapCntlIkeTunnelStart, cipSecTrapCntlIkeTunnelStop=cipSecTrapCntlIkeTunnelStop, cipSecTrapCntlIkeSysFailure=cipSecTrapCntlIkeSysFailure, cipSecTrapCntlIkeCertCrlFailure=cipSecTrapCntlIkeCertCrlFailure, cipSecTrapCntlIkeProtocolFail=cipSecTrapCntlIkeProtocolFail, cipSecTrapCntlIkeNoSa=cipSecTrapCntlIkeNoSa, cipSecTrapCntlIpSecTunnelStart=cipSecTrapCntlIpSecTunnelStart, cipSecTrapCntlIpSecTunnelStop=cipSecTrapCntlIpSecTunnelStop, cipSecTrapCntlIpSecSysFailure=cipSecTrapCntlIpSecSysFailure, cipSecTrapCntlIpSecSetUpFailure=cipSecTrapCntlIpSecSetUpFailure, cipSecTrapCntlIpSecEarlyTunTerm=cipSecTrapCntlIpSecEarlyTunTerm, cipSecTrapCntlIpSecProtocolFail=cipSecTrapCntlIpSecProtocolFail, cipSecTrapCntlIpSecNoSa=cipSecTrapCntlIpSecNoSa, cipSecMIBNotificationPrefix=cipSecMIBNotificationPrefix, cipSecMIBNotifications=cipSecMIBNotifications, cipSecMIBConformance=cipSecMIBConformance, cipSecMIBGroups=cipSecMIBGroups, cipSecMIBCompliances=cipSecMIBCompliances)

# Notifications
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", cikeTunnelStart=cikeTunnelStart, cikeTunnelStop=cikeTunnelStop, cikeSysFailure=cikeSysFailure, cikeCertCrlFailure=cikeCertCrlFailure, cikeProtocolFailure=cikeProtocolFailure, cikeNoSa=cikeNoSa, cipSecTunnelStart=cipSecTunnelStart, cipSecTunnelStop=cipSecTunnelStop, cipSecSysFailure=cipSecSysFailure, cipSecSetUpFailure=cipSecSetUpFailure, cipSecEarlyTunTerm=cipSecEarlyTunTerm, cipSecProtocolFailure=cipSecProtocolFailure, cipSecNoSa=cipSecNoSa)

# Groups
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", cipSecLevelsGroup=cipSecLevelsGroup, cipSecPhaseOneGroup=cipSecPhaseOneGroup, cipSecPhaseTwoGroup=cipSecPhaseTwoGroup, cipSecHistoryGroup=cipSecHistoryGroup, cipSecFailuresGroup=cipSecFailuresGroup, cipSecTrapCntlGroup=cipSecTrapCntlGroup, cipSecNotificationGroup=cipSecNotificationGroup, cipSecGWStatsGroup=cipSecGWStatsGroup)

# Compliances
mibBuilder.exportSymbols("CISCO-IPSEC-FLOW-MONITOR-MIB", cipSecMIBCompliance=cipSecMIBCompliance, cipSecMIBComplianceRev1=cipSecMIBComplianceRev1)
