# PySNMP SMI module. Autogenerated from smidump -f python BGP4-V2-MIB-JUNIPER
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:48 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InetAddress, InetAddressPrefixLength, InetAddressType, InetAutonomousSystemNumber, InetPortNumber, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType", "InetAutonomousSystemNumber", "InetPortNumber")
( jnxBgpM2Experiment, ) = mibBuilder.importSymbols("JUNIPER-EXPERIMENT-MIB", "jnxBgpM2Experiment")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32")
( RowPointer, RowStatus, StorageType, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "RowStatus", "StorageType", "TextualConvention", "TruthValue")

# Types

class JnxBgpM2Community(TextualConvention, OctetString):
    displayHint = "2d:"
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(4,4)
    fixedLength = 4
    
class JnxBgpM2ExtendedCommunity(TextualConvention, OctetString):
    displayHint = "1x:"
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(8,8)
    fixedLength = 8
    
class JnxBgpM2Identifier(TextualConvention, OctetString):
    displayHint = "1d."
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(4,4)
    fixedLength = 4
    
class JnxBgpM2Safi(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,255)
    

# Objects

jnxBgpM2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1)).setRevisions(("2012-12-17 00:00","2003-09-09 15:08","2003-09-09 15:08","2002-11-04 00:00",))
if mibBuilder.loadTexts: jnxBgpM2.setOrganization("IETF IDR Working Group")
if mibBuilder.loadTexts: jnxBgpM2.setContactInfo("E-mail:  idr@merit.net\n\nJeffrey Haas  (Editor)\n825 Victors Way, Suite 100\nAnn Arbor, MI  48108\nTel: +1 734 222-1600\nFax: +1 734 222-1602\nE-mail: jhaas@nexthop.com")
if mibBuilder.loadTexts: jnxBgpM2.setDescription("This MIB module defines management objects for\nthe Border Gateway Protocol, Version 4.")
jnxBgpM2BaseScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1))
jnxBgpM2BaseNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 0))
jnxBgpM2Version = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 1))
jnxBgpM2VersionTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2VersionTable.setDescription("Table of supported BGP versions.")
jnxBgpM2VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 1, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2VersionIndex"))
if mibBuilder.loadTexts: jnxBgpM2VersionEntry.setDescription("Entry containing data on a given supported version\nof the Border Gateway Protocol and the level of\nsupport provided.  It is expected that any agent\nimplementation supporting this MIB module will\nreport support for Version 4 of the Border Gateway\nProtocol at the very minimum.")
jnxBgpM2VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2VersionIndex.setDescription("The version number of the BGP Protocol.")
jnxBgpM2VersionSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 1, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2VersionSupported.setDescription("This value is TRUE if this version of the BGP protocol\nidentified in 'jnxBgpM2VersionIndex' is supported.  The absence\nof a row for a particular jnxBgpM2VersionIndex indicates that\nthat jnxBgpM2VersionIndex protocol version number is not\nsupported.")
jnxBgpM2SupportedAuthentication = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 2))
jnxBgpM2SupportedAuthTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 2, 1))
if mibBuilder.loadTexts: jnxBgpM2SupportedAuthTable.setDescription("The supported BGP authentication mechanisms.")
jnxBgpM2SupportedAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 2, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2SupportedAuthCode"))
if mibBuilder.loadTexts: jnxBgpM2SupportedAuthEntry.setDescription("Entry containing information whether a given BGP\nauthentication mechanism is supported by this\nimplementation.")
jnxBgpM2SupportedAuthCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2SupportedAuthCode.setDescription("The BGP authentication code.")
jnxBgpM2SupportedAuthValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2SupportedAuthValue.setDescription("This value is TRUE if a given authentication method\nis supported by the local implementation.")
jnxBgpM2SupportedCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 3))
jnxBgpM2CapabilitySupportAvailable = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 3, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2CapabilitySupportAvailable.setDescription("This value is TRUE if capability support is\navailable and is enabled.")
jnxBgpM2SupportedCapabilitiesTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 3, 2))
if mibBuilder.loadTexts: jnxBgpM2SupportedCapabilitiesTable.setDescription("Table of supported BGP-4 capabilities.")
jnxBgpM2SupportedCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 3, 2, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2SupportedCapabilityCode"))
if mibBuilder.loadTexts: jnxBgpM2SupportedCapabilitiesEntry.setDescription("Information about supported capabilities indexed\nby capability number.")
jnxBgpM2SupportedCapabilityCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2SupportedCapabilityCode.setDescription("Index of supported capability.  The index directly\ncorresponds with the BGP-4 Capability Advertisement\nCapability Code.")
jnxBgpM2SupportedCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 3, 2, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2SupportedCapability.setDescription("This value is True if this capability is supported,\nFalse otherwise.")
jnxBgpM2AsSize = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("twoOctet", 1), ("fourOctet", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsSize.setDescription("The size of the AS value in this implementation.\n\nThe semantics of this are determined as per the\nas-4bytes draft.")
jnxBgpM2LocalAs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 5), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2LocalAs.setDescription("The local autonomous system number.\n\nIf the jnxBgpM2AsSize is twoOctet, then the range is\nconstrained to be 0-65535.")
jnxBgpM2LocalIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 6), JnxBgpM2Identifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2LocalIdentifier.setDescription("The BGP Identifier of local system.\n\nCurrent practice is trending away from this value being\ntreated as an IP address and more as a generic\nidentifier.")
jnxBgpM2BaseScalarExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7))
jnxBgpM2BaseScalarNonCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1))
jnxBgpM2BaseScalarRouteReflectExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1, 2796))
jnxBgpM2RouteReflector = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1, 2796, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2RouteReflector.setDescription("This value is TRUE if this implementation supports the\nBGP Route Reflection Extension and is enabled as a\nroute reflector.  If the BGP Route Reflection extension\nis not supported this value must be FALSE.")
jnxBgpM2ClusterId = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1, 2796, 2), JnxBgpM2Identifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2ClusterId.setDescription("The configured Cluster-ID of the BGP Speaker.  This will\ndefault to the BGP Speaker's JnxBgpM2Identifier if this\nspeaker is functioning as a route reflector and an\nexplicit Cluster-ID has not been configured.\n\nA value of 0.0.0.0 will be present if Route Reflection is\nnot enabled.")
jnxBgpM2BaseScalarASConfedExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1, 3065))
jnxBgpM2ConfederationRouter = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1, 3065, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2ConfederationRouter.setDescription("This value is TRUE if this implementation supports the\nBGP AS Confederations Extension and this router is\nconfigured to be in a confederation.")
jnxBgpM2ConfederationId = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 1, 3065, 2), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2ConfederationId.setDescription("The local Confederation Identification Number.\n\nThis value will be zero (0) if this BGP Speaker is not\na confederation router.")
jnxBgpM2BaseScalarCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 7, 2))
jnxBgpM2BaseScalarConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8))
jnxBgpM2CfgBaseScalarStorageType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 1), StorageType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgBaseScalarStorageType.setDescription("This object specifies the intended storage type for\nall configurable base scalars.")
jnxBgpM2CfgLocalAs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 2), InetAutonomousSystemNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgLocalAs.setDescription("The local autonomous system number.\n\nIf the jnxBgpM2AsSize is twoOctet, then the range is\nconstrained to be 0-65535.")
jnxBgpM2CfgLocalIdentifier = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 3), JnxBgpM2Identifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgLocalIdentifier.setDescription("The BGP Identifier of local system.\n\nCurrent practice is trending away from this value being\ntreated as an IP address and more as a generic\nidentifier.")
jnxBgpM2CfgBaseScalarExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4))
jnxBgpM2CfgBaseScalarNonCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1))
jnxBgpM2CfgBaseScalarReflectorExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1, 2796))
jnxBgpM2CfgRouteReflector = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1, 2796, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgRouteReflector.setDescription("This value is set to true if this implementation will\nbe supporting route reflection.")
jnxBgpM2CfgClusterId = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1, 2796, 2), JnxBgpM2Identifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgClusterId.setDescription("The configured Cluster-ID of the BGP Speaker.  This will\ndefault to the BGP Speaker's JnxBgpM2Identifier if this\nspeaker is functioning as a route reflector and an\nexplicit Cluster-ID has not been configured.\n\nA value of 0.0.0.0 will be present if Route Reflection is\nnot enabled.")
jnxBgpM2CfgBaseScalarASConfedExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1, 3065))
jnxBgpM2CfgConfederationRouter = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1, 3065, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgConfederationRouter.setDescription("This value is set to true if this implementation will be\nsupporting BGP AS Confederations.")
jnxBgpM2CfgConfederationId = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 1, 3065, 2), InetAutonomousSystemNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgConfederationId.setDescription("The local Confederation Identification Number.\n\nThis value will be zero (0) if this BGP Speaker is not\na confederation router.")
jnxBgpM2CfgBaseScalarCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 8, 4, 2))
jnxBgpM2Peer = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2))
jnxBgpM2PeerData = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1))
jnxBgpM2PeerTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerTable.setDescription("BGP peer table.\n\nThis table contains, one entry per remote BGP peer,\nany information about the connections with the remote\nBGP peers.")
jnxBgpM2PeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRoutingInstance"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddrType"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddr"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddrType"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddr"))
if mibBuilder.loadTexts: jnxBgpM2PeerEntry.setDescription("Entry containing information about the connection with\na remote BGP peer.")
jnxBgpM2PeerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 1), JnxBgpM2Identifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerIdentifier.setDescription("The BGP Identifier of this entry's remote BGP peer.\n\nThis entry should be 0.0.0.0 unless the jnxBgpM2PeerState is\nin the OpenConfirm or the Established state.")
jnxBgpM2PeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(6,5,4,1,2,3,)).subtype(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerState.setDescription("The remote BGP peer's FSM state.")
jnxBgpM2PeerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("halted", 1), ("running", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerStatus.setDescription("Whether or not the BGP FSM for this remote peer is halted\nor running.  The BGP FSM for a remote peer is halted after\nprocessing a Stop event.  Likewise, it is in the running\nstate after a Start event.\n\nThe jnxBgpM2PeerState will generally be in the idle state when\nthe FSM is halted, although some extensions such as\nGraceful Restart will leave the peer in the Idle state\nbut with the FSM running.")
jnxBgpM2PeerConfiguredVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerConfiguredVersion.setDescription("The configured version to originally start with this\nremote peer.  The BGP speaker may permit negotiation to a\nlower version number of the protocol.")
jnxBgpM2PeerNegotiatedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerNegotiatedVersion.setDescription("The negotiated version of BGP running between the two\npeers.")
jnxBgpM2PeerLocalAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLocalAddrType.setDescription("The address family of the local end of the peering\nsession.")
jnxBgpM2PeerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 7), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLocalAddr.setDescription("The address of the local end of the peering session.")
jnxBgpM2PeerLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 8), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLocalPort.setDescription("The local port for the TCP connection between the BGP\npeers.")
jnxBgpM2PeerLocalAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 9), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLocalAs.setDescription("Some implementations of BGP can represent themselves\nas multiple ASs.  This is the AS that this peering\nsession is representing itself as to the remote peer.")
jnxBgpM2PeerRemoteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerRemoteAddrType.setDescription("The address family of the remote end of the peering\nsession.")
jnxBgpM2PeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 11), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerRemoteAddr.setDescription("The address of the remote end of the peering session.")
jnxBgpM2PeerRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 12), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerRemotePort.setDescription("The remote port for the TCP connection between the BGP\npeers.  In the case of a transport for which the notion\nof 'port' is irrelevant, an instance value of -1\nshould be returned by the agent for this object.\n\nNote that the objects jnxBgpM2PeerLocalAddr,\njnxBgpM2PeerLocalPort, jnxBgpM2PeerRemoteAddr and\njnxBgpM2PeerRemotePort provide the appropriate reference to\nthe standard MIB TCP connection table. or even the ipv6\nTCP MIB as in rfc2452.")
jnxBgpM2PeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 13), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerRemoteAs.setDescription("The remote autonomous system number.")
jnxBgpM2PeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerIndex.setDescription("This value is a unique index for the remote peer entry\nin the jnxBgpM2PeerTable.  It is assigned by the agent\nat the point of creation of the jnxBgpM2PeerTable row\nentry.  While its value is guaranteed to be unique at\nany time, it is otherwise opaque to the management\napplication with respect to its value or the contiguity\nof jnxBgpM2PeerIndex row instance values across rows of\nthe jnxBgpM2PeerTable.  It is used to provide an index\nstructure for other tables whose data is logically\nper-peer.\n\nFor explicitly configured peers, this value will remain\nconsistent until this row is deleted by deleting the\nconfigured peers.  Unconfigured peers will generate\na monotonically increasing number when a BGP FSM is\nbuilt to process the peering session.  Values in the\njnxBgpM2PeerTable and other tables utilizing jnxBgpM2PeerIndex\nare expected to remain in existence for an arbitrary\ntime after the unconfigured peer has been deleted\nin order to allow management applications to extract\nuseful management information for those peers.  Thus,\nan unconfigured peer using the same indices as the\njnxBgpM2PeerTable that comes up while this row still\nexists will re-utilize the same row.")
jnxBgpM2PeerRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 1, 1, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerRoutingInstance.setDescription("Routing instance index.")
jnxBgpM2PeerErrors = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2))
jnxBgpM2PeerErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerErrorsTable.setDescription("On a per peer basis, this table reflects the last\nprotocol-defined error encountered and reported on\nthe peer session.  If no entry for a given peer,\nby its jnxBgpM2PeerIndex, exists in this table, then no\nsuch errors have been observed, reported, and\nrecorded on the  session.")
jnxBgpM2PeerErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerErrorsEntry.setDescription("Each entry contains information about errors sent\nand received for a particular BGP peer.")
jnxBgpM2PeerLastErrorReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorReceived.setDescription("The last error code and subcode received by this BGP\nSpeaker via a NOTIFICATION message for this peer.\nIf no error has occurred, this field is zero.\nOtherwise, the first byte of this two byte\nOCTET STRING contains the error code, and the second\nbyte contains the subcode.")
jnxBgpM2PeerLastErrorSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorSent.setDescription("The last error code and subcode sent by this BGP\nSpeaker via a NOTIFICATION message to this peer.\nIf no error has occurred, this field is zero.\nOtherwise, the first byte of this two byte\nOCTET STRING contains the error code, and the second\nbyte contains the subcode.")
jnxBgpM2PeerLastErrorReceivedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorReceivedTime.setDescription("The timestamp that the last NOTIFICATION was received from\nthis peer.")
jnxBgpM2PeerLastErrorSentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorSentTime.setDescription("The timestamp that the last NOTIFICATION was sent to\nthis peer.")
jnxBgpM2PeerLastErrorReceivedText = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorReceivedText.setDescription("This object contains an implementation specific\nexplanation of the error that was reported.")
jnxBgpM2PeerLastErrorSentText = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorSentText.setDescription("This object contains an implementation specific\nexplanation of the error that is being reported.")
jnxBgpM2PeerLastErrorReceivedData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4075))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorReceivedData.setDescription("The last error code's data seen by this peer.")
jnxBgpM2PeerLastErrorSentData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4075))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerLastErrorSentData.setDescription("The last error code's data sent to this peer.")
jnxBgpM2PeerAuthentication = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3))
jnxBgpM2PeerAuthTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerAuthTable.setDescription("BGP peer authentication table.\n\nThis table contains, one entry per BGP peer,\ninformation about the authentication with BGP peers.")
jnxBgpM2PeerAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerAuthEntry.setDescription("Entry containing information about the authentication\nwith a BGP peer.")
jnxBgpM2PeerAuthSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerAuthSent.setDescription("The local peer has sent authentication information\nto the remote peer in the BGP Authentication field.")
jnxBgpM2PeerAuthSentCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerAuthSentCode.setDescription("The code of the authentication information sent to\nthe remote peer.")
jnxBgpM2PeerAuthSentValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerAuthSentValue.setDescription("The payload of the authentication information\nfrom the remote peer.")
jnxBgpM2PeerAuthRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerAuthRcvd.setDescription("The local peer has received authentication information\nfrom the remote peer in the BGP Authentication field.")
jnxBgpM2PeerAuthRcvdCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerAuthRcvdCode.setDescription("The code of the authentication information received from\nthe remote peer.")
jnxBgpM2PeerAuthRcvdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 3, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 252))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerAuthRcvdValue.setDescription("The payload of the authentication information from\nthe remote peer.")
jnxBgpM2PeerTimers = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4))
jnxBgpM2PeerEventTimesTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerEventTimesTable.setDescription("A table reporting the per-peering session amount\nof time elapsed and update events since the peering\nsession advanced into the Established state.")
jnxBgpM2PeerEventTimesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerEventTimesEntry.setDescription("Each row contains a set of statistics about time\nspent and events encountered in the peer session\nEstablished state.")
jnxBgpM2PeerFsmEstablishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerFsmEstablishedTime.setDescription("This timer indicates how long (in seconds) this\npeer has been in the Established state or how long\nsince this peer was last in the Established state.\nIt is set to zero when a new peer is configured or\nthe router is booted.")
jnxBgpM2PeerInUpdatesElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerInUpdatesElapsedTime.setDescription("Elapsed time in seconds since the last BGP UPDATE\nmessage was received from the peer.  Each time\njnxBgpM2PeerInUpdates is incremented, the value of this\nobject is set to zero (0).  This value shall also be\nzero (0) when the peer is not in the Established state")
jnxBgpM2PeerConfiguredTimersTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2))
if mibBuilder.loadTexts: jnxBgpM2PeerConfiguredTimersTable.setDescription("Per peer management data on BGP session timers.")
jnxBgpM2PeerConfiguredTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerConfiguredTimersEntry.setDescription("Each entry corresponds to the current state of\nBGP timers on a given peering session.")
jnxBgpM2PeerConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerConnectRetryInterval.setDescription("Time interval in seconds for the ConnectRetry\ntimer.  The suggested value for this timer is 120\nseconds.")
jnxBgpM2PeerHoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerHoldTimeConfigured.setDescription("Time interval in seconds for the Hold Time configured\nfor this BGP speaker with this peer.  This value\nis placed in an OPEN message sent to this peer by\nthis BGP speaker, and is compared with the Hold\nTime field in an OPEN message received from the\npeer when determining the Hold Time (jnxBgpM2PeerHoldTime)\nwith the peer.  This value must not be less than\nthree seconds if it is not zero (0) in which case\nthe Hold Time is NOT to be established with the\npeer.  The suggested value for this timer is 90\nseconds.")
jnxBgpM2PeerKeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerKeepAliveConfigured.setDescription("Time interval in seconds for the KeepAlive timer\nconfigured for this BGP speaker with this peer.\nThe value of this object will only determine the\nKEEPALIVE messages frequency relative to the value\nspecified in jnxBgpM2PeerHoldTimeConfigured; the actual\ntime interval for the KEEPALIVE messages is indicated\nby jnxBgpM2PeerKeepAlive.  A reasonable maximum value\nfor this timer would be configured to be one third\nof that of jnxBgpM2PeerHoldTimeConfigured.\n\nIf the value of this object is zero (0), no\nperiodical KEEPALIVE messages are sent to the peer\nafter the BGP connection has been established.\nThe suggested value for this timer is 30 seconds.")
jnxBgpM2PeerMinASOrigInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerMinASOrigInterval.setDescription("Time interval in seconds for the MinASOriginationInterval\ntimer.  The suggested value for this timer is 15\nseconds.")
jnxBgpM2PeerMinRouteAdverInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerMinRouteAdverInterval.setDescription("Time interval in seconds for the\nMinRouteAdvertisementInterval timer.  The suggested\nvalue for this timer is 30 seconds.")
jnxBgpM2PeerNegotiatedTimersTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 3))
if mibBuilder.loadTexts: jnxBgpM2PeerNegotiatedTimersTable.setDescription("Current values of per-peer timers which can be\ndynamically set in the jnxBgpM2PeerConfiguredTimersTable.\nValues reflected in this table are the current\noperational values, after negotiation from values\nderived from initial configuration or last set from\njnxBgpM2PeerConfiguredTimersTable row instances.")
jnxBgpM2PeerNegotiatedTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 3, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerNegotiatedTimersEntry.setDescription("Each entry reflects a value of the currently\noperational, negotiated timers as reflected in the\nJnxBgpM2PeerNegotiatedTimersEntry.")
jnxBgpM2PeerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerHoldTime.setDescription("The value of this object is calculated by this BGP\nSpeaker as being;\n\nzero (0) - if this was the value sent by the peer and\nthis value is permitted by this BGP Speaker.  In this\ncase, no keepalive messages are sent and the Hold Timer\nis not set.\n\nAt least three (3).  This value is the smaller of\nthe value sent by this peer in the OPEN message and\njnxBgpM2PeerHoldTimeConfigured for this peer.\n\nThis value is only defined when the peering session is\nin the Established state.")
jnxBgpM2PeerKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 4, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerKeepAlive.setDescription("Time interval in seconds for the KeepAlive timer\nestablished with the peer.  The value of this object\nis calculated by this BGP speaker such that, when\ncompared with jnxBgpM2PeerHoldTime, it has the same\nproportion as what jnxBgpM2PeerKeepAliveConfigured has\nwhen compared with jnxBgpM2PeerHoldTimeConfigured.  If\nthe value of this object is zero (0), it indicates\nthat the KeepAlive timer has not been established\nwith the peer, or, the value of\njnxBgpM2PeerKeepAliveConfigured is zero (0).\n\nThis value is only defined when the peering session is\nin the Established state.")
jnxBgpM2PeerCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5))
jnxBgpM2PeerCapsAnnouncedTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerCapsAnnouncedTable.setDescription("This table contains the capabilities\nthat are supported for a given peer.")
jnxBgpM2PeerCapsAnnouncedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapAnnouncedCode"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapAnnouncedIndex"))
if mibBuilder.loadTexts: jnxBgpM2PeerCapsAnnouncedEntry.setDescription("These entries are keyed by a BGP-4 peer remote\naddress and the BGP Capability Code")
jnxBgpM2PeerCapAnnouncedCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerCapAnnouncedCode.setDescription("The BGP Capability Advertisement Capability Code.")
jnxBgpM2PeerCapAnnouncedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerCapAnnouncedIndex.setDescription("Multiple instances of a given capability may be sent\nbgp a BGP speaker.  This variable is used to index them.")
jnxBgpM2PeerCapAnnouncedValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerCapAnnouncedValue.setDescription("The value of the announced capability.")
jnxBgpM2PeerCapsReceivedTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 2))
if mibBuilder.loadTexts: jnxBgpM2PeerCapsReceivedTable.setDescription("This table contains the capabilities\nthat are supported for a given peer.")
jnxBgpM2PeerCapsReceivedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 2, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapReceivedCode"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapReceivedIndex"))
if mibBuilder.loadTexts: jnxBgpM2PeerCapsReceivedEntry.setDescription("These entries are keyed by a BGP-4 peer remote\naddress and the BGP Capability Code")
jnxBgpM2PeerCapReceivedCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerCapReceivedCode.setDescription("The BGP Capability Advertisement Capability Code.")
jnxBgpM2PeerCapReceivedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerCapReceivedIndex.setDescription("Multiple instances of a given capability may be sent\nbgp a BGP speaker.  This variable is used to index them.")
jnxBgpM2PeerCapReceivedValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 5, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerCapReceivedValue.setDescription("The value of the announced capability.")
jnxBgpM2PeerCounters = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6))
jnxBgpM2PeerCountersTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerCountersTable.setDescription("The counters associated with a BGP Peer.")
jnxBgpM2PeerCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerCountersEntry.setDescription("Each entry contains counters of message transmissions\nand FSM transitions for a given BGP Peering session.")
jnxBgpM2PeerInUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerInUpdates.setDescription("The number of BGP UPDATE messages received on this\nconnection.  This object should be initialized to zero\n(0) when the connection is established.")
jnxBgpM2PeerOutUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerOutUpdates.setDescription("The number of BGP UPDATE messages transmitted on this\nconnection.  This object should be initialized to zero\n(0) when the connection is established.")
jnxBgpM2PeerInTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerInTotalMessages.setDescription("The total number of messages received from the remote\npeer on this connection.  This object should be\ninitialized to zero when the connection is established.")
jnxBgpM2PeerOutTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerOutTotalMessages.setDescription("The total number of messages transmitted to the remote\npeer on this connection.  This object should be\ninitialized to zero when the connection is established.")
jnxBgpM2PeerFsmEstablishedTrans = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerFsmEstablishedTrans.setDescription("The total number of times the BGP FSM\ntransitioned into the established state\nfor this peer.")
jnxBgpM2PrefixCountersTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2))
if mibBuilder.loadTexts: jnxBgpM2PrefixCountersTable.setDescription("Additional per-peer, per AFI SAFI counters for prefixes")
jnxBgpM2PrefixCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixCountersAfi"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixCountersSafi"))
if mibBuilder.loadTexts: jnxBgpM2PrefixCountersEntry.setDescription("Entry containing information about a bgp-peers prefix\ncounters.")
jnxBgpM2PrefixCountersAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 1), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixCountersAfi.setDescription("The AFI index of the per-peer, per prefix counters")
jnxBgpM2PrefixCountersSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 2), JnxBgpM2Safi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixCountersSafi.setDescription("The SAFI index of the per-peer, per prefix counters")
jnxBgpM2PrefixInPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixInPrefixes.setDescription("The number of prefixes received from a peer and are\nstored in the Adj-Ribs-In for that peer.")
jnxBgpM2PrefixInPrefixesAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixInPrefixesAccepted.setDescription("The number of prefixes for a peer that are installed\nin the Adj-Ribs-In and are eligible to become active\nin the Loc-Rib.")
jnxBgpM2PrefixInPrefixesRejected = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixInPrefixesRejected.setDescription("The number of prefixes for a peer that are installed\nin the Adj-Ribs-In and are NOT eligible to become active\nin the Loc-Rib.")
jnxBgpM2PrefixOutPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixOutPrefixes.setDescription("The number of prefixes for a peer that are installed\nin that peers Adj-Ribs-Out.")
jnxBgpM2PrefixInPrefixesActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 6, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PrefixInPrefixesActive.setDescription("The number of prefixes for a peer that are installed\nin the Adj-Ribs-In and are the active route\nin the Loc-Rib.")
jnxBgpM2PeerExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7))
jnxBgpM2PeerNonCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1))
jnxBgpM2PeerRouteReflectionExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 2796))
jnxBgpM2PeerReflectorClientTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 2796, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerReflectorClientTable.setDescription("Table of route reflection client settings on a per-peer\nbasis.")
jnxBgpM2PeerReflectorClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 2796, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerReflectorClientEntry.setDescription("Entry containing data on a per-peer basis on whether\nthe peer is configured as a route reflector client.")
jnxBgpM2PeerReflectorClient = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 2796, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,0,)).subtype(namedValues=NamedValues(("nonClient", 0), ("client", 1), ("meshedClient", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerReflectorClient.setDescription("This value indicates whether the given peer is a\nreflector client of this router, or not.  A value of\nnonClient indicates that this peer is not a reflector\nclient.  A value of client indicates that this peer is a\nreflector client that is not fully meshed with other\nreflector clients.  A value of meshedClient indicates\nthat the peer is a reflector client and is fully meshed\nwith all other reflector clients.\n\nThis value must be nonClient (0) for BGP external peers.")
jnxBgpM2PeerASConfederationExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 3065))
jnxBgpM2PeerConfedMemberTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 3065, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerConfedMemberTable.setDescription("Table of confederation member settings on a per-peer\nbasis.")
jnxBgpM2PeerConfedMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 3065, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2PeerConfedMemberEntry.setDescription("Entry containing data on a per-peer basis on whether\nthe peer is configured as a BGP confederation member.")
jnxBgpM2PeerConfedMember = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 1, 3065, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PeerConfedMember.setDescription("This value indicates whether the given peer is in our\nconfederation or not.")
jnxBgpM2PeerCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 7, 2))
jnxBgpM2PeerConfiguration = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8))
jnxBgpM2CfgPeerAdminStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAdminStatusTable.setDescription("Table containing rows for administratively starting and\nstopping peering sessions.")
jnxBgpM2CfgPeerAdminStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAdminStatusEntry.setDescription("Entry containing row for administratively starting and\nstopping peers.")
jnxBgpM2CfgPeerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("stop", 1), ("start", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAdminStatus.setDescription("This object allows the Manual Stop and Manual Start\nevents to be sent to an activated peering session.")
jnxBgpM2CfgPeerNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerNextIndex.setDescription("This object contains the next appropriate value to\nuse as an index for creation of a row instance in\nin the jnxBgpM2CfgPeerTable.  If the number of available\nentries in the jnxBgpM2CfgPeerTable is exhausted, a\nretrieval value of this object instance will return\n0.  A value of 0 may also be returned if the agent\nis otherwise incapable of jnxBgpM2CfgPeerTable row creation\nat the time of jnxBgpM2CfgPeerNextIndex retrieval.")
jnxBgpM2CfgPeerTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerTable.setDescription("BGP configuration peer table.\n\nThis table allows the configuration of the parameters\nfor a session with a BGP peer.\n\n+++wayne provide description of how config should be done\nfor a peer per table.")
jnxBgpM2CfgPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerIndex"))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerEntry.setDescription("Entry containing information set up by a management\nentity to configure a connection with a BGP peer.")
jnxBgpM2CfgPeerConfiguredVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(4)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerConfiguredVersion.setDescription("The configured version to originally start with\nthis peer.  The BGP speaker may permit negotiation\nto a lower version number of the protocol depending on the\nset value of jnxBgpM2CfgAllowVersionNegotiation.")
jnxBgpM2CfgAllowVersionNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgAllowVersionNegotiation.setDescription("If set to true, during session establishment with this\npeer, negotiation to a version lower than that specified\nin jnxBgpM2CfgPeerConfiguredVersion will be allowed.")
jnxBgpM2CfgPeerLocalAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerLocalAddrType.setDescription("The address family of the speakers of this BGP\nsession.")
jnxBgpM2CfgPeerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerLocalAddr.setDescription("The address of the local end of the peering session.")
jnxBgpM2CfgPeerLocalAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 5), InetAutonomousSystemNumber().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerLocalAs.setDescription("Autonomous system represented to peer on peering\nsession initialization.  Some implementations of\nBGP can represent themselves as multiple ASes.\nThese implementations can set this to an alternate\nautonomous system.  If this object is set to zero\n(0) at the point this row instance is set to active,\nthen the implementation will initialize this session\nrepresenting itself as the value of jnxBgpM2CfgLocalAs.")
jnxBgpM2CfgPeerRemoteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 6), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerRemoteAddrType.setDescription("The address family of the speakers of the remote BGP\nsession.")
jnxBgpM2CfgPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 7), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerRemoteAddr.setDescription("The address of the remote end (destination address\nof peer) for peering session.")
jnxBgpM2CfgPeerRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerRemotePort.setDescription("This is the remote port for the transport connection\nbetween the BGP peers.  In the case of a transport for\nwhich the notion of port is irrelevant, the value of\n-1 can be defaulted or set.")
jnxBgpM2CfgPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 9), InetAutonomousSystemNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerRemoteAs.setDescription("Autonomous system number of the remote peer.")
jnxBgpM2CfgPeerEntryStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerEntryStorageType.setDescription("This object type specifies the intended storage\ntype for the jnxBgpM2CfgPeerEntry row instance.")
jnxBgpM2CfgPeerError = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(0,2,1,3,)).subtype(namedValues=NamedValues(("unknown", 0), ("notActivated", 1), ("errDuplicatePeeringSession", 2), ("activated", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerError.setDescription("This value indicates the current error status of\nthe row denoting the configured error status.\n\nIf this row is still under creation (has not been activated\njnxBgpM2CfgPeerRowEntryStatus), then this instance will be set to\nnot-activated (1).\n\nAt the point that the row is activated, jnxBgpM2CfgPeerError\nwill reflect the error status of the row data itself.  If\nthere is another session already activated with the same\nlocal and remote addresses as denoted by\n{jnxBgpM2CfgPeerLocalAddrType, jnxBgpM2CfgPeerLocalAddr,\njnxBgpM2CfgPeerRemoteAddr, jnxBgpM2CfgPeerRemotePort}, then\nthe value of this will be set to\nerr-duplicate-peering-session (2).\n\nIf this row is associated with a peer session whose\ninitialization has been attempted, the value will be\nset to activated (3) (and, jnxBgpM2PeerCfgPeerEntry will\nbe set to the row instance of the entry in the\njnxBgpM2PeerTable which reflects the state of the peering\nsession).\n\nNote that this object only reflects the error as a\nfunction of the attempted activation of this row as\ncontaining data for a bgp peering session.  The actual\nstate of the session at the point of any protocol exchange\nor session state machine initiation is reflected in the\njnxBgpM2PeerTable row instance (as reflected through\njnxBgpM2CfgPeerPeerEntry) associated with this row instance.")
jnxBgpM2CfgPeerBgpPeerEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 12), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerBgpPeerEntry.setDescription("Upon activation of the session data contained in this\nrow instance, this object points to an instance of a row\nwithin the jnxBgpM2PeerTable reflecting the session in its\ninitializing or operational state.  Retrieval of this\ncolumn instance will always yield a value of {0.0} unless\nthe session has successfully been activated (via\njnxBgpM2CfgPeerRowEntryStatus).  Such row instances will always\nhave a value of jnxBgpM2CfgPeerError which is activated (3).")
jnxBgpM2CfgPeerRowEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerRowEntryStatus.setDescription("This object type is used to control creation,\nactivation, and deletion of this row instance.")
jnxBgpM2CfgPeerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerIndex.setDescription("Uniquely identifies an instance of a peer row, as\nan element of configuration.")
jnxBgpM2CfgPeerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("halted", 1), ("running", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerStatus.setDescription("This specifies the state of the peering session upon\nactivation.  If disabled, the FSM is in the halted\nstate and no Automatic Start events are generated.\nIf enabled, the FSM is in the running state and\nAutomatic Start events may be generated.")
jnxBgpM2CfgPeerRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 3, 1, 16), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerRoutingInstance.setDescription("Routing instance index.")
jnxBgpM2CfgPeerAuthTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 4))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAuthTable.setDescription("Table contain per peer configuration for BGP Authentication.")
jnxBgpM2CfgPeerAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 4, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAuthEntry.setDescription("Entry containing information about a peer's BGP Authentication\nconfiguration.")
jnxBgpM2CfgPeerAuthEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 4, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAuthEnabled.setDescription("This value is true if BGP Authentication is enabled for\nthis peer.  This is the authentication mechanism\ndocumented in the base BGP specification, not the MD5\nsession protection mechanism.")
jnxBgpM2CfgPeerAuthCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAuthCode.setDescription("The authentication code for the BGP Authentication\nmechanism.")
jnxBgpM2CfgPeerAuthValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 252))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerAuthValue.setDescription("The authentication payload for the BGP authentication\nmechanism.  This value has semantic meaning within\nthe context of the authentication code.")
jnxBgpM2CfgPeerTimersTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerTimersTable.setDescription("Table for configuration of per-peer timers.")
jnxBgpM2CfgPeerTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerTimersEntry.setDescription("Entry containing per-peer timer configuration.")
jnxBgpM2CfgPeerConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(120)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerConnectRetryInterval.setDescription("Time interval in seconds for the ConnectRetry\ntimer.  The suggested value for this timer is 120\nseconds.")
jnxBgpM2CfgPeerHoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),)).clone(90)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerHoldTimeConfigured.setDescription("Time interval in seconds for the Hold Time configured\nfor this BGP speaker with this peer.  This value\nis placed in an OPEN message sent to this peer by\nthis BGP speaker, and is compared with the Hold\nTime field in an OPEN message received from the\npeer when determining the Hold Time (jnxBgpM2PeerHoldTime)\nwith the peer.  This value must not be less than\nthree seconds if it is not zero (0) in which case\nthe Hold Time is NOT to be established with the\npeer.  The suggested value for this timer is 90\nseconds.")
jnxBgpM2CfgPeerKeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845)).clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerKeepAliveConfigured.setDescription("Time interval in seconds for the KeepAlive timer\nconfigured for this BGP speaker with this peer.\nThe value of this object will only determine the\nKEEPALIVE messages frequency relative to the value\nspecified in jnxBgpM2PeerHoldTimeConfigured; the actual\ntime interval for the KEEPALIVE messages is indicated\nby jnxBgpM2PeerKeepAlive.  A reasonable maximum value\nfor this timer would be configured to be one third\nof that of jnxBgpM2PeerHoldTimeConfigured.\n\nIf the value of this object is zero (0), no\nperiodical KEEPALIVE messages are sent to the peer\nafter the BGP connection has been established.\nThe suggested value for this timer is 30 seconds.")
jnxBgpM2CfgPeerMinASOrigInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerMinASOrigInterval.setDescription("Time interval in seconds for the MinASOriginationInterval\ntimer.  The suggested value for this timer is 15\nseconds.")
jnxBgpM2CfgPeerMinRouteAdverInter = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(30)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerMinRouteAdverInter.setDescription("Time interval in seconds for the\nMinRouteAdvertisementInterval timer.  The suggested\nvalue for this timer is 30 seconds.")
jnxBgpM2CfgPeerExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6))
jnxBgpM2CfgPeerNonCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1))
jnxBgpM2CfgPeerRouteReflectionExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 2796))
jnxBgpM2CfgPeerReflectorClientTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 2796, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerReflectorClientTable.setDescription("Table of route reflection client settings on a per-peer\nbasis.")
jnxBgpM2CfgPeerReflectorClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 2796, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerReflectorClientEntry.setDescription("Entry containing data on a per-peer basis on whether\nthe peer is configured as a route reflector client.")
jnxBgpM2CfgPeerReflectorClient = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 2796, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,0,)).subtype(namedValues=NamedValues(("nonClient", 0), ("client", 1), ("meshedClient", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerReflectorClient.setDescription("This value indicates whether the given peer is a\nreflector client of this router, or not.  A value of\nnonClient indicates that this peer is not a reflector\nclient.  A value of client indicates that this peer is a\nreflector client that is not fully meshed with other\nreflector clients.  A value of meshedClient indicates\nthat the peer is a reflector client and is fully meshed\nwith all other reflector clients.\n\nThis value must be nonClient (0) for BGP external peers.")
jnxBgpM2CfgPeerASConfederationExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 3065))
jnxBgpM2CfgPeerConfedMemberTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 3065, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerConfedMemberTable.setDescription("Table of confederation member settings on a per-peer\nbasis.")
jnxBgpM2CfgPeerConfedMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 3065, 1, 1))
if mibBuilder.loadTexts: jnxBgpM2CfgPeerConfedMemberEntry.setDescription("Entry containing data on a per-peer basis on whether\nthe peer is configured as a BGP confederation member.")
jnxBgpM2CfgPeerConfedMember = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 1, 3065, 1, 1, 1), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxBgpM2CfgPeerConfedMember.setDescription("This value indicates whether the given peer is in our\nconfederation or not.")
jnxBgpM2CfgPeerCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 2, 8, 6, 2))
jnxBgpM2Rib = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3))
jnxBgpM2NlriTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1))
if mibBuilder.loadTexts: jnxBgpM2NlriTable.setDescription("The BGP-4 Received Path Attribute Table contains\ninformation about paths to destination networks\nreceived from all BGP4 peers.  Collectively, this\nrepresents the Adj-Ribs-In.  The route where\njnxBgpM2NlriBest is TRUE represents, for this NLRI,\nthe route that is installed in the LocRib from the\nAdj-Ribs-In.")
jnxBgpM2NlriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriAfi"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriSafi"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriPrefix"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriPrefixLen"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriIndex"))
if mibBuilder.loadTexts: jnxBgpM2NlriEntry.setDescription("Information about a path to a network.")
jnxBgpM2NlriIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriIndex.setDescription("This index allows for multiple instances of a base\nprefix for a certain AFI SAFI from a given peer.\nThis is currently useful for two things:\n1. Allowing for a peer in future implementations to\n   send more than a single route instance.\n2. Allow for extensions which extend the NLRI field\n   to send the same prefix while utilizing other\n   extension specific information.  An example of\n   this is RFC 3107 - Carrying MPLS labels in BGP.")
jnxBgpM2NlriAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriAfi.setDescription("The address family of the prefix for this NLRI.")
jnxBgpM2NlriSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 3), JnxBgpM2Safi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriSafi.setDescription("The subsequent address family of the prefix for\nthis NLRI")
jnxBgpM2NlriPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriPrefix.setDescription("An IP address prefix in the Network Layer\nReachability Information field.  This object\nis an IP address containing the prefix with\nlength specified by\njnxBgpM2PathAttrAddrPrefixLen.\nAny bits beyond the length specified by\njnxBgpM2PathAttrAddrPrefixLen are zeroed.")
jnxBgpM2NlriPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 5), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriPrefixLen.setDescription("Length in bits of the address prefix in\nthe Network Layer Reachability Information field.")
jnxBgpM2NlriBest = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriBest.setDescription("An indication of whether or not this route\nwas chosen as the best BGP4 route.")
jnxBgpM2NlriCalcLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriCalcLocalPref.setDescription("The degree of preference calculated by the\nreceiving BGP4 speaker for an advertised\nroute.")
jnxBgpM2PathAttrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrIndex.setDescription("This value is a unique index for the per-NLRI entry\nin the jnxBgpM2PeerAttrTable.  It is assigned by the\nagent at the point of creation of the jnxBgpM2PeerAttrTable\nrow entry.  While its value is guaranteed to be unique\nat any time, it is otherwise opaque to the management\napplication with respect to its value or the contiguity\nof jnxBgpM2PeerAttrIndex row instance values across rows\nof the jnxBgpM2PeerAttrTable.  It is used to provide an\nindex structure for other tables whose data is logically\nper-peer, per-NLRI.")
jnxBgpM2NlriOpaqueType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("none", 0), ("bgpMplsLabelStack", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriOpaqueType.setDescription("This object enumerates the type of the row that is\npointed to in the table row jnxBgpM2NlriOpaquePointer\ninstance, if jnxBgpM2NlriOpaquePointer is in fact not\na zero length.  jnxBgpM2NlriOpaqueType is necessary since\nthe data referenced by jnxBgpM2NlriOpaquePointer is\nopaque to BGP.  For example, in the case of RFC 3107,\nthe label stack that is pointed to may occur in the\nmplsLabelStackTable from the MPLS-LSR-MIB, and the\ninstance value of jnxBgpM2NlriOpaqueType would be\nbgpMplsLabelStack(1).")
jnxBgpM2NlriOpaquePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 1, 1, 10), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2NlriOpaquePointer.setDescription("Pointer to a row that decomposes the data that is\nopaque to the BGP MIB but is sent in the NLRI.\nThis RowPointer has zero (0) length data instance\nif jnxBgpM2NlriOpaqueType is none.")
jnxBgpM2AdjRibsOutTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 2))
if mibBuilder.loadTexts: jnxBgpM2AdjRibsOutTable.setDescription("This table contains on a per-peer basis one or more\nroutes from the jnxBgpM2NlriTable that have been\nplaced in this peer's Adj-Ribs-Out.")
jnxBgpM2AdjRibsOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 2, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriAfi"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriSafi"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriPrefix"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriPrefixLen"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2AdjRibsOutIndex"))
if mibBuilder.loadTexts: jnxBgpM2AdjRibsOutEntry.setDescription("List of BGP routes that have been placed into a\npeer's Adj-Ribs-Out.")
jnxBgpM2AdjRibsOutIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AdjRibsOutIndex.setDescription("Certain extensions to BGP permit multiple instance of\na per afi, per safi prefix to be advertised to a peer.\nThis object allows the enumeration of them.")
jnxBgpM2AdjRibsOutRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 2, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AdjRibsOutRoute.setDescription("This object points to the route in the jnxBgpM2NlriTable\nthat corresponds to the entry in the peer's\nAdj-Rib-Out.  Outgoing route maps are not\nreflected at this point as those are part of the\nUpdate-Send process.")
jnxBgpM2PathAttrCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrCount.setDescription("The number of entries in the jnxBgpM2PathAttrTable.")
jnxBgpM2PathAttrTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4))
if mibBuilder.loadTexts: jnxBgpM2PathAttrTable.setDescription("Provides per advertised network-prefix attribute data,\nas advertised over a peering session.")
jnxBgpM2PathAttrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"))
if mibBuilder.loadTexts: jnxBgpM2PathAttrEntry.setDescription("Each entry contains data about a given network\nprefix, per-prefix and per-advertising peer.")
jnxBgpM2PathAttrOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrOrigin.setDescription("The ultimate origin of the path information.")
jnxBgpM2PathAttrNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrNextHopAddrType.setDescription("The address family of the address for\nthe border router that should be used\nto access the destination network.")
jnxBgpM2PathAttrNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrNextHop.setDescription("The address of the border router that\nshould be used to access the destination\nnetwork.  This address is the nexthop\naddress received in the UPDATE packet.\nThe address family of this object will be the\nsame as that of the prefix in this row.\n\nNote that for RFC2545 style double nexthops,\nthis object will always contain the global scope\nnexthop.  jnxBgpM2LinkLocalNextHopTable will contain\nthe linklocal scope nexthop.\n\nIn the case that the mechanism documented in\ndraft-kato-bgp-ipv6-link-local-00.txt is used and\nonly a link local nexthop has been sent, ,\njnxBgpM2LinkLocalNextHopPresent will be false\nand jnxBgpM2PathAttrNextHop will contain the link local\nnexthop.")
jnxBgpM2PathAttrMedPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrMedPresent.setDescription("Whether or not the MED value is present.\nIf it is not present, the jnxBgpM2PathAttrMed\nobject has no useful value and should be set to 0.")
jnxBgpM2PathAttrMed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrMed.setDescription("This metric is used to discriminate\nbetween multiple exit points to an\nadjacent autonomous system.")
jnxBgpM2PathAttrLocalPrefPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrLocalPrefPresent.setDescription("Whether or not the LocalPref value is present.\nIf it is not present, the jnxBgpM2PathAttrLocalPref\nobject has no useful value and should be set to 0.")
jnxBgpM2PathAttrLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrLocalPref.setDescription("The originating BGP4 speakers degree of\npreference for an advertised route.")
jnxBgpM2PathAttrAtomicAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("atomicAggregatePresent", 1), ("atomicAggregateMissing", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrAtomicAggregate.setDescription("When this object is set to atomicAggregatePresent,\nthe ATOMIC_AGGREGATE Path Attribute is present\nand indicates that the NLRI MUST NOT be made\nmore specific.")
jnxBgpM2PathAttrAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 9), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrAggregatorAS.setDescription("The AS number of the last BGP4 speaker that\nperformed route aggregation.  A value of\nzero (0) indicates the absence of this\nattribute.\n\nNote propagation of AS of zero is illegal in\nthe Internet.")
jnxBgpM2PathAttrAggregatorAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 10), JnxBgpM2Identifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrAggregatorAddr.setDescription("The IP address of the last BGP4 speaker\nthat performed route aggregation.  A\nvalue of 0.0.0.0 indicates the absence\nof this attribute.")
jnxBgpM2AsPathCalcLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathCalcLength.setDescription("This value represents the calculated length of the\nAS Path according to the rules of the BGP specification.\nThis value is used in route selection.")
jnxBgpM2AsPathString = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 12), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathString.setDescription("This is a string depicting the autonomous system\npath to this network which was received from the\npeer which advertised it.  The format of the string\nis implementation-dependent, and should be designed\nfor operator readability.")
jnxBgpM2AsPathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 4, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathIndex.setDescription("This value is a unique index for the decomposed AS Path\nin the jnxBgpM2AsPathTable.  It is assigned by the\nagent at the point of creation of the jnxBgpM2AsPathTable\nrow entry.  While its value is guaranteed to be unique\nat any time, it is otherwise opaque to the management\napplication with respect to its value or the contiguity\nof jnxBgpM2AsPathIndex row instance values across rows\nof the jnxBgpM2AsPathTable.")
jnxBgpM2AsPath4byteTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5))
if mibBuilder.loadTexts: jnxBgpM2AsPath4byteTable.setDescription("This table is present for BGP speakers that support\nthe AS 4byte specification and are functioning as\na router between 2-byte and 4-byte AS space.")
jnxBgpM2AsPath4byteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5, 1))
if mibBuilder.loadTexts: jnxBgpM2AsPath4byteEntry.setDescription("Each row contains the information for the AS 4-byte\nextension's NEW_AS_PATH and NEW_AGGREGATOR attributes.")
jnxBgpM2AsPath4bytePathPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPath4bytePathPresent.setDescription("This value may only be true if this BGP Speaker\nis functioning as a router between ASs that\nare in 2-byte and 4-byte AS space.  If this\nvalue is true, then the NEW_AS_PATH attributes\nare present and the 4-byte versions of the\nappropriate path attributes are in this row.\n\nIf this value is false, then the following values\nwill be present in the row:\n\njnxBgpM2PathAttrAggregatorAS - zero (0).\njnxBgpM2AsPathCalcLength - zero (0).\njnxBgpM2AsPathString - zero (0) length string.\njnxBgpM2AsPathIndex - zero (0).")
jnxBgpM2AsPath4byteAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5, 1, 2), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPath4byteAggregatorAS.setDescription("The NEW_AGGREGATOR AS number of the last BGP4 speaker\nthat performed route aggregation.  A value of\nzero (0) indicates the absence of this\nattribute.\n\nNote propagation of AS of zero is illegal in\nthe Internet.")
jnxBgpM2AsPath4byteCalcLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPath4byteCalcLength.setDescription("This value represents the calculated length of the\nNEW_AS_PATH according to the rules of the BGP specification.\nThis value is used in route selection.")
jnxBgpM2AsPath4byteString = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPath4byteString.setDescription("This is a string depicting the autonomous system\npath to this network which was received from the\npeer which advertised it.  The format of the string\nis implementation-dependent, and should be designed\nfor operator readability.")
jnxBgpM2AsPath4byteIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 5, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPath4byteIndex.setDescription("This value is a unique index for the decomposed AS Path\nin the jnxBgpM2AsPathTable.  It is assigned by the\nagent at the point of creation of the jnxBgpM2AsPathTable\nrow entry.  While its value is guaranteed to be unique\nat any time, it is otherwise opaque to the management\napplication with respect to its value or the contiguity\nof jnxBgpM2AsPathIndex row instance values across rows\nof the jnxBgpM2AsPathTable. ")
jnxBgpM2AsPathTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 6))
if mibBuilder.loadTexts: jnxBgpM2AsPathTable.setDescription("The BGP-4 Path Attribute AS Path Table\ncontains the per network path (NLRI)\nAS PATH data received from the\nadvertising BGP peer.")
jnxBgpM2AsPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 6, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathSegmentIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathElementIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathElementValue"))
if mibBuilder.loadTexts: jnxBgpM2AsPathEntry.setDescription("Information about an AS path provided with a path to\na network.")
jnxBgpM2AsPathSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 6, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathSegmentIndex.setDescription("A per-AS path segment index.  This will index a set of\nautonomous systems in an AS path which are part\nof the same sequence or set (as determined by\nthe row value of jnxBgpM2AsPathType, which\nshould be the same value for each jnxBgpM2AsPathTable\nentry indexed by the same (jnxBgpM2PathAttrIndex,\njnxBgpM2AsPathIndex) pair).")
jnxBgpM2AsPathElementIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 6, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathElementIndex.setDescription("A per-AS element index.  This will index a particular\nAS within a sequence or set of autonomous systems in\nan AS path.")
jnxBgpM2AsPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 6, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,4,)).subtype(namedValues=NamedValues(("asSet", 1), ("asSequence", 2), ("confedSequence", 3), ("confedSet", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathType.setDescription("The type of sequence in which this asPath\nwas advertised as an attribute.  Note that\nall asPath row instances for a given (jnxBgpM2PathAttrIndex,\njnxBgpM2AsPathIndex) index pair will have their\njnxBgpM2AsPathType set to the same value.\nThe values for jnxBgpM2AsPathType are\ninterpreted as defined in the base BGP document\nand the BGP AS Confederations document.")
jnxBgpM2AsPathElementValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 6, 1, 4), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2AsPathElementValue.setDescription("An AS value for an AS the related NLRI traversed\nin the propagation of its advertisement.  This\nvalue is to be interpreted in the context of the\nsequence implied by jnxBgpM2AsPathIndex and\njnxBgpM2AsPathType (and, in sequence of the\nother table rows with the same value of\njnxBgpM2PathAttrIndex and jnxBgpM2AsPathIndex).")
jnxBgpM2PathAttrUnknownTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 7))
if mibBuilder.loadTexts: jnxBgpM2PathAttrUnknownTable.setDescription("The BGP-4 Path Attribute Unknown Table\ncontains the per network path (NLRI)\ndata on the path attributes advertised\nwith a route but not known to the local BGP implementation\nor not otherwise capable of being returned from this agent.\n\nThe absence of row data for a given index value for\njnxBgpM2PathAttrIndex indicates a lack of such unknown\nattribute information for the indicated network path\n(as indexed by that jnxBgpM2PathAttrIndex value in the\njnxBgpM2PathAttrTable).")
jnxBgpM2PathAttrUnknownEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 7, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrUnknownIndex"))
if mibBuilder.loadTexts: jnxBgpM2PathAttrUnknownEntry.setDescription("Information about an unknown attribute\nprovided with a path to a network.")
jnxBgpM2PathAttrUnknownIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 7, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrUnknownIndex.setDescription("An integer index for a row in this table.")
jnxBgpM2PathAttrUnknownType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 7, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrUnknownType.setDescription("The attribute type advertised with this unknown\nattribute by the peer.")
jnxBgpM2PathAttrUnknownValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 7, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4070))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrUnknownValue.setDescription("Value of path attribute not understood\nby the base BGP-4 document.\n\nOctets beyond the maximum size, if any,\nare not recorded by this row object. ")
jnxBgpM2PathAttrExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8))
jnxBgpM2PathAttrNonCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1))
jnxBgpM2PathAttrCommunityExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 1997))
jnxBgpM2PathAttrCommTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 1997, 1))
if mibBuilder.loadTexts: jnxBgpM2PathAttrCommTable.setDescription("The BGP-4 Path Attribute Community Table\ncontains the per network path (NLRI)\ndata on the community membership advertised\nwith a route.  The absence of row\ndata for a given index value for jnxBgpM2PathAttrIndex\nindicates a lack of this attribute information\nfor the indicated network path (as indexed by\nthat jnxBgpM2PathAttrIndex value in the jnxBgpM2PathAttrTable).")
jnxBgpM2PathAttrCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 1997, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrCommIndex"))
if mibBuilder.loadTexts: jnxBgpM2PathAttrCommEntry.setDescription("Information about a community association\nprovided with a path to a network.")
jnxBgpM2PathAttrCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 1997, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrCommIndex.setDescription("An integer index for a row in this table.")
jnxBgpM2PathAttrCommValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 1997, 1, 1, 2), JnxBgpM2Community()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrCommValue.setDescription("A value representing a community.   There are certain\n4-octet long values which could be returned in this\ncolumnar row data that carry additional semantics.")
jnxBgpM2LinkLocalNextHopTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2545))
if mibBuilder.loadTexts: jnxBgpM2LinkLocalNextHopTable.setDescription("Table of link local nexthops as sent by RFC 2545\nfor IPv6 BGP Speakers.")
jnxBgpM2LinkLocalNextHopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2545, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"))
if mibBuilder.loadTexts: jnxBgpM2LinkLocalNextHopEntry.setDescription("Entry containing the link-local nexthops as sent\nby a BGP speaker running RFC 2545 extensions for\ndouble-nexthops.")
jnxBgpM2LinkLocalNextHopPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2545, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2LinkLocalNextHopPresent.setDescription("This value is TRUE if and only if the BGP\nspeaker is receiving IPv6 NLRI using the\nRFC 2545 double nexthop convention and it\nhas received a link local scope nexthop in\naddition to the global scope nexthop.")
jnxBgpM2LinkLocalNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2545, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2LinkLocalNextHop.setDescription("This value contains an IPv6 link local address of\nInetAddressType of type ipv6z.  This value is only\npresent if jnxBgpM2LinkLocalNextHopPresent is true.")
jnxBgpM2PathAttrRouteReflectionExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796))
jnxBgpM2PathAttrOriginatorIdTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 1))
if mibBuilder.loadTexts: jnxBgpM2PathAttrOriginatorIdTable.setDescription("Per prefix data pertinent to advertisement of a\nnetwork prefix through an originator.")
jnxBgpM2PathAttrOriginatorIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 1, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"))
if mibBuilder.loadTexts: jnxBgpM2PathAttrOriginatorIdEntry.setDescription("Each entry contains data pertinent to a network\nprefix as received through its originating BGP\nroute reflector.")
jnxBgpM2PathAttrOriginatorId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 1, 1, 1), JnxBgpM2Identifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrOriginatorId.setDescription("The Originator-ID identifying the router that initially\nadvertised this destination to a Route Reflector.  A\nvalue of 0.0.0.0 indicates the absence of this attribute.")
jnxBgpM2PathAttrClusterTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 2))
if mibBuilder.loadTexts: jnxBgpM2PathAttrClusterTable.setDescription("The BGP-4 Path Attribute Cluster Table\ncontains the per network path (NLRI)\ndata on the reflection path which a\nroute has traversed.  The absence of row\ndata for a given index value for jnxBgpM2PathAttrIndex\nindicates a lack of this attribute information\nfor the indicated network path (as indexed by\nthat jnxBgpM2PathAttrIndex value in the jnxBgpM2PathAttrTable).")
jnxBgpM2PathAttrClusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 2, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrClusterIndex"))
if mibBuilder.loadTexts: jnxBgpM2PathAttrClusterEntry.setDescription("Information about a cluster traversal\nprovided with a path to a network.")
jnxBgpM2PathAttrClusterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrClusterIndex.setDescription("An integral index for a row in this table.")
jnxBgpM2PathAttrClusterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 2796, 2, 1, 2), JnxBgpM2Identifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrClusterValue.setDescription("A four octet long value representing a part of the\nreflection path that the route has passed.  Each such four\noctet long value represents the ID of a cluster that\nthe route has traversed.  The sequence of this path as\nreceived in the route advertisement will be preserved in\nthe sequence of jnxBgpM2PathAttrClusterTable rows (and the\njnxBgpM2PathAttrClusterValues in each row) as returned for\na given jnxBgpM2PathAttrIndex value, and the monotonically\nincreasing sequence of jnxBgpM2PathAttrClusterIndex values\nfor that jnxBgpM2PathAttrIndex.")
jnxBgpM2PathAttrExtCommTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 65001))
if mibBuilder.loadTexts: jnxBgpM2PathAttrExtCommTable.setDescription("The BGP-4 Path Attribute Community Table\ncontains the per network path (NLRI)\ndata on the extended community membership advertised\nwith a route.  The absence of row\ndata for a given index value for jnxBgpM2PathAttrIndex\nindicates a lack of this attribute information\nfor the indicated network path (as indexed by\nthat jnxBgpM2PathAttrIndex value in the jnxBgpM2PathAttrTable).\n\nXXX JMH - can not assign the OID until an RFC is published.")
jnxBgpM2PathAttrExtCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 65001, 1)).setIndexNames((0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"), (0, "BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrExtCommIndex"))
if mibBuilder.loadTexts: jnxBgpM2PathAttrExtCommEntry.setDescription("Information about an extended community association\nprovided with a path to a network.")
jnxBgpM2PathAttrExtCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 65001, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrExtCommIndex.setDescription("An integral index for a row in this table.")
jnxBgpM2PathAttrExtCommValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 1, 65001, 1, 2), JnxBgpM2ExtendedCommunity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxBgpM2PathAttrExtCommValue.setDescription("A value representing an extended community which was\nreceived with the route implied by the jnxBgpM2PathAttr\nIndex value of this row data.   There are certain\n8-octet long values which could be returned in this\ncolumnar row data that carry additional semantics.")
jnxBgpM2PathAttrCapExts = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 3, 8, 2))
jnxBgpM2Conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4))
jnxBgpM2MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 1))
jnxBgpM2MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2))

# Augmentions
jnxBgpM2CfgPeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerTimersEntry"))
jnxBgpM2CfgPeerTimersEntry.setIndexNames(*jnxBgpM2CfgPeerEntry.getIndexNames())
jnxBgpM2CfgPeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerAuthEntry"))
jnxBgpM2CfgPeerAuthEntry.setIndexNames(*jnxBgpM2CfgPeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerConfedMemberEntry"))
jnxBgpM2PeerConfedMemberEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2CfgPeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerReflectorClientEntry"))
jnxBgpM2CfgPeerReflectorClientEntry.setIndexNames(*jnxBgpM2CfgPeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthEntry"))
jnxBgpM2PeerAuthEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerEventTimesEntry"))
jnxBgpM2PeerEventTimesEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2CfgPeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerConfedMemberEntry"))
jnxBgpM2CfgPeerConfedMemberEntry.setIndexNames(*jnxBgpM2CfgPeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerErrorsEntry"))
jnxBgpM2PeerErrorsEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerReflectorClientEntry"))
jnxBgpM2PeerReflectorClientEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCountersEntry"))
jnxBgpM2PeerCountersEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerNegotiatedTimersEntry"))
jnxBgpM2PeerNegotiatedTimersEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2PeerEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerConfiguredTimersEntry"))
jnxBgpM2PeerConfiguredTimersEntry.setIndexNames(*jnxBgpM2PeerEntry.getIndexNames())
jnxBgpM2PathAttrEntry.registerAugmentions(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPath4byteEntry"))
jnxBgpM2AsPath4byteEntry.setIndexNames(*jnxBgpM2PathAttrEntry.getIndexNames())

# Notifications

jnxBgpM2Established = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 0, 1)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceived"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddr"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerState"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddr"), ) )
if mibBuilder.loadTexts: jnxBgpM2Established.setDescription("The BGP Established event is generated when\nthe BGP FSM enters the ESTABLISHED state.")
jnxBgpM2BackwardTransition = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 1, 0, 2)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceived"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceivedText"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddr"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerState"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddr"), ) )
if mibBuilder.loadTexts: jnxBgpM2BackwardTransition.setDescription("The BGPBackwardTransition Event is generated\nwhen the BGP FSM moves from a higher numbered\nstate to a lower numbered state.")

# Groups

jnxBgpM2AuthenticationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 1)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2SupportedAuthCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthSentCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthRcvd"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthSentValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthSent"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2SupportedAuthValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthRcvdCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthRcvdValue"), ) )
if mibBuilder.loadTexts: jnxBgpM2AuthenticationGroup.setDescription("Objects associated with BGP authentication.")
jnxBgpM2CommunitiesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 2)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrCommValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrCommIndex"), ) )
if mibBuilder.loadTexts: jnxBgpM2CommunitiesGroup.setDescription("Objects associated with BGP communities.")
jnxBgpM2ExtCommunitiesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 3)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrExtCommIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrExtCommValue"), ) )
if mibBuilder.loadTexts: jnxBgpM2ExtCommunitiesGroup.setDescription("Objects associated with BGP extended communities.")
jnxBgpM2RouteReflectionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 4)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrClusterIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerReflectorClient"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrOriginatorId"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2ClusterId"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2RouteReflector"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrClusterValue"), ) )
if mibBuilder.loadTexts: jnxBgpM2RouteReflectionGroup.setDescription("Objects associated with BGP route reflection.")
jnxBgpM2AsConfederationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 5)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2ConfederationRouter"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2ConfederationId"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerConfedMember"), ) )
if mibBuilder.loadTexts: jnxBgpM2AsConfederationGroup.setDescription("Objects associated with BGP confederation membership.")
jnxBgpM2TimersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 6)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerHoldTimeConfigured"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerHoldTime"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerFsmEstablishedTime"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerKeepAlive"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerKeepAliveConfigured"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerMinASOrigInterval"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerConnectRetryInterval"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerInUpdatesElapsedTime"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerMinRouteAdverInterval"), ) )
if mibBuilder.loadTexts: jnxBgpM2TimersGroup.setDescription("Objects associated with BGP peering timers.")
jnxBgpM2CountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 7)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerOutTotalMessages"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixCountersAfi"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixCountersSafi"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerInTotalMessages"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixInPrefixesAccepted"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixOutPrefixes"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixInPrefixes"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerInUpdates"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerFsmEstablishedTrans"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PrefixInPrefixesRejected"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerOutUpdates"), ) )
if mibBuilder.loadTexts: jnxBgpM2CountersGroup.setDescription("Objects to count discrete events and exchanges on BGP\nsessions.")
jnxBgpM2CapabilitiesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 8)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapAnnouncedValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapAnnouncedCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2SupportedCapabilityCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapReceivedIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CapabilitySupportAvailable"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2SupportedCapability"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapAnnouncedIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapReceivedCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerCapReceivedValue"), ) )
if mibBuilder.loadTexts: jnxBgpM2CapabilitiesGroup.setDescription("Objects to report capabilities as received on BGP\nsessions.")
jnxBgpM2AsPathGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 9)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathSegmentIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathElementIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathElementValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathType"), ) )
if mibBuilder.loadTexts: jnxBgpM2AsPathGroup.setDescription("Objects to report AS paths received on BGP NLRIs.")
jnxBgpM2As4byteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 10)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPath4byteIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPath4bytePathPresent"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsSize"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPath4byteString"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPath4byteCalcLength"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPath4byteAggregatorAS"), ) )
if mibBuilder.loadTexts: jnxBgpM2As4byteGroup.setDescription("AS Size objects.")
jnxBgpM2BaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 11)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2LocalIdentifier"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2VersionIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2VersionSupported"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2LocalAs"), ) )
if mibBuilder.loadTexts: jnxBgpM2BaseGroup.setDescription("Basic objects in local BGP implementation.")
jnxBgpM2ErrorsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 12)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceivedData"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorSentTime"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorSentText"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorSent"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceived"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceivedText"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorReceivedTime"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLastErrorSentData"), ) )
if mibBuilder.loadTexts: jnxBgpM2ErrorsGroup.setDescription("Errors received on BGP peering sessions.")
jnxBgpM2PeerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 13)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAs"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalPort"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIdentifier"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerState"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAddr"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerNegotiatedVersion"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerLocalAddr"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemotePort"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRemoteAs"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerConfiguredVersion"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerStatus"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRoutingInstance"), ) )
if mibBuilder.loadTexts: jnxBgpM2PeerGroup.setDescription("Core object types on BGP peering sessions.")
jnxBgpM2PathAttributesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 14)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrNextHopAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriCalcLocalPref"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrAtomicAggregate"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrOrigin"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrCount"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriOpaqueType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrUnknownType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AdjRibsOutRoute"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathString"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathElementValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrUnknownValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriSafi"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriAfi"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AdjRibsOutIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathCalcLength"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrMedPresent"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriOpaquePointer"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriPrefixLen"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrAggregatorAddr"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrUnknownIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriPrefix"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrLocalPrefPresent"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrNextHop"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrAggregatorAS"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2NlriBest"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrMed"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttrLocalPref"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathIndex"), ) )
if mibBuilder.loadTexts: jnxBgpM2PathAttributesGroup.setDescription("Attributes received on BGP peering sessions.")
jnxBgpM2PeerConfigurationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 15)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgAllowVersionNegotiation"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerLocalAs"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerConfiguredVersion"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerRemoteAs"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerMinASOrigInterval"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerAdminStatus"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerRemotePort"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerBgpPeerEntry"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerKeepAliveConfigured"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerEntryStorageType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgBaseScalarStorageType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerMinRouteAdverInter"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerLocalAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerStatus"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerLocalAddr"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerError"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerConnectRetryInterval"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgLocalAs"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerRowEntryStatus"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerNextIndex"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgLocalIdentifier"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerRemoteAddrType"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerHoldTimeConfigured"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerRemoteAddr"), ) )
if mibBuilder.loadTexts: jnxBgpM2PeerConfigurationGroup.setDescription("Configuration objects for BGP peers.")
jnxBgpM2PeerAuthConfigurationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 16)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerAuthValue"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerAuthCode"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerAuthEnabled"), ) )
if mibBuilder.loadTexts: jnxBgpM2PeerAuthConfigurationGroup.setDescription("Configuration objects for BGP peers that support\nauthentication.")
jnxBgpM2PeerRouteReflectorCfgGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 17)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgClusterId"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerReflectorClient"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgRouteReflector"), ) )
if mibBuilder.loadTexts: jnxBgpM2PeerRouteReflectorCfgGroup.setDescription("Configuration objects for BGP peers that support route\nreflection.")
jnxBgpM2PeerAsConfederationCfgGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 18)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgPeerConfedMember"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgConfederationId"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CfgConfederationRouter"), ) )
if mibBuilder.loadTexts: jnxBgpM2PeerAsConfederationCfgGroup.setDescription("Configuration objects for BGP peers that support BGP\nconfederations.")
jnxBgpM2MIBNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 19)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2BackwardTransition"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2Established"), ) )
if mibBuilder.loadTexts: jnxBgpM2MIBNotificationsGroup.setDescription("This group contains objects for notifications\nsupported by this mib module.")
jnxBgpM2Rfc2545Group = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 2, 20)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2LinkLocalNextHopPresent"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2LinkLocalNextHop"), ) )
if mibBuilder.loadTexts: jnxBgpM2Rfc2545Group.setDescription("This group is required for peers that support exchanging\nof IPv6 NLRI per RFC 2545.")

# Compliances

jnxBgpM2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 5, 1, 1, 4, 1, 1)).setObjects(*(("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerRouteReflectorCfgGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2BaseGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2ExtCommunitiesGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2As4byteGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CommunitiesGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CountersGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2CapabilitiesGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PathAttributesGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2ErrorsGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2RouteReflectionGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2Rfc2545Group"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2TimersGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsConfederationGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2MIBNotificationsGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AsPathGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2AuthenticationGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAsConfederationCfgGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerAuthConfigurationGroup"), ("BGP4-V2-MIB-JUNIPER", "jnxBgpM2PeerConfigurationGroup"), ) )
if mibBuilder.loadTexts: jnxBgpM2MIBCompliance.setDescription("The compliance statement for entities which\nimplement the BGP4 mib.")

# Exports

# Module identity
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", PYSNMP_MODULE_ID=jnxBgpM2)

# Types
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", JnxBgpM2Community=JnxBgpM2Community, JnxBgpM2ExtendedCommunity=JnxBgpM2ExtendedCommunity, JnxBgpM2Identifier=JnxBgpM2Identifier, JnxBgpM2Safi=JnxBgpM2Safi)

# Objects
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", jnxBgpM2=jnxBgpM2, jnxBgpM2BaseScalars=jnxBgpM2BaseScalars, jnxBgpM2BaseNotifications=jnxBgpM2BaseNotifications, jnxBgpM2Version=jnxBgpM2Version, jnxBgpM2VersionTable=jnxBgpM2VersionTable, jnxBgpM2VersionEntry=jnxBgpM2VersionEntry, jnxBgpM2VersionIndex=jnxBgpM2VersionIndex, jnxBgpM2VersionSupported=jnxBgpM2VersionSupported, jnxBgpM2SupportedAuthentication=jnxBgpM2SupportedAuthentication, jnxBgpM2SupportedAuthTable=jnxBgpM2SupportedAuthTable, jnxBgpM2SupportedAuthEntry=jnxBgpM2SupportedAuthEntry, jnxBgpM2SupportedAuthCode=jnxBgpM2SupportedAuthCode, jnxBgpM2SupportedAuthValue=jnxBgpM2SupportedAuthValue, jnxBgpM2SupportedCapabilities=jnxBgpM2SupportedCapabilities, jnxBgpM2CapabilitySupportAvailable=jnxBgpM2CapabilitySupportAvailable, jnxBgpM2SupportedCapabilitiesTable=jnxBgpM2SupportedCapabilitiesTable, jnxBgpM2SupportedCapabilitiesEntry=jnxBgpM2SupportedCapabilitiesEntry, jnxBgpM2SupportedCapabilityCode=jnxBgpM2SupportedCapabilityCode, jnxBgpM2SupportedCapability=jnxBgpM2SupportedCapability, jnxBgpM2AsSize=jnxBgpM2AsSize, jnxBgpM2LocalAs=jnxBgpM2LocalAs, jnxBgpM2LocalIdentifier=jnxBgpM2LocalIdentifier, jnxBgpM2BaseScalarExtensions=jnxBgpM2BaseScalarExtensions, jnxBgpM2BaseScalarNonCapExts=jnxBgpM2BaseScalarNonCapExts, jnxBgpM2BaseScalarRouteReflectExts=jnxBgpM2BaseScalarRouteReflectExts, jnxBgpM2RouteReflector=jnxBgpM2RouteReflector, jnxBgpM2ClusterId=jnxBgpM2ClusterId, jnxBgpM2BaseScalarASConfedExts=jnxBgpM2BaseScalarASConfedExts, jnxBgpM2ConfederationRouter=jnxBgpM2ConfederationRouter, jnxBgpM2ConfederationId=jnxBgpM2ConfederationId, jnxBgpM2BaseScalarCapExts=jnxBgpM2BaseScalarCapExts, jnxBgpM2BaseScalarConfiguration=jnxBgpM2BaseScalarConfiguration, jnxBgpM2CfgBaseScalarStorageType=jnxBgpM2CfgBaseScalarStorageType, jnxBgpM2CfgLocalAs=jnxBgpM2CfgLocalAs, jnxBgpM2CfgLocalIdentifier=jnxBgpM2CfgLocalIdentifier, jnxBgpM2CfgBaseScalarExtensions=jnxBgpM2CfgBaseScalarExtensions, jnxBgpM2CfgBaseScalarNonCapExts=jnxBgpM2CfgBaseScalarNonCapExts, jnxBgpM2CfgBaseScalarReflectorExts=jnxBgpM2CfgBaseScalarReflectorExts, jnxBgpM2CfgRouteReflector=jnxBgpM2CfgRouteReflector, jnxBgpM2CfgClusterId=jnxBgpM2CfgClusterId, jnxBgpM2CfgBaseScalarASConfedExts=jnxBgpM2CfgBaseScalarASConfedExts, jnxBgpM2CfgConfederationRouter=jnxBgpM2CfgConfederationRouter, jnxBgpM2CfgConfederationId=jnxBgpM2CfgConfederationId, jnxBgpM2CfgBaseScalarCapExts=jnxBgpM2CfgBaseScalarCapExts, jnxBgpM2Peer=jnxBgpM2Peer, jnxBgpM2PeerData=jnxBgpM2PeerData, jnxBgpM2PeerTable=jnxBgpM2PeerTable, jnxBgpM2PeerEntry=jnxBgpM2PeerEntry, jnxBgpM2PeerIdentifier=jnxBgpM2PeerIdentifier, jnxBgpM2PeerState=jnxBgpM2PeerState, jnxBgpM2PeerStatus=jnxBgpM2PeerStatus, jnxBgpM2PeerConfiguredVersion=jnxBgpM2PeerConfiguredVersion, jnxBgpM2PeerNegotiatedVersion=jnxBgpM2PeerNegotiatedVersion, jnxBgpM2PeerLocalAddrType=jnxBgpM2PeerLocalAddrType, jnxBgpM2PeerLocalAddr=jnxBgpM2PeerLocalAddr, jnxBgpM2PeerLocalPort=jnxBgpM2PeerLocalPort, jnxBgpM2PeerLocalAs=jnxBgpM2PeerLocalAs, jnxBgpM2PeerRemoteAddrType=jnxBgpM2PeerRemoteAddrType, jnxBgpM2PeerRemoteAddr=jnxBgpM2PeerRemoteAddr, jnxBgpM2PeerRemotePort=jnxBgpM2PeerRemotePort, jnxBgpM2PeerRemoteAs=jnxBgpM2PeerRemoteAs, jnxBgpM2PeerIndex=jnxBgpM2PeerIndex, jnxBgpM2PeerRoutingInstance=jnxBgpM2PeerRoutingInstance, jnxBgpM2PeerErrors=jnxBgpM2PeerErrors, jnxBgpM2PeerErrorsTable=jnxBgpM2PeerErrorsTable, jnxBgpM2PeerErrorsEntry=jnxBgpM2PeerErrorsEntry, jnxBgpM2PeerLastErrorReceived=jnxBgpM2PeerLastErrorReceived, jnxBgpM2PeerLastErrorSent=jnxBgpM2PeerLastErrorSent, jnxBgpM2PeerLastErrorReceivedTime=jnxBgpM2PeerLastErrorReceivedTime, jnxBgpM2PeerLastErrorSentTime=jnxBgpM2PeerLastErrorSentTime, jnxBgpM2PeerLastErrorReceivedText=jnxBgpM2PeerLastErrorReceivedText, jnxBgpM2PeerLastErrorSentText=jnxBgpM2PeerLastErrorSentText, jnxBgpM2PeerLastErrorReceivedData=jnxBgpM2PeerLastErrorReceivedData, jnxBgpM2PeerLastErrorSentData=jnxBgpM2PeerLastErrorSentData, jnxBgpM2PeerAuthentication=jnxBgpM2PeerAuthentication, jnxBgpM2PeerAuthTable=jnxBgpM2PeerAuthTable, jnxBgpM2PeerAuthEntry=jnxBgpM2PeerAuthEntry, jnxBgpM2PeerAuthSent=jnxBgpM2PeerAuthSent, jnxBgpM2PeerAuthSentCode=jnxBgpM2PeerAuthSentCode, jnxBgpM2PeerAuthSentValue=jnxBgpM2PeerAuthSentValue, jnxBgpM2PeerAuthRcvd=jnxBgpM2PeerAuthRcvd, jnxBgpM2PeerAuthRcvdCode=jnxBgpM2PeerAuthRcvdCode, jnxBgpM2PeerAuthRcvdValue=jnxBgpM2PeerAuthRcvdValue, jnxBgpM2PeerTimers=jnxBgpM2PeerTimers, jnxBgpM2PeerEventTimesTable=jnxBgpM2PeerEventTimesTable, jnxBgpM2PeerEventTimesEntry=jnxBgpM2PeerEventTimesEntry, jnxBgpM2PeerFsmEstablishedTime=jnxBgpM2PeerFsmEstablishedTime, jnxBgpM2PeerInUpdatesElapsedTime=jnxBgpM2PeerInUpdatesElapsedTime, jnxBgpM2PeerConfiguredTimersTable=jnxBgpM2PeerConfiguredTimersTable, jnxBgpM2PeerConfiguredTimersEntry=jnxBgpM2PeerConfiguredTimersEntry, jnxBgpM2PeerConnectRetryInterval=jnxBgpM2PeerConnectRetryInterval, jnxBgpM2PeerHoldTimeConfigured=jnxBgpM2PeerHoldTimeConfigured, jnxBgpM2PeerKeepAliveConfigured=jnxBgpM2PeerKeepAliveConfigured, jnxBgpM2PeerMinASOrigInterval=jnxBgpM2PeerMinASOrigInterval, jnxBgpM2PeerMinRouteAdverInterval=jnxBgpM2PeerMinRouteAdverInterval, jnxBgpM2PeerNegotiatedTimersTable=jnxBgpM2PeerNegotiatedTimersTable, jnxBgpM2PeerNegotiatedTimersEntry=jnxBgpM2PeerNegotiatedTimersEntry, jnxBgpM2PeerHoldTime=jnxBgpM2PeerHoldTime, jnxBgpM2PeerKeepAlive=jnxBgpM2PeerKeepAlive, jnxBgpM2PeerCapabilities=jnxBgpM2PeerCapabilities, jnxBgpM2PeerCapsAnnouncedTable=jnxBgpM2PeerCapsAnnouncedTable, jnxBgpM2PeerCapsAnnouncedEntry=jnxBgpM2PeerCapsAnnouncedEntry, jnxBgpM2PeerCapAnnouncedCode=jnxBgpM2PeerCapAnnouncedCode, jnxBgpM2PeerCapAnnouncedIndex=jnxBgpM2PeerCapAnnouncedIndex, jnxBgpM2PeerCapAnnouncedValue=jnxBgpM2PeerCapAnnouncedValue, jnxBgpM2PeerCapsReceivedTable=jnxBgpM2PeerCapsReceivedTable, jnxBgpM2PeerCapsReceivedEntry=jnxBgpM2PeerCapsReceivedEntry, jnxBgpM2PeerCapReceivedCode=jnxBgpM2PeerCapReceivedCode, jnxBgpM2PeerCapReceivedIndex=jnxBgpM2PeerCapReceivedIndex, jnxBgpM2PeerCapReceivedValue=jnxBgpM2PeerCapReceivedValue, jnxBgpM2PeerCounters=jnxBgpM2PeerCounters, jnxBgpM2PeerCountersTable=jnxBgpM2PeerCountersTable, jnxBgpM2PeerCountersEntry=jnxBgpM2PeerCountersEntry, jnxBgpM2PeerInUpdates=jnxBgpM2PeerInUpdates, jnxBgpM2PeerOutUpdates=jnxBgpM2PeerOutUpdates, jnxBgpM2PeerInTotalMessages=jnxBgpM2PeerInTotalMessages, jnxBgpM2PeerOutTotalMessages=jnxBgpM2PeerOutTotalMessages, jnxBgpM2PeerFsmEstablishedTrans=jnxBgpM2PeerFsmEstablishedTrans, jnxBgpM2PrefixCountersTable=jnxBgpM2PrefixCountersTable, jnxBgpM2PrefixCountersEntry=jnxBgpM2PrefixCountersEntry, jnxBgpM2PrefixCountersAfi=jnxBgpM2PrefixCountersAfi, jnxBgpM2PrefixCountersSafi=jnxBgpM2PrefixCountersSafi, jnxBgpM2PrefixInPrefixes=jnxBgpM2PrefixInPrefixes, jnxBgpM2PrefixInPrefixesAccepted=jnxBgpM2PrefixInPrefixesAccepted, jnxBgpM2PrefixInPrefixesRejected=jnxBgpM2PrefixInPrefixesRejected, jnxBgpM2PrefixOutPrefixes=jnxBgpM2PrefixOutPrefixes)
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", jnxBgpM2PrefixInPrefixesActive=jnxBgpM2PrefixInPrefixesActive, jnxBgpM2PeerExtensions=jnxBgpM2PeerExtensions, jnxBgpM2PeerNonCapExts=jnxBgpM2PeerNonCapExts, jnxBgpM2PeerRouteReflectionExts=jnxBgpM2PeerRouteReflectionExts, jnxBgpM2PeerReflectorClientTable=jnxBgpM2PeerReflectorClientTable, jnxBgpM2PeerReflectorClientEntry=jnxBgpM2PeerReflectorClientEntry, jnxBgpM2PeerReflectorClient=jnxBgpM2PeerReflectorClient, jnxBgpM2PeerASConfederationExts=jnxBgpM2PeerASConfederationExts, jnxBgpM2PeerConfedMemberTable=jnxBgpM2PeerConfedMemberTable, jnxBgpM2PeerConfedMemberEntry=jnxBgpM2PeerConfedMemberEntry, jnxBgpM2PeerConfedMember=jnxBgpM2PeerConfedMember, jnxBgpM2PeerCapExts=jnxBgpM2PeerCapExts, jnxBgpM2PeerConfiguration=jnxBgpM2PeerConfiguration, jnxBgpM2CfgPeerAdminStatusTable=jnxBgpM2CfgPeerAdminStatusTable, jnxBgpM2CfgPeerAdminStatusEntry=jnxBgpM2CfgPeerAdminStatusEntry, jnxBgpM2CfgPeerAdminStatus=jnxBgpM2CfgPeerAdminStatus, jnxBgpM2CfgPeerNextIndex=jnxBgpM2CfgPeerNextIndex, jnxBgpM2CfgPeerTable=jnxBgpM2CfgPeerTable, jnxBgpM2CfgPeerEntry=jnxBgpM2CfgPeerEntry, jnxBgpM2CfgPeerConfiguredVersion=jnxBgpM2CfgPeerConfiguredVersion, jnxBgpM2CfgAllowVersionNegotiation=jnxBgpM2CfgAllowVersionNegotiation, jnxBgpM2CfgPeerLocalAddrType=jnxBgpM2CfgPeerLocalAddrType, jnxBgpM2CfgPeerLocalAddr=jnxBgpM2CfgPeerLocalAddr, jnxBgpM2CfgPeerLocalAs=jnxBgpM2CfgPeerLocalAs, jnxBgpM2CfgPeerRemoteAddrType=jnxBgpM2CfgPeerRemoteAddrType, jnxBgpM2CfgPeerRemoteAddr=jnxBgpM2CfgPeerRemoteAddr, jnxBgpM2CfgPeerRemotePort=jnxBgpM2CfgPeerRemotePort, jnxBgpM2CfgPeerRemoteAs=jnxBgpM2CfgPeerRemoteAs, jnxBgpM2CfgPeerEntryStorageType=jnxBgpM2CfgPeerEntryStorageType, jnxBgpM2CfgPeerError=jnxBgpM2CfgPeerError, jnxBgpM2CfgPeerBgpPeerEntry=jnxBgpM2CfgPeerBgpPeerEntry, jnxBgpM2CfgPeerRowEntryStatus=jnxBgpM2CfgPeerRowEntryStatus, jnxBgpM2CfgPeerIndex=jnxBgpM2CfgPeerIndex, jnxBgpM2CfgPeerStatus=jnxBgpM2CfgPeerStatus, jnxBgpM2CfgPeerRoutingInstance=jnxBgpM2CfgPeerRoutingInstance, jnxBgpM2CfgPeerAuthTable=jnxBgpM2CfgPeerAuthTable, jnxBgpM2CfgPeerAuthEntry=jnxBgpM2CfgPeerAuthEntry, jnxBgpM2CfgPeerAuthEnabled=jnxBgpM2CfgPeerAuthEnabled, jnxBgpM2CfgPeerAuthCode=jnxBgpM2CfgPeerAuthCode, jnxBgpM2CfgPeerAuthValue=jnxBgpM2CfgPeerAuthValue, jnxBgpM2CfgPeerTimersTable=jnxBgpM2CfgPeerTimersTable, jnxBgpM2CfgPeerTimersEntry=jnxBgpM2CfgPeerTimersEntry, jnxBgpM2CfgPeerConnectRetryInterval=jnxBgpM2CfgPeerConnectRetryInterval, jnxBgpM2CfgPeerHoldTimeConfigured=jnxBgpM2CfgPeerHoldTimeConfigured, jnxBgpM2CfgPeerKeepAliveConfigured=jnxBgpM2CfgPeerKeepAliveConfigured, jnxBgpM2CfgPeerMinASOrigInterval=jnxBgpM2CfgPeerMinASOrigInterval, jnxBgpM2CfgPeerMinRouteAdverInter=jnxBgpM2CfgPeerMinRouteAdverInter, jnxBgpM2CfgPeerExtensions=jnxBgpM2CfgPeerExtensions, jnxBgpM2CfgPeerNonCapExts=jnxBgpM2CfgPeerNonCapExts, jnxBgpM2CfgPeerRouteReflectionExts=jnxBgpM2CfgPeerRouteReflectionExts, jnxBgpM2CfgPeerReflectorClientTable=jnxBgpM2CfgPeerReflectorClientTable, jnxBgpM2CfgPeerReflectorClientEntry=jnxBgpM2CfgPeerReflectorClientEntry, jnxBgpM2CfgPeerReflectorClient=jnxBgpM2CfgPeerReflectorClient, jnxBgpM2CfgPeerASConfederationExts=jnxBgpM2CfgPeerASConfederationExts, jnxBgpM2CfgPeerConfedMemberTable=jnxBgpM2CfgPeerConfedMemberTable, jnxBgpM2CfgPeerConfedMemberEntry=jnxBgpM2CfgPeerConfedMemberEntry, jnxBgpM2CfgPeerConfedMember=jnxBgpM2CfgPeerConfedMember, jnxBgpM2CfgPeerCapExts=jnxBgpM2CfgPeerCapExts, jnxBgpM2Rib=jnxBgpM2Rib, jnxBgpM2NlriTable=jnxBgpM2NlriTable, jnxBgpM2NlriEntry=jnxBgpM2NlriEntry, jnxBgpM2NlriIndex=jnxBgpM2NlriIndex, jnxBgpM2NlriAfi=jnxBgpM2NlriAfi, jnxBgpM2NlriSafi=jnxBgpM2NlriSafi, jnxBgpM2NlriPrefix=jnxBgpM2NlriPrefix, jnxBgpM2NlriPrefixLen=jnxBgpM2NlriPrefixLen, jnxBgpM2NlriBest=jnxBgpM2NlriBest, jnxBgpM2NlriCalcLocalPref=jnxBgpM2NlriCalcLocalPref, jnxBgpM2PathAttrIndex=jnxBgpM2PathAttrIndex, jnxBgpM2NlriOpaqueType=jnxBgpM2NlriOpaqueType, jnxBgpM2NlriOpaquePointer=jnxBgpM2NlriOpaquePointer, jnxBgpM2AdjRibsOutTable=jnxBgpM2AdjRibsOutTable, jnxBgpM2AdjRibsOutEntry=jnxBgpM2AdjRibsOutEntry, jnxBgpM2AdjRibsOutIndex=jnxBgpM2AdjRibsOutIndex, jnxBgpM2AdjRibsOutRoute=jnxBgpM2AdjRibsOutRoute, jnxBgpM2PathAttrCount=jnxBgpM2PathAttrCount, jnxBgpM2PathAttrTable=jnxBgpM2PathAttrTable, jnxBgpM2PathAttrEntry=jnxBgpM2PathAttrEntry, jnxBgpM2PathAttrOrigin=jnxBgpM2PathAttrOrigin, jnxBgpM2PathAttrNextHopAddrType=jnxBgpM2PathAttrNextHopAddrType, jnxBgpM2PathAttrNextHop=jnxBgpM2PathAttrNextHop, jnxBgpM2PathAttrMedPresent=jnxBgpM2PathAttrMedPresent, jnxBgpM2PathAttrMed=jnxBgpM2PathAttrMed, jnxBgpM2PathAttrLocalPrefPresent=jnxBgpM2PathAttrLocalPrefPresent, jnxBgpM2PathAttrLocalPref=jnxBgpM2PathAttrLocalPref, jnxBgpM2PathAttrAtomicAggregate=jnxBgpM2PathAttrAtomicAggregate, jnxBgpM2PathAttrAggregatorAS=jnxBgpM2PathAttrAggregatorAS, jnxBgpM2PathAttrAggregatorAddr=jnxBgpM2PathAttrAggregatorAddr, jnxBgpM2AsPathCalcLength=jnxBgpM2AsPathCalcLength, jnxBgpM2AsPathString=jnxBgpM2AsPathString, jnxBgpM2AsPathIndex=jnxBgpM2AsPathIndex, jnxBgpM2AsPath4byteTable=jnxBgpM2AsPath4byteTable, jnxBgpM2AsPath4byteEntry=jnxBgpM2AsPath4byteEntry, jnxBgpM2AsPath4bytePathPresent=jnxBgpM2AsPath4bytePathPresent, jnxBgpM2AsPath4byteAggregatorAS=jnxBgpM2AsPath4byteAggregatorAS, jnxBgpM2AsPath4byteCalcLength=jnxBgpM2AsPath4byteCalcLength, jnxBgpM2AsPath4byteString=jnxBgpM2AsPath4byteString, jnxBgpM2AsPath4byteIndex=jnxBgpM2AsPath4byteIndex, jnxBgpM2AsPathTable=jnxBgpM2AsPathTable, jnxBgpM2AsPathEntry=jnxBgpM2AsPathEntry, jnxBgpM2AsPathSegmentIndex=jnxBgpM2AsPathSegmentIndex, jnxBgpM2AsPathElementIndex=jnxBgpM2AsPathElementIndex, jnxBgpM2AsPathType=jnxBgpM2AsPathType, jnxBgpM2AsPathElementValue=jnxBgpM2AsPathElementValue, jnxBgpM2PathAttrUnknownTable=jnxBgpM2PathAttrUnknownTable, jnxBgpM2PathAttrUnknownEntry=jnxBgpM2PathAttrUnknownEntry, jnxBgpM2PathAttrUnknownIndex=jnxBgpM2PathAttrUnknownIndex, jnxBgpM2PathAttrUnknownType=jnxBgpM2PathAttrUnknownType, jnxBgpM2PathAttrUnknownValue=jnxBgpM2PathAttrUnknownValue, jnxBgpM2PathAttrExtensions=jnxBgpM2PathAttrExtensions, jnxBgpM2PathAttrNonCapExts=jnxBgpM2PathAttrNonCapExts, jnxBgpM2PathAttrCommunityExts=jnxBgpM2PathAttrCommunityExts, jnxBgpM2PathAttrCommTable=jnxBgpM2PathAttrCommTable, jnxBgpM2PathAttrCommEntry=jnxBgpM2PathAttrCommEntry, jnxBgpM2PathAttrCommIndex=jnxBgpM2PathAttrCommIndex, jnxBgpM2PathAttrCommValue=jnxBgpM2PathAttrCommValue, jnxBgpM2LinkLocalNextHopTable=jnxBgpM2LinkLocalNextHopTable, jnxBgpM2LinkLocalNextHopEntry=jnxBgpM2LinkLocalNextHopEntry, jnxBgpM2LinkLocalNextHopPresent=jnxBgpM2LinkLocalNextHopPresent, jnxBgpM2LinkLocalNextHop=jnxBgpM2LinkLocalNextHop, jnxBgpM2PathAttrRouteReflectionExts=jnxBgpM2PathAttrRouteReflectionExts, jnxBgpM2PathAttrOriginatorIdTable=jnxBgpM2PathAttrOriginatorIdTable, jnxBgpM2PathAttrOriginatorIdEntry=jnxBgpM2PathAttrOriginatorIdEntry, jnxBgpM2PathAttrOriginatorId=jnxBgpM2PathAttrOriginatorId, jnxBgpM2PathAttrClusterTable=jnxBgpM2PathAttrClusterTable, jnxBgpM2PathAttrClusterEntry=jnxBgpM2PathAttrClusterEntry, jnxBgpM2PathAttrClusterIndex=jnxBgpM2PathAttrClusterIndex)
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", jnxBgpM2PathAttrClusterValue=jnxBgpM2PathAttrClusterValue, jnxBgpM2PathAttrExtCommTable=jnxBgpM2PathAttrExtCommTable, jnxBgpM2PathAttrExtCommEntry=jnxBgpM2PathAttrExtCommEntry, jnxBgpM2PathAttrExtCommIndex=jnxBgpM2PathAttrExtCommIndex, jnxBgpM2PathAttrExtCommValue=jnxBgpM2PathAttrExtCommValue, jnxBgpM2PathAttrCapExts=jnxBgpM2PathAttrCapExts, jnxBgpM2Conformance=jnxBgpM2Conformance, jnxBgpM2MIBCompliances=jnxBgpM2MIBCompliances, jnxBgpM2MIBGroups=jnxBgpM2MIBGroups)

# Notifications
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", jnxBgpM2Established=jnxBgpM2Established, jnxBgpM2BackwardTransition=jnxBgpM2BackwardTransition)

# Groups
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", jnxBgpM2AuthenticationGroup=jnxBgpM2AuthenticationGroup, jnxBgpM2CommunitiesGroup=jnxBgpM2CommunitiesGroup, jnxBgpM2ExtCommunitiesGroup=jnxBgpM2ExtCommunitiesGroup, jnxBgpM2RouteReflectionGroup=jnxBgpM2RouteReflectionGroup, jnxBgpM2AsConfederationGroup=jnxBgpM2AsConfederationGroup, jnxBgpM2TimersGroup=jnxBgpM2TimersGroup, jnxBgpM2CountersGroup=jnxBgpM2CountersGroup, jnxBgpM2CapabilitiesGroup=jnxBgpM2CapabilitiesGroup, jnxBgpM2AsPathGroup=jnxBgpM2AsPathGroup, jnxBgpM2As4byteGroup=jnxBgpM2As4byteGroup, jnxBgpM2BaseGroup=jnxBgpM2BaseGroup, jnxBgpM2ErrorsGroup=jnxBgpM2ErrorsGroup, jnxBgpM2PeerGroup=jnxBgpM2PeerGroup, jnxBgpM2PathAttributesGroup=jnxBgpM2PathAttributesGroup, jnxBgpM2PeerConfigurationGroup=jnxBgpM2PeerConfigurationGroup, jnxBgpM2PeerAuthConfigurationGroup=jnxBgpM2PeerAuthConfigurationGroup, jnxBgpM2PeerRouteReflectorCfgGroup=jnxBgpM2PeerRouteReflectorCfgGroup, jnxBgpM2PeerAsConfederationCfgGroup=jnxBgpM2PeerAsConfederationCfgGroup, jnxBgpM2MIBNotificationsGroup=jnxBgpM2MIBNotificationsGroup, jnxBgpM2Rfc2545Group=jnxBgpM2Rfc2545Group)

# Compliances
mibBuilder.exportSymbols("BGP4-V2-MIB-JUNIPER", jnxBgpM2MIBCompliance=jnxBgpM2MIBCompliance)
