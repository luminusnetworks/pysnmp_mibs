# PySNMP SMI module. Autogenerated from smidump -f python NETSCREEN-VR-OSPF-MIB
# by libsmi2pysnmp-0.1.3 at Fri May 30 14:12:57 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( netscreenVR, ) = mibBuilder.importSymbols("NETSCREEN-SMI", "netscreenVR")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "mib-2")
( RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue")

# Types

class BigMetric(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,16777215)
    
class DesignatedRouterPriority(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,255)
    
class HelloRange(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,65535)
    
class InterfaceIndex(Integer32):
    pass

class Metric(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,65535)
    
class PositiveInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,2147483647)
    
class Status(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("enabled", 1), ("disabled", 2), )
    
class TOSType(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,30)
    
class UpToMaxAge(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,3600)
    
class AreaID(IpAddress):
    pass

class RouterID(IpAddress):
    pass


# Objects

nsVrOspf = ModuleIdentity((1, 3, 6, 1, 4, 1, 3224, 18, 5)).setRevisions(("2005-06-20 20:22",))
if mibBuilder.loadTexts: nsVrOspf.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: nsVrOspf.setContactInfo("Customer Support\n\n1194 North Mathilda Avenue \nSunnyvale, California 94089-1206\nUSA\n\nTel: 1-800-638-8296\nE-mail: customerservice@juniper.net\nHTTP://www.juniper.net")
if mibBuilder.loadTexts: nsVrOspf.setDescription("The MIB module to describe the NS-OSPF Version 2\nProtocol")
nsVrOspfGeneralTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1))
if mibBuilder.loadTexts: nsVrOspfGeneralTable.setDescription("Ospf general information table per VR")
nsVrOspfGeneralEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfGeneralVRID"))
if mibBuilder.loadTexts: nsVrOspfGeneralEntry.setDescription("Ospf general information table per VR")
nsVrOspfRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 1), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfRouterId.setDescription("A  32-bit  integer  uniquely  identifying  the\nrouter in the Autonomous System.\n\nBy  convention,  to  ensure  uniqueness,   this\nshould  default  to  the  value  of  one of the\nrouter's IP interface addresses.")
nsVrOspfAdminStat = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 2), Status()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAdminStat.setDescription("The  administrative  status  of  OSPF  in  the\nrouter.   The  value 'enabled' denotes that the\nOSPF Process is active on at least  one  inter-\nface;  'disabled'  disables  it  on  all inter-\nfaces.")
nsVrOspfVersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,)).subtype(namedValues=NamedValues(("version2", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVersionNumber.setDescription("The current version number of the OSPF  proto-\ncol is 2.")
nsVrOspfAreaBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaBdrRtrStatus.setDescription("A flag to note whether this router is an  area\nborder router.")
nsVrOspfASBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfASBdrRtrStatus.setDescription("A flag to note whether this router is  config-\nured as an Autonomous System border router.")
nsVrOspfExternLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExternLsaCount.setDescription("The number of external (LS type 5)  link-state\nadvertisements in the link-state database.")
nsVrOspfExternLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExternLsaCksumSum.setDescription("The 32-bit unsigned sum of the LS checksums of\nthe  external  link-state  advertisements  con-\ntained in the link-state  database.   This  sum\ncan  be  used  to determine if there has been a\nchange in a router's link state  database,  and\nto  compare  the  link-state  database  of  two\nrouters.")
nsVrOspfTOSSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfTOSSupport.setDescription("The router's support for type-of-service rout-\ning.")
nsVrOspfOriginateNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfOriginateNewLsas.setDescription("The number of  new  link-state  advertisements\nthat  have been originated.  This number is in-\ncremented each time the router originates a new\nLSA.")
nsVrOspfRxNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfRxNewLsas.setDescription("The number of  link-state  advertisements  re-\nceived  determined  to  be  new instantiations.\nThis number does not include  newer  instantia-\ntions  of self-originated link-state advertise-\nments.")
nsVrOspfExtLsdbLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbLimit.setDescription("The  maximum   number   of   non-default   AS-\nexternal-LSAs entries that can be stored in the\nlink-state database.  If the value is -1,  then\nthere is no limit.\n\nWhen the number of non-default AS-external-LSAs\nin   a  router's  link-state  database  reaches\nnsVrOspfExtLsdbLimit, the router  enters  Overflow-\nState.   The   router  never  holds  more  than\nnsVrOspfExtLsdbLimit  non-default  AS-external-LSAs\nin  its  database.  OspfExtLsdbLimit MUST be set\nidentically in all routers attached to the OSPF\nbackbone  and/or  any regular OSPF area. (i.e.,\nOSPF stub areas and NSSAs are excluded).")
nsVrOspfMulticastExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 12), Integer32().clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfMulticastExtensions.setDescription("A Bit Mask indicating whether  the  router  is\nforwarding  IP  multicast  (Class  D) datagrams\nbased on the algorithms defined in  the  Multi-\ncast Extensions to OSPF.\n\nBit 0, if set, indicates that  the  router  can\nforward  IP multicast datagrams in the router's\ndirectly attached areas (called intra-area mul-\nticast routing).\n\nBit 1, if set, indicates that  the  router  can\nforward  IP  multicast  datagrams  between OSPF\nareas (called inter-area multicast routing).\n\nBit 2, if set, indicates that  the  router  can\nforward  IP  multicast  datagrams between Auto-\nnomous Systems (called inter-AS multicast rout-\ning).\n\nOnly certain combinations of bit  settings  are\nallowed,  namely: 0 (no multicast forwarding is\n\nenabled), 1 (intra-area multicasting  only),  3\n(intra-area  and  inter-area  multicasting),  5\n(intra-area and inter-AS  multicasting)  and  7\n(multicasting  everywhere). By default, no mul-\nticast forwarding is enabled.")
nsVrOspfExitOverflowInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 13), PositiveInteger().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExitOverflowInterval.setDescription("The number of  seconds  that,  after  entering\nOverflowState,  a  router will attempt to leave\nOverflowState. This allows the router to  again\noriginate  non-default  AS-external-LSAs.  When\nset to 0, the router will not  leave  Overflow-\nState until restarted.")
nsVrOspfDemandExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfDemandExtensions.setDescription("The router's support for demand routing.")
nsVrOspfGeneralVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfGeneralVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfAreaTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2))
if mibBuilder.loadTexts: nsVrOspfAreaTable.setDescription("Information describing the configured  parame-\nters  and cumulative statistics of the router's\nattached areas.")
nsVrOspfAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaId"))
if mibBuilder.loadTexts: nsVrOspfAreaEntry.setDescription("Information describing the configured  parame-\nters  and  cumulative  statistics of one of the\nrouter's attached areas.")
nsVrOspfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 1), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaId.setDescription("A 32-bit integer uniquely identifying an area.\nArea ID 0.0.0.0 is used for the OSPF backbone.")
nsVrOspfImportAsExtern = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("importExternal", 1), ("importNoExternal", 2), ("importNssa", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfImportAsExtern.setDescription("The area's support for importing  AS  external\nlink- state advertisements.")
nsVrOspfSpfRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfSpfRuns.setDescription("The number of times that the intra-area  route\ntable  has  been  calculated  using this area's\nlink-state database.  This  is  typically  done\nusing Dijkstra's algorithm.")
nsVrOspfAreaBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaBdrRtrCount.setDescription("The total number of area border routers reach-\nable within this area.  This is initially zero,\nand is calculated in each SPF Pass.")
nsVrOspfAsBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAsBdrRtrCount.setDescription("The total number of Autonomous  System  border\nrouters  reachable  within  this area.  This is\ninitially zero, and is calculated in  each  SPF\nPass.")
nsVrOspfAreaLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaLsaCount.setDescription("The total number of link-state  advertisements\nin  this  area's link-state database, excluding\nAS External LSA's.")
nsVrOspfAreaLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 8), Integer32().clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaLsaCksumSum.setDescription("The 32-bit unsigned sum of the link-state  ad-\nvertisements'  LS  checksums  contained in this\narea's link-state database.  This sum  excludes\nexternal (LS type 5) link-state advertisements.\nThe sum can be used to determine if  there  has\nbeen  a  change  in a router's link state data-\nbase, and to compare the link-state database of\n\ntwo routers.")
nsVrOspfAreaSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("noAreaSummary", 1), ("sendAreaSummary", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfAreaSummary.setDescription("The variable nsVrOspfAreaSummary controls the  im-\nport  of  summary LSAs into stub areas.  It has\nno effect on other areas.\n\nIf it is noAreaSummary, the router will neither\noriginate  nor  propagate summary LSAs into the\nstub area.  It will rely entirely  on  its  de-\nfault route.\n\nIf it is sendAreaSummary, the router will  both\nsummarize and propagate summary LSAs.")
nsVrOspfAreaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfAreaStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfAreaVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfStubAreaTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3))
if mibBuilder.loadTexts: nsVrOspfStubAreaTable.setDescription("The set of metrics that will be advertised  by\na default Area Border Router into a stub area.")
nsVrOspfStubAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfStubVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfStubAreaId"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfStubTOS"))
if mibBuilder.loadTexts: nsVrOspfStubAreaEntry.setDescription("The metric for a given Type  of  Service  that\nwill  be  advertised  by  a default Area Border\nRouter into a stub area.")
nsVrOspfStubAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1, 1), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfStubAreaId.setDescription("The 32 bit identifier for the Stub  Area.   On\ncreation,  this  can  be  derived  from the in-\nstance.")
nsVrOspfStubTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1, 2), TOSType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfStubTOS.setDescription("The  Type  of  Service  associated  with   the\nmetric.   On creation, this can be derived from\nthe instance.")
nsVrOspfStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1, 3), BigMetric()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfStubMetric.setDescription("The metric value applied at the indicated type\nof  service.  By default, this equals the least\nmetric at the type of service among the  inter-\nfaces to other areas.")
nsVrOspfStubStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfStubStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfStubMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("nsVrOspfMetric", 1), ("comparableCost", 2), ("nonComparable", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfStubMetricType.setDescription("This variable displays the type of metric  ad-\nvertised as a default route.")
nsVrOspfStubVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfStubVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4))
if mibBuilder.loadTexts: nsVrOspfLsdbTable.setDescription("The OSPF Process's Link State Database.")
nsVrOspfLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfLsdbVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfLsdbAreaId"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfLsdbType"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfLsdbLsid"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfLsdbRouterId"))
if mibBuilder.loadTexts: nsVrOspfLsdbEntry.setDescription("A single Link State Advertisement.")
nsVrOspfLsdbAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 1), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbAreaId.setDescription("The 32 bit identifier of the Area  from  which\nthe LSA was received.")
nsVrOspfLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,4,5,2,7,6,)).subtype(namedValues=NamedValues(("routerLink", 1), ("networkLink", 2), ("summaryLink", 3), ("asSummaryLink", 4), ("asExternalLink", 5), ("multicastLink", 6), ("nssaExternalLink", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbType.setDescription("The type  of  the  link  state  advertisement.\nEach  link state type has a separate advertise-\nment format.")
nsVrOspfLsdbLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbLsid.setDescription("The Link State ID is an LS Type Specific field\ncontaining either a Router ID or an IP Address;\nit identifies the piece of the  routing  domain\nthat is being described by the advertisement.")
nsVrOspfLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 4), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbRouterId.setDescription("The 32 bit number that uniquely identifies the\noriginating router in the Autonomous System.")
nsVrOspfLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbSequence.setDescription("The sequence number field is a  signed  32-bit\ninteger.   It  is used to detect old and dupli-\ncate link state advertisements.  The  space  of\nsequence  numbers  is  linearly  ordered.   The\nlarger the sequence number the more recent  the\nadvertisement.")
nsVrOspfLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbAge.setDescription("This field is the age of the link state adver-\ntisement in seconds.")
nsVrOspfLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbChecksum.setDescription("This field is the  checksum  of  the  complete\ncontents  of  the  advertisement, excepting the\nage field.  The age field is excepted  so  that\nan   advertisement's  age  can  be  incremented\nwithout updating the  checksum.   The  checksum\nused  is  the same that is used for ISO connec-\ntionless datagrams; it is commonly referred  to\nas the Fletcher checksum.")
nsVrOspfLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbAdvertisement.setDescription("The entire Link State Advertisement, including\nits header.")
nsVrOspfLsdbVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfLsdbVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfHostTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6))
if mibBuilder.loadTexts: nsVrOspfHostTable.setDescription("The list of Hosts, and their metrics, that the\nrouter will advertise as host routes.")
nsVrOspfHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfHostVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfHostIpAddress"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfHostTOS"))
if mibBuilder.loadTexts: nsVrOspfHostEntry.setDescription("A metric to be advertised, for a given type of\nservice, when a given host is reachable.")
nsVrOspfHostIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfHostIpAddress.setDescription("The IP Address of the Host.")
nsVrOspfHostTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1, 2), TOSType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfHostTOS.setDescription("The Type of Service of the route being config-\nured.")
nsVrOspfHostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1, 3), Metric()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfHostMetric.setDescription("The Metric to be advertised.")
nsVrOspfHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfHostStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfHostAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1, 5), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfHostAreaID.setDescription("The Area the Host Entry is to be found within.\nBy  default, the area that a subsuming OSPF in-\nterface is in, or 0.0.0.0")
nsVrOspfHostVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfHostVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfIfTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7))
if mibBuilder.loadTexts: nsVrOspfIfTable.setDescription("The OSPF Interface Table describes the  inter-\nfaces from the viewpoint of OSPF.")
nsVrOspfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfIpAddress"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAddressLessIf"))
if mibBuilder.loadTexts: nsVrOspfIfEntry.setDescription("The OSPF Interface Entry describes one  inter-\nface from the viewpoint of OSPF.")
nsVrOspfIfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfIpAddress.setDescription("The IP address of this OSPF interface.")
nsVrOspfAddressLessIf = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAddressLessIf.setDescription("For the purpose of easing  the  instancing  of\naddressed   and  addressless  interfaces;  This\nvariable takes the value 0 on  interfaces  with\nIP  Addresses,  and  the corresponding value of\nifIndex for interfaces having no IP Address.")
nsVrOspfIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 3), AreaID().clone(hexValue='00000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfAreaId.setDescription("A 32-bit integer uniquely identifying the area\nto  which  the  interface  connects.   Area  ID\n0.0.0.0 is used for the OSPF backbone.")
nsVrOspfIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,5,3,)).subtype(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3), ("pointToMultipoint", 5), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfType.setDescription("The OSPF interface type.\n\nBy way of a default, this field may be intuited\nfrom the corresponding value of ifType.  Broad-\ncast LANs, such as  Ethernet  and  IEEE  802.5,\ntake  the  value  'broadcast', X.25 and similar\ntechnologies take the value 'nbma',  and  links\nthat  are  definitively point to point take the\nvalue 'pointToPoint'.")
nsVrOspfIfAdminStat = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 5), Status().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfAdminStat.setDescription("The OSPF  interface's  administrative  status.\nThe  value formed on the interface, and the in-\nterface will be advertised as an internal route\nto  some  area.   The  value 'disabled' denotes\nthat the interface is external to OSPF.")
nsVrOspfIfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 6), DesignatedRouterPriority().clone('1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfRtrPriority.setDescription("The  priority  of  this  interface.   Used  in\nmulti-access  networks,  this  field is used in\nthe designated router election algorithm.   The\nvalue 0 signifies that the router is not eligi-\nble to become the  designated  router  on  this\nparticular  network.   In the event of a tie in\nthis value, routers will use their Router ID as\na tie breaker.")
nsVrOspfIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 7), UpToMaxAge().clone('1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfTransitDelay.setDescription("The estimated number of seconds  it  takes  to\ntransmit  a  link state update packet over this\ninterface.")
nsVrOspfIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 8), UpToMaxAge().clone('5')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfRetransInterval.setDescription("The number of seconds between  link-state  ad-\nvertisement  retransmissions,  for  adjacencies\nbelonging to this  interface.   This  value  is\nalso used when retransmitting database descrip-\ntion and link-state request packets.")
nsVrOspfIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 9), HelloRange().clone('10')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfHelloInterval.setDescription("The length of time, in  seconds,  between  the\nHello  packets that the router sends on the in-\n\nterface.  This value must be the same  for  all\nrouters attached to a common network.")
nsVrOspfIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 10), PositiveInteger().clone('40')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfRtrDeadInterval.setDescription("The number of seconds that  a  router's  Hello\npackets  have  not been seen before it's neigh-\nbors declare the router down.  This  should  be\nsome  multiple  of  the  Hello  interval.  This\nvalue must be the same for all routers attached\nto a common network.")
nsVrOspfIfPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 11), PositiveInteger().clone('120')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfPollInterval.setDescription("The larger time interval, in seconds,  between\nthe  Hello  packets  sent  to  an inactive non-\nbroadcast multi- access neighbor.")
nsVrOspfIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,3,6,7,2,4,)).subtype(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointToPoint", 4), ("designatedRouter", 5), ("backupDesignatedRouter", 6), ("otherDesignatedRouter", 7), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfState.setDescription("The OSPF Interface State.")
nsVrOspfIfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 13), IpAddress().clone("0.0.0.0")).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfDesignatedRouter.setDescription("The IP Address of the Designated Router.")
nsVrOspfIfBackupDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 14), IpAddress().clone("0.0.0.0")).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfBackupDesignatedRouter.setDescription("The  IP  Address  of  the  Backup   Designated\nRouter.")
nsVrOspfIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfEvents.setDescription("The number of times this  OSPF  interface  has\nchanged its state, or an error has occurred.")
nsVrOspfIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue='0000000000000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfAuthKey.setDescription("The Authentication Key.  If the Area's Author-\nization  Type  is  simplePassword,  and the key\nlength is shorter than 8 octets, the agent will\nleft adjust and zero fill to 8 octets.\n\nNote that unauthenticated  interfaces  need  no\nauthentication key, and simple password authen-\ntication cannot use a key of more  than  8  oc-\ntets.  Larger keys are useful only with authen-\ntication mechanisms not specified in this docu-\n\nment.\n\nWhen read, nsVrOspfIfAuthKey always returns an  Oc-\ntet String of length zero.")
nsVrOspfIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfIfMulticastForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 18), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("blocked", 1), ("multicast", 2), ("unicast", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfMulticastForwarding.setDescription("The way multicasts should  forwarded  on  this\ninterface;  not  forwarded,  forwarded  as data\nlink multicasts, or forwarded as data link uni-\ncasts.   Data link multicasting is not meaning-\nful on point to point and NBMA interfaces,  and\nsetting nsVrOspfMulticastForwarding to 0 effective-\nly disables all multicast forwarding.")
nsVrOspfIfDemand = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfDemand.setDescription("Indicates whether Demand OSPF procedures (hel-\n\nlo supression to FULL neighbors and setting the\nDoNotAge flag on proogated LSAs) should be per-\nformed on this interface.")
nsVrOspfIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfAuthType.setDescription("The authentication type specified for  an  in-\nterface.   Additional  authentication types may\nbe assigned locally.")
nsVrOspfIfVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 7, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfIfMetricTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8))
if mibBuilder.loadTexts: nsVrOspfIfMetricTable.setDescription("The TOS metrics for  a  non-virtual  interface\nidentified by the interface index.")
nsVrOspfIfMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfMetricVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfMetricIpAddress"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfMetricAddressLessIf"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfMetricTOS"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfIfMetricVRID"))
if mibBuilder.loadTexts: nsVrOspfIfMetricEntry.setDescription("A particular TOS metric for a non-virtual  in-\nterface identified by the interface index.")
nsVrOspfIfMetricIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfMetricIpAddress.setDescription("The IP address of this OSPF interface.  On row\ncreation,  this  can  be  derived  from the in-\nstance.")
nsVrOspfIfMetricAddressLessIf = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfMetricAddressLessIf.setDescription("For the purpose of easing  the  instancing  of\naddressed   and  addressless  interfaces;  This\nvariable takes the value 0 on  interfaces  with\nIP  Addresses, and the value of ifIndex for in-\nterfaces having no IP Address.   On  row  crea-\ntion, this can be derived from the instance.")
nsVrOspfIfMetricTOS = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1, 3), TOSType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfMetricTOS.setDescription("The type of service metric  being  referenced.\nOn  row  creation, this can be derived from the\ninstance.")
nsVrOspfIfMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1, 4), Metric()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfMetricValue.setDescription("The metric of using this type  of  service  on\nthis interface.  The default value of the TOS 0\nMetric is 10^8 / ifSpeed.")
nsVrOspfIfMetricStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfIfMetricStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfIfMetricVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfIfMetricVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfVirtIfTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9))
if mibBuilder.loadTexts: nsVrOspfVirtIfTable.setDescription("Information about this router's virtual inter-\nfaces.")
nsVrOspfVirtIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfVirtIfVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfVirtIfAreaId"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfVirtIfNeighbor"))
if mibBuilder.loadTexts: nsVrOspfVirtIfEntry.setDescription("Information about a single Virtual Interface.")
nsVrOspfVirtIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 1), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtIfAreaId.setDescription("The  Transit  Area  that  the   Virtual   Link\ntraverses.  By definition, this is not 0.0.0.0")
nsVrOspfVirtIfNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 2), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtIfNeighbor.setDescription("The Router ID of the Virtual Neighbor.")
nsVrOspfVirtIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 3), UpToMaxAge().clone('1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfTransitDelay.setDescription("The estimated number of seconds  it  takes  to\ntransmit  a link- state update packet over this\ninterface.")
nsVrOspfVirtIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 4), UpToMaxAge().clone('5')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfRetransInterval.setDescription("The number of seconds between  link-state  ad-\nvertisement  retransmissions,  for  adjacencies\nbelonging to this  interface.   This  value  is\nalso used when retransmitting database descrip-\ntion  and  link-state  request  packets.   This\nvalue  should  be well over the expected round-\ntrip time.")
nsVrOspfVirtIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 5), HelloRange().clone('10')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfHelloInterval.setDescription("The length of time, in  seconds,  between  the\nHello  packets that the router sends on the in-\nterface.  This value must be the same  for  the\nvirtual neighbor.")
nsVrOspfVirtIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 6), PositiveInteger().clone('60')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfRtrDeadInterval.setDescription("The number of seconds that  a  router's  Hello\npackets  have  not been seen before it's neigh-\nbors declare the router down.  This  should  be\nsome  multiple  of  the  Hello  interval.  This\nvalue must be the same for the  virtual  neigh-\nbor.")
nsVrOspfVirtIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,4,)).subtype(namedValues=NamedValues(("down", 1), ("pointToPoint", 4), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtIfState.setDescription("OSPF virtual interface states.")
nsVrOspfVirtIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtIfEvents.setDescription("The number of state changes or error events on\nthis Virtual Link")
nsVrOspfVirtIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256)).clone(hexValue='0000000000000000')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfAuthKey.setDescription("If Authentication Type is simplePassword,  the\ndevice  will left adjust and zero fill to 8 oc-\ntets.\n\nNote that unauthenticated  interfaces  need  no\nauthentication key, and simple password authen-\ntication cannot use a key of more  than  8  oc-\ntets.  Larger keys are useful only with authen-\ntication mechanisms not specified in this docu-\nment.\n\nWhen  read,  nsVrOspfVifAuthKey  always  returns  a\nstring of length zero.")
nsVrOspfVirtIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfVirtIfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfVirtIfAuthType.setDescription("The authentication type specified for a virtu-\nal  interface.  Additional authentication types\nmay be assigned locally.")
nsVrOspfVirtIfVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 9, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtIfVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfNbrTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10))
if mibBuilder.loadTexts: nsVrOspfNbrTable.setDescription("A table of non-virtual neighbor information.")
nsVrOspfNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfNbrVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfNbrIpAddr"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfNbrAddressLessIndex"))
if mibBuilder.loadTexts: nsVrOspfNbrEntry.setDescription("The information regarding a single neighbor.")
nsVrOspfNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrIpAddr.setDescription("The IP address this neighbor is using  in  its\nIP  Source  Address.  Note that, on addressless\nlinks, this will not be 0.0.0.0,  but  the  ad-\ndress of another of the neighbor's interfaces.")
nsVrOspfNbrAddressLessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrAddressLessIndex.setDescription("On an interface having an  IP  Address,  zero.\nOn  addressless  interfaces,  the corresponding\nvalue of ifIndex in the Internet Standard  MIB.\nOn  row  creation, this can be derived from the\ninstance.")
nsVrOspfNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 3), RouterID().clone(hexValue='00000000')).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrRtrId.setDescription("A 32-bit integer (represented as a type  IpAd-\ndress)  uniquely  identifying  the  neighboring\nrouter in the Autonomous System.")
nsVrOspfNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 4), Integer32().clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrOptions.setDescription("A Bit Mask corresponding to the neighbor's op-\ntions field.\n\nBit 0, if set, indicates that the  system  will\noperate  on  Type of Service metrics other than\nTOS 0.  If zero, the neighbor will  ignore  all\nmetrics except the TOS 0 metric.\n\nBit 1, if set, indicates  that  the  associated\narea  accepts and operates on external informa-\ntion; if zero, it is a stub area.\n\nBit 2, if set, indicates that the system is ca-\npable  of routing IP Multicast datagrams; i.e.,\nthat it implements the Multicast Extensions  to\nOSPF.\n\nBit 3, if set, indicates  that  the  associated\narea  is  an  NSSA.  These areas are capable of\ncarrying type 7 external advertisements,  which\nare  translated into type 5 external advertise-\n\nments at NSSA borders.")
nsVrOspfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 5), DesignatedRouterPriority().clone('1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfNbrPriority.setDescription("The priority of this neighbor in the designat-\ned router election algorithm.  The value 0 sig-\nnifies that the neighbor is not eligible to be-\ncome  the  designated router on this particular\nnetwork.")
nsVrOspfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,3,7,2,8,6,4,)).subtype(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrState.setDescription("The State of the relationship with this Neigh-\nbor.")
nsVrOspfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrEvents.setDescription("The number of times this neighbor relationship\nhas changed state, or an error has occurred.")
nsVrOspfNbrLsRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrLsRetransQLen.setDescription("The  current  length  of  the   retransmission\nqueue.")
nsVrOspfNbmaNbrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfNbmaNbrStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfNbmaNbrPermanence = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("dynamic", 1), ("permanent", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbmaNbrPermanence.setDescription("This variable displays the status of  the  en-\ntry.   'dynamic'  and  'permanent' refer to how\nthe neighbor became known.")
nsVrOspfNbrHelloSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrHelloSuppressed.setDescription("Indicates whether Hellos are being  suppressed\n\nto the neighbor")
nsVrOspfNbrVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 10, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfNbrVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfVirtNbrTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11))
if mibBuilder.loadTexts: nsVrOspfVirtNbrTable.setDescription("A table of virtual neighbor information.")
nsVrOspfVirtNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfVirtNbrVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfVirtNbrArea"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfVirtNbrRtrId"))
if mibBuilder.loadTexts: nsVrOspfVirtNbrEntry.setDescription("Virtual neighbor information.")
nsVrOspfVirtNbrArea = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 1), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrArea.setDescription("The Transit Area Identifier.")
nsVrOspfVirtNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 2), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrRtrId.setDescription("A  32-bit  integer  uniquely  identifying  the\nneighboring router in the Autonomous System.")
nsVrOspfVirtNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrIpAddr.setDescription("The IP address this Virtual  Neighbor  is  us-\ning.")
nsVrOspfVirtNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrOptions.setDescription("A Bit Mask corresponding to the neighbor's op-\ntions field.\n\nBit 1, if set, indicates that the  system  will\noperate  on  Type of Service metrics other than\nTOS 0.  If zero, the neighbor will  ignore  all\nmetrics except the TOS 0 metric.\n\nBit 2, if set, indicates  that  the  system  is\nNetwork  Multicast  capable; ie, that it imple-\nments OSPF Multicast Routing.")
nsVrOspfVirtNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,5,3,7,2,8,6,4,)).subtype(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrState.setDescription("The state of the  Virtual  Neighbor  Relation-\nship.")
nsVrOspfVirtNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrEvents.setDescription("The number of  times  this  virtual  link  has\nchanged its state, or an error has occurred.")
nsVrOspfVirtNbrLsRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrLsRetransQLen.setDescription("The  current  length  of  the   retransmission\nqueue.")
nsVrOspfVirtNbrHelloSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrHelloSuppressed.setDescription("Indicates whether Hellos are being  suppressed\nto the neighbor")
nsVrOspfVirtNbrVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 11, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfVirtNbrVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfExtLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12))
if mibBuilder.loadTexts: nsVrOspfExtLsdbTable.setDescription("The OSPF Process's Links State Database.")
nsVrOspfExtLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfExtLsdbVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfExtLsdbType"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfExtLsdbLsid"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfExtLsdbRouterId"))
if mibBuilder.loadTexts: nsVrOspfExtLsdbEntry.setDescription("A single Link State Advertisement.")
nsVrOspfExtLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(5,)).subtype(namedValues=NamedValues(("asExternalLink", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbType.setDescription("The type  of  the  link  state  advertisement.\nEach  link state type has a separate advertise-\nment format.")
nsVrOspfExtLsdbLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbLsid.setDescription("The Link State ID is an LS Type Specific field\ncontaining either a Router ID or an IP Address;\nit identifies the piece of the  routing  domain\nthat is being described by the advertisement.")
nsVrOspfExtLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 3), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbRouterId.setDescription("The 32 bit number that uniquely identifies the\noriginating router in the Autonomous System.")
nsVrOspfExtLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbSequence.setDescription("The sequence number field is a  signed  32-bit\ninteger.   It  is used to detect old and dupli-\ncate link state advertisements.  The  space  of\nsequence  numbers  is  linearly  ordered.   The\nlarger the sequence number the more recent  the\nadvertisement.")
nsVrOspfExtLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbAge.setDescription("This field is the age of the link state adver-\ntisement in seconds.")
nsVrOspfExtLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbChecksum.setDescription("This field is the  checksum  of  the  complete\ncontents  of  the  advertisement, excepting the\nage field.  The age field is excepted  so  that\nan   advertisement's  age  can  be  incremented\nwithout updating the  checksum.   The  checksum\nused  is  the same that is used for ISO connec-\ntionless datagrams; it is commonly referred  to\nas the Fletcher checksum.")
nsVrOspfExtLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(36, 36)).setFixedLength(36)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbAdvertisement.setDescription("The entire Link State Advertisement, including\nits header.")
nsVrOspfExtLsdbVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 12, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfExtLsdbVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrOspfAreaAggregateTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14))
if mibBuilder.loadTexts: nsVrOspfAreaAggregateTable.setDescription("A range of IP addresses  specified  by  an  IP\naddress/IP  network  mask  pair.   For example,\nclass B address range of X.X.X.X with a network\nmask  of  255.255.0.0 includes all IP addresses\nfrom X.X.0.0  to  X.X.255.255.   Note  that  if\nranges  are configured such that one range sub-\nsumes  another  range  (e.g.,   10.0.0.0   mask\n255.0.0.0  and  10.1.0.0 mask 255.255.0.0), the\nmost specific match is the preferred one.")
nsVrOspfAreaAggregateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1)).setIndexNames((0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaAggregateVRID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaAggregateAreaID"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaAggregateLsdbType"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaAggregateNet"), (0, "NETSCREEN-VR-OSPF-MIB", "nsVrOspfAreaAggregateMask"))
if mibBuilder.loadTexts: nsVrOspfAreaAggregateEntry.setDescription("A range of IP addresses  specified  by  an  IP\naddress/IP  network  mask  pair.   For example,\nclass B address range of X.X.X.X with a network\nmask  of  255.255.0.0 includes all IP addresses\nfrom X.X.0.0  to  X.X.255.255.   Note  that  if\nranges are range configured such that one range\nsubsumes another  range  (e.g.,  10.0.0.0  mask\n255.0.0.0  and  10.1.0.0 mask 255.255.0.0), the\n\nmost specific match is the preferred one.")
nsVrOspfAreaAggregateAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 1), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateAreaID.setDescription("The Area the Address Aggregate is to be  found\nwithin.")
nsVrOspfAreaAggregateLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(7,3,)).subtype(namedValues=NamedValues(("summaryLink", 3), ("nssaExternalLink", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateLsdbType.setDescription("The type of the Address Aggregate.  This field\nspecifies  the  Lsdb type that this Address Ag-\ngregate applies to.")
nsVrOspfAreaAggregateNet = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateNet.setDescription("The IP Address of the Net or Subnet  indicated\nby the range.")
nsVrOspfAreaAggregateMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateMask.setDescription("The Subnet Mask that pertains to  the  Net  or\nSubnet.")
nsVrOspfAreaAggregateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateStatus.setDescription("This variable displays the status of  the  en-\ntry.  Setting it to 'invalid' has the effect of\nrendering it inoperative.  The internal  effect\n(row removal) is implementation dependent.")
nsVrOspfAreaAggregateEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("advertiseMatching", 1), ("doNotAdvertiseMatching", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateEffect.setDescription("Subnets subsumed by ranges either trigger  the\nadvertisement  of  the indicated aggregate (ad-\nvertiseMatching), or result in the subnet's not\nbeing advertised at all outside the area.")
nsVrOspfAreaAggregateVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 5, 14, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrOspfAreaAggregateVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")

# Augmentions

# Exports

# Module identity
mibBuilder.exportSymbols("NETSCREEN-VR-OSPF-MIB", PYSNMP_MODULE_ID=nsVrOspf)

# Types
mibBuilder.exportSymbols("NETSCREEN-VR-OSPF-MIB", BigMetric=BigMetric, DesignatedRouterPriority=DesignatedRouterPriority, HelloRange=HelloRange, InterfaceIndex=InterfaceIndex, Metric=Metric, PositiveInteger=PositiveInteger, Status=Status, TOSType=TOSType, UpToMaxAge=UpToMaxAge, AreaID=AreaID, RouterID=RouterID)

# Objects
mibBuilder.exportSymbols("NETSCREEN-VR-OSPF-MIB", nsVrOspf=nsVrOspf, nsVrOspfGeneralTable=nsVrOspfGeneralTable, nsVrOspfGeneralEntry=nsVrOspfGeneralEntry, nsVrOspfRouterId=nsVrOspfRouterId, nsVrOspfAdminStat=nsVrOspfAdminStat, nsVrOspfVersionNumber=nsVrOspfVersionNumber, nsVrOspfAreaBdrRtrStatus=nsVrOspfAreaBdrRtrStatus, nsVrOspfASBdrRtrStatus=nsVrOspfASBdrRtrStatus, nsVrOspfExternLsaCount=nsVrOspfExternLsaCount, nsVrOspfExternLsaCksumSum=nsVrOspfExternLsaCksumSum, nsVrOspfTOSSupport=nsVrOspfTOSSupport, nsVrOspfOriginateNewLsas=nsVrOspfOriginateNewLsas, nsVrOspfRxNewLsas=nsVrOspfRxNewLsas, nsVrOspfExtLsdbLimit=nsVrOspfExtLsdbLimit, nsVrOspfMulticastExtensions=nsVrOspfMulticastExtensions, nsVrOspfExitOverflowInterval=nsVrOspfExitOverflowInterval, nsVrOspfDemandExtensions=nsVrOspfDemandExtensions, nsVrOspfGeneralVRID=nsVrOspfGeneralVRID, nsVrOspfAreaTable=nsVrOspfAreaTable, nsVrOspfAreaEntry=nsVrOspfAreaEntry, nsVrOspfAreaId=nsVrOspfAreaId, nsVrOspfImportAsExtern=nsVrOspfImportAsExtern, nsVrOspfSpfRuns=nsVrOspfSpfRuns, nsVrOspfAreaBdrRtrCount=nsVrOspfAreaBdrRtrCount, nsVrOspfAsBdrRtrCount=nsVrOspfAsBdrRtrCount, nsVrOspfAreaLsaCount=nsVrOspfAreaLsaCount, nsVrOspfAreaLsaCksumSum=nsVrOspfAreaLsaCksumSum, nsVrOspfAreaSummary=nsVrOspfAreaSummary, nsVrOspfAreaStatus=nsVrOspfAreaStatus, nsVrOspfAreaVRID=nsVrOspfAreaVRID, nsVrOspfStubAreaTable=nsVrOspfStubAreaTable, nsVrOspfStubAreaEntry=nsVrOspfStubAreaEntry, nsVrOspfStubAreaId=nsVrOspfStubAreaId, nsVrOspfStubTOS=nsVrOspfStubTOS, nsVrOspfStubMetric=nsVrOspfStubMetric, nsVrOspfStubStatus=nsVrOspfStubStatus, nsVrOspfStubMetricType=nsVrOspfStubMetricType, nsVrOspfStubVRID=nsVrOspfStubVRID, nsVrOspfLsdbTable=nsVrOspfLsdbTable, nsVrOspfLsdbEntry=nsVrOspfLsdbEntry, nsVrOspfLsdbAreaId=nsVrOspfLsdbAreaId, nsVrOspfLsdbType=nsVrOspfLsdbType, nsVrOspfLsdbLsid=nsVrOspfLsdbLsid, nsVrOspfLsdbRouterId=nsVrOspfLsdbRouterId, nsVrOspfLsdbSequence=nsVrOspfLsdbSequence, nsVrOspfLsdbAge=nsVrOspfLsdbAge, nsVrOspfLsdbChecksum=nsVrOspfLsdbChecksum, nsVrOspfLsdbAdvertisement=nsVrOspfLsdbAdvertisement, nsVrOspfLsdbVRID=nsVrOspfLsdbVRID, nsVrOspfHostTable=nsVrOspfHostTable, nsVrOspfHostEntry=nsVrOspfHostEntry, nsVrOspfHostIpAddress=nsVrOspfHostIpAddress, nsVrOspfHostTOS=nsVrOspfHostTOS, nsVrOspfHostMetric=nsVrOspfHostMetric, nsVrOspfHostStatus=nsVrOspfHostStatus, nsVrOspfHostAreaID=nsVrOspfHostAreaID, nsVrOspfHostVRID=nsVrOspfHostVRID, nsVrOspfIfTable=nsVrOspfIfTable, nsVrOspfIfEntry=nsVrOspfIfEntry, nsVrOspfIfIpAddress=nsVrOspfIfIpAddress, nsVrOspfAddressLessIf=nsVrOspfAddressLessIf, nsVrOspfIfAreaId=nsVrOspfIfAreaId, nsVrOspfIfType=nsVrOspfIfType, nsVrOspfIfAdminStat=nsVrOspfIfAdminStat, nsVrOspfIfRtrPriority=nsVrOspfIfRtrPriority, nsVrOspfIfTransitDelay=nsVrOspfIfTransitDelay, nsVrOspfIfRetransInterval=nsVrOspfIfRetransInterval, nsVrOspfIfHelloInterval=nsVrOspfIfHelloInterval, nsVrOspfIfRtrDeadInterval=nsVrOspfIfRtrDeadInterval, nsVrOspfIfPollInterval=nsVrOspfIfPollInterval, nsVrOspfIfState=nsVrOspfIfState, nsVrOspfIfDesignatedRouter=nsVrOspfIfDesignatedRouter, nsVrOspfIfBackupDesignatedRouter=nsVrOspfIfBackupDesignatedRouter, nsVrOspfIfEvents=nsVrOspfIfEvents, nsVrOspfIfAuthKey=nsVrOspfIfAuthKey, nsVrOspfIfStatus=nsVrOspfIfStatus, nsVrOspfIfMulticastForwarding=nsVrOspfIfMulticastForwarding, nsVrOspfIfDemand=nsVrOspfIfDemand, nsVrOspfIfAuthType=nsVrOspfIfAuthType, nsVrOspfIfVRID=nsVrOspfIfVRID, nsVrOspfIfMetricTable=nsVrOspfIfMetricTable, nsVrOspfIfMetricEntry=nsVrOspfIfMetricEntry, nsVrOspfIfMetricIpAddress=nsVrOspfIfMetricIpAddress, nsVrOspfIfMetricAddressLessIf=nsVrOspfIfMetricAddressLessIf, nsVrOspfIfMetricTOS=nsVrOspfIfMetricTOS, nsVrOspfIfMetricValue=nsVrOspfIfMetricValue, nsVrOspfIfMetricStatus=nsVrOspfIfMetricStatus, nsVrOspfIfMetricVRID=nsVrOspfIfMetricVRID, nsVrOspfVirtIfTable=nsVrOspfVirtIfTable, nsVrOspfVirtIfEntry=nsVrOspfVirtIfEntry, nsVrOspfVirtIfAreaId=nsVrOspfVirtIfAreaId, nsVrOspfVirtIfNeighbor=nsVrOspfVirtIfNeighbor, nsVrOspfVirtIfTransitDelay=nsVrOspfVirtIfTransitDelay, nsVrOspfVirtIfRetransInterval=nsVrOspfVirtIfRetransInterval, nsVrOspfVirtIfHelloInterval=nsVrOspfVirtIfHelloInterval, nsVrOspfVirtIfRtrDeadInterval=nsVrOspfVirtIfRtrDeadInterval, nsVrOspfVirtIfState=nsVrOspfVirtIfState, nsVrOspfVirtIfEvents=nsVrOspfVirtIfEvents, nsVrOspfVirtIfAuthKey=nsVrOspfVirtIfAuthKey, nsVrOspfVirtIfStatus=nsVrOspfVirtIfStatus, nsVrOspfVirtIfAuthType=nsVrOspfVirtIfAuthType, nsVrOspfVirtIfVRID=nsVrOspfVirtIfVRID, nsVrOspfNbrTable=nsVrOspfNbrTable, nsVrOspfNbrEntry=nsVrOspfNbrEntry, nsVrOspfNbrIpAddr=nsVrOspfNbrIpAddr, nsVrOspfNbrAddressLessIndex=nsVrOspfNbrAddressLessIndex, nsVrOspfNbrRtrId=nsVrOspfNbrRtrId, nsVrOspfNbrOptions=nsVrOspfNbrOptions, nsVrOspfNbrPriority=nsVrOspfNbrPriority, nsVrOspfNbrState=nsVrOspfNbrState, nsVrOspfNbrEvents=nsVrOspfNbrEvents, nsVrOspfNbrLsRetransQLen=nsVrOspfNbrLsRetransQLen, nsVrOspfNbmaNbrStatus=nsVrOspfNbmaNbrStatus, nsVrOspfNbmaNbrPermanence=nsVrOspfNbmaNbrPermanence, nsVrOspfNbrHelloSuppressed=nsVrOspfNbrHelloSuppressed, nsVrOspfNbrVRID=nsVrOspfNbrVRID, nsVrOspfVirtNbrTable=nsVrOspfVirtNbrTable, nsVrOspfVirtNbrEntry=nsVrOspfVirtNbrEntry, nsVrOspfVirtNbrArea=nsVrOspfVirtNbrArea, nsVrOspfVirtNbrRtrId=nsVrOspfVirtNbrRtrId, nsVrOspfVirtNbrIpAddr=nsVrOspfVirtNbrIpAddr, nsVrOspfVirtNbrOptions=nsVrOspfVirtNbrOptions, nsVrOspfVirtNbrState=nsVrOspfVirtNbrState, nsVrOspfVirtNbrEvents=nsVrOspfVirtNbrEvents, nsVrOspfVirtNbrLsRetransQLen=nsVrOspfVirtNbrLsRetransQLen, nsVrOspfVirtNbrHelloSuppressed=nsVrOspfVirtNbrHelloSuppressed)
mibBuilder.exportSymbols("NETSCREEN-VR-OSPF-MIB", nsVrOspfVirtNbrVRID=nsVrOspfVirtNbrVRID, nsVrOspfExtLsdbTable=nsVrOspfExtLsdbTable, nsVrOspfExtLsdbEntry=nsVrOspfExtLsdbEntry, nsVrOspfExtLsdbType=nsVrOspfExtLsdbType, nsVrOspfExtLsdbLsid=nsVrOspfExtLsdbLsid, nsVrOspfExtLsdbRouterId=nsVrOspfExtLsdbRouterId, nsVrOspfExtLsdbSequence=nsVrOspfExtLsdbSequence, nsVrOspfExtLsdbAge=nsVrOspfExtLsdbAge, nsVrOspfExtLsdbChecksum=nsVrOspfExtLsdbChecksum, nsVrOspfExtLsdbAdvertisement=nsVrOspfExtLsdbAdvertisement, nsVrOspfExtLsdbVRID=nsVrOspfExtLsdbVRID, nsVrOspfAreaAggregateTable=nsVrOspfAreaAggregateTable, nsVrOspfAreaAggregateEntry=nsVrOspfAreaAggregateEntry, nsVrOspfAreaAggregateAreaID=nsVrOspfAreaAggregateAreaID, nsVrOspfAreaAggregateLsdbType=nsVrOspfAreaAggregateLsdbType, nsVrOspfAreaAggregateNet=nsVrOspfAreaAggregateNet, nsVrOspfAreaAggregateMask=nsVrOspfAreaAggregateMask, nsVrOspfAreaAggregateStatus=nsVrOspfAreaAggregateStatus, nsVrOspfAreaAggregateEffect=nsVrOspfAreaAggregateEffect, nsVrOspfAreaAggregateVRID=nsVrOspfAreaAggregateVRID)

