# PySNMP SMI module. Autogenerated from smidump -f python CISCO-BGP4-MIB
# by libsmi2pysnmp-0.1.3 at Fri May 23 09:05:50 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( bgpPeerEntry, bgpPeerLastError, bgpPeerRemoteAddr, bgpPeerState, ) = mibBuilder.importSymbols("BGP4-MIB", "bgpPeerEntry", "bgpPeerLastError", "bgpPeerRemoteAddr", "bgpPeerState")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue")

# Types

class CbgpNetworkAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,255)
    
class CbgpSafi(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,3,128,)
    namedValues = NamedValues(("unicast", 1), ("vpn", 128), ("multicast", 2), ("unicastAndMulticast", 3), )
    

# Objects

ciscoBgp4MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 187)).setRevisions(("2003-02-24 00:00","2002-12-19 00:00","2001-08-13 00:00",))
if mibBuilder.loadTexts: ciscoBgp4MIB.setOrganization("Cisco Systems, Inc.")
if mibBuilder.loadTexts: ciscoBgp4MIB.setContactInfo("       Cisco Systems\nCustomer Service\n\nPostal: 170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\n\nE-mail: cs-iprouting-bgp@cisco.com")
if mibBuilder.loadTexts: ciscoBgp4MIB.setDescription("An extension to the IETF BGP4 MIB module defined in \nRFC 1657.\n               \nFollowing is the terminology associated with Border\nGateway Protocol(BGP).\n   \nUPDATE message\n    UPDATE messages are used to transfer routing \n    information between BGP peers. An UPDATE message \n    is used to advertise a single feasible route to a\n    peer, or to withdraw multiple unfeasible routes \n    from service.                 \n\nAdj-RIBs-In \n   The Adj-RIBs-In store routing information that has\n   been learned from inbound UPDATE messages. Their \n   contents represent routes that are available as an \n   input to the Decision Process.\n\nLoc-RIB(BGP table) \n   The Loc-RIB contains the local routing information\n   that the BGP speaker has selected by applying its \n   local policies to the routing information contained \n   in its Adj-RIBs-In.\n\nAdj-RIBs-Out \n   The Adj-RIBs-Out store the information that the\n   local BGP speaker has selected for advertisement to \n   its peers. The routing information stored in the \n   Adj-RIBs-Out will be carried in the local BGP \n   speaker's UPDATE messages and advertised to its\n   peers.\n\nPath Attributes\n   A variable length sequence of path attributes is \n   present in every UPDATE. Each path attribute is a \n   triple <attribute type, attribute length, \n   attribute value> of variable length. \n\nNetwork Layer Reachability Information(NLRI)\n   A variable length field present in UPDATE messages\n   which contains a list of Network Layer address \n   prefixes. \n\nAddress Family Identifier(AFI) \n   Primary identifier to indicate the type of the \n   Network Layer Reachability Information(NLRI) being \n   carried.\n\nSubsequent Address Family Identifier(SAFI) \n   Secondary identifier to indicate the type of the \n   Network Layer Reachability Information(NLRI) being \n   carried.")
ciscoBgp4NotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 0))
ciscoBgp4MIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1))
cbgpRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1))
cbgpRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1))
if mibBuilder.loadTexts: cbgpRouteTable.setDescription("This table contains information about routes to \ndestination networks from all BGP4 peers.  Since \nBGP4 can carry routes for multiple Network Layer \nprotocols, this table has the Address Family \nIdentifier(AFI) of the Network Layer protocol as the \nfirst index. Further for a given AFI, routes carried\nby BGP4 are distinguished based on Subsequent Address \nFamily Identifiers(SAFI).  Hence that is used as the\nsecond index.  Conceptually there is a separate Loc-RIB\nmaintained by the BGP speaker for each combination of \nAFI and SAFI supported by it.")
cbgpRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1)).setIndexNames((0, "CISCO-BGP4-MIB", "cbgpRouteAfi"), (0, "CISCO-BGP4-MIB", "cbgpRouteSafi"), (0, "CISCO-BGP4-MIB", "cbgpRoutePeerType"), (0, "CISCO-BGP4-MIB", "cbgpRoutePeer"), (0, "CISCO-BGP4-MIB", "cbgpRouteAddrPrefix"), (0, "CISCO-BGP4-MIB", "cbgpRouteAddrPrefixLen"))
if mibBuilder.loadTexts: cbgpRouteEntry.setDescription("Information about a path to a network received from\na peer.")
cbgpRouteAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteAfi.setDescription("Represents Address Family Identifier(AFI) of the \nNetwork Layer protocol associated with the route.\nAn implementation is only required to support IPv4\nunicast and VPNv4 (Value - 1) address families.")
cbgpRouteSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 2), CbgpSafi()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteSafi.setDescription("Represents Subsequent Address Family Identifier(SAFI)\nof the route. It gives additional information about\nthe type of the route. An implementation is only \nrequired to support IPv4 unicast(Value - 1) and VPNv4(\nValue - 128) address families.")
cbgpRoutePeerType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 3), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRoutePeerType.setDescription("Represents the type of Network Layer address stored\nin cbgpRoutePeer. An implementation is only required\nto support IPv4 address type(Value - 1).")
cbgpRoutePeer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 4), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRoutePeer.setDescription("The Network Layer address of the peer where the route\ninformation was learned. An implementation is only \nrequired to support an IPv4 peer.")
cbgpRouteAddrPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 5), CbgpNetworkAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteAddrPrefix.setDescription("A Network Address prefix in the Network Layer \nReachability Information field of BGP UPDATE message.\nThis object is a Network Address containing the prefix\nwith length specified by cbgpRouteAddrPrefixLen. Any\nbits beyond the length specified by\ncbgpRouteAddrPrefixLen are zeroed.")
cbgpRouteAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2040))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteAddrPrefixLen.setDescription("Length in bits of the Network Address prefix in the \nNetwork Layer Reachability Information field.")
cbgpRouteOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteOrigin.setDescription("The ultimate origin of the route information.")
cbgpRouteASPathSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteASPathSegment.setDescription("The sequence of AS path segments.  Each AS\npath segment is represented by a triple\n<type, length, value>.\n\nThe type is a 1-octet field which has two\npossible values:\n1  AS_SET: unordered set of ASs a route in the \n          UPDATE message has traversed\n2  AS_SEQUENCE: ordered set of ASs a route in the\n               UPDATE message has traversed.\n\nThe length is a 1-octet field containing the\nnumber of ASs in the value field.\n\nThe value field contains one or more AS\nnumbers, each AS is represented in the octet\nstring as a pair of octets according to the\nfollowing algorithm:\n\nfirst-byte-of-pair = ASNumber / 256;\nsecond-byte-of-pair = ASNumber & 255;")
cbgpRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 9), CbgpNetworkAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteNextHop.setDescription("The Network Layer address of the border router \nthat should be used for the destination network.")
cbgpRouteMedPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteMedPresent.setDescription("Indicates the presence/absence of MULTI_EXIT_DISC \nattribute for the route.")
cbgpRouteMultiExitDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteMultiExitDisc.setDescription("This metric is used to discriminate between multiple \nexit points to an adjacent autonomous system.  The\nvalue of this object is irrelevant if the value of\nof cbgpRouteMedPresent is false(2).")
cbgpRouteLocalPrefPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteLocalPrefPresent.setDescription("Indicates the presence/absence of LOCAL_PREF \nattribute for the route.")
cbgpRouteLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteLocalPref.setDescription("The degree of preference calculated by the local BGP4\nspeaker for the route. The value of this object is \nirrelevant if the value of cbgpRouteLocalPrefPresent \nis false(2).")
cbgpRouteAtomicAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("lessSpecificRouteNotSelected", 1), ("lessSpecificRouteSelected", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAtomicAggregate.setDescription("Whether or not the local system has selected a less \nspecific route without selecting a more specific\nroute.")
cbgpRouteAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAggregatorAS.setDescription("The AS number of the last BGP4 speaker that performed\nroute aggregation.  A value of zero (0) indicates the \nabsence of this attribute.")
cbgpRouteAggregatorAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 16), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAggregatorAddrType.setDescription("Represents the type of Network Layer address stored\nin cbgpRouteAggregatorAddr.")
cbgpRouteAggregatorAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 17), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAggregatorAddr.setDescription("The Network Layer address of the last BGP4 speaker\nthat performed route aggregation.  A value of all zeros\nindicates the absence of this attribute.")
cbgpRouteBest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteBest.setDescription("An indication of whether or not this route was chosen\nas the best BGP4 route.")
cbgpRouteUnknownAttr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteUnknownAttr.setDescription("One or more path attributes not understood by this\nBGP4 speaker.  Size zero (0) indicates the absence of\nsuch attribute(s).  Octets beyond the maximum size, if\nany, are not recorded by this object.  \n      \nEach path attribute is a triple <attribute type,\nattribute length, attribute value> of variable length.\nAttribute Type is a two-octet field that consists of\nthe Attribute Flags octet followed by the Attribute\nType Code octet.  If the Extended Length bit of the \nAttribute Flags octet is set to 0, the third octet of \nthe Path Attribute contains the length of the\nattribute data in octets.  If the Extended Length bit \nof the Attribute Flags octet is set to 1, then the\nthird and the fourth octets of the path attribute \ncontain the length of the attribute data in octets.\nThe remaining octets of the Path Attribute represent \nthe attribute value and are interpreted according to \nthe Attribute Flags and the Attribute Type Code.")
cbgpPeer = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2))
cbgpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1))
if mibBuilder.loadTexts: cbgpPeerTable.setDescription("BGP peer table.  This table contains,\none entry per BGP peer, information about\nthe connections with BGP peers.")
cbgpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1))
if mibBuilder.loadTexts: cbgpPeerEntry.setDescription("Entry containing information about the\nconnection with a BGP peer.")
cbgpPeerPrefixAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixAccepted.setDescription("Number of Route prefixes received on this connnection,\nwhich are accepted after applying filters. Possible\nfilters are route maps, prefix lists, distributed\nlists, etc.")
cbgpPeerPrefixDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixDenied.setDescription("Counter which gets incremented when a route prefix\nreceived on this connection is denied  or when a route\nprefix is denied during soft reset of this connection\nif 'soft-reconfiguration' is on . This object is \ninitialized to zero when the peer is  configured or\nthe router is rebooted")
cbgpPeerPrefixLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeerPrefixLimit.setDescription("Max number of route prefixes accepted on this \nconnection")
cbgpPeerPrefixAdvertised = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixAdvertised.setDescription("Counter which gets incremented when a route prefix\nis advertised on this connection. This object is\ninitialized to zero when the peer is configured or \nthe router is rebooted")
cbgpPeerPrefixSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixSuppressed.setDescription("Counter which gets incremented when a route prefix\nis suppressed from being sent on this connection. This \nobject is initialized to zero when the peer is \nconfigured or the router is rebooted")
cbgpPeerPrefixWithdrawn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixWithdrawn.setDescription("Counter which gets incremented when a route prefix\nis withdrawn on this connection. This object is\ninitialized to zero when the peer is configured or\nthe router is rebooted")
cbgpPeerLastErrorTxt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerLastErrorTxt.setDescription("Implementation specific error description for\nbgpPeerLastErrorReceived.")
cbgpPeerPrevState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(6,0,5,2,3,4,1,)).subtype(namedValues=NamedValues(("none", 0), ("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrevState.setDescription("The BGP peer connection previous state.")
cbgpPeerCapsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2))
if mibBuilder.loadTexts: cbgpPeerCapsTable.setDescription("This table contains the capabilities that are\nsupported by a peer. Capabilities of a peer are \nreceived during BGP connection establishment.\nValues corresponding to each received capability\nare stored in this table. When a new capability \nis received, this table is updated with a new \nentry. When an existing capability is not received \nduring the latest connection establishment, the \ncorresponding entry is deleted from the table.")
cbgpPeerCapsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1)).setIndexNames((0, "BGP4-MIB", "bgpPeerRemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeerCapCode"), (0, "CISCO-BGP4-MIB", "cbgpPeerCapIndex"))
if mibBuilder.loadTexts: cbgpPeerCapsEntry.setDescription("Each entry represents a capability received from a\npeer with a particular code and an index. When a \ncapability is received multiple times with different\nvalues during a BGP connection establishment, \ncorresponding entries are differentiated with indices.")
cbgpPeerCapCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,64,1,128,)).subtype(namedValues=NamedValues(("multiProtocol", 1), ("routeRefreshOld", 128), ("routeRefresh", 2), ("gracefulRestart", 64), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerCapCode.setDescription("The BGP Capability Advertisement Capability Code.")
cbgpPeerCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerCapIndex.setDescription("Multiple instances of a given capability may be\nsent by a BGP speaker.  This variable is used\nto index them.")
cbgpPeerCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerCapValue.setDescription("The value of the announced capability. This\nMIB object value is organized as given below,\n    Capability : Route Refresh Capability\n                 Null string\n    Capability : Multiprotocol Extensions\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n    Capability : Graceful Restart\n      +----------------------------------+\n      | Restart Flags (4 bits)           |\n      +----------------------------------+\n      | Restart Time in seconds (12 bits)|\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Flags for Address Family (8 bits)|\n      +----------------------------------+\n      | ...                              |\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Flags for Address Family (8 bits)|\n      +----------------------------------+")
cbgpPeerAddrFamilyTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyTable.setDescription("This table contains information related to \naddress families supported by a peer. Supported\naddress families of a peer are known during BGP \nconnection establishment. When a new supported \naddress family is known, this table is updated \nwith a new entry. When an address family is not \nsupported any more, corresponding entry is deleted \nfrom the table.")
cbgpPeerAddrFamilyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1)).setIndexNames((0, "BGP4-MIB", "bgpPeerRemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilyAfi"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilySafi"))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyEntry.setDescription("An entry is identified by an AFI/SAFI pair and\npeer address. It contains names associated with\nan address family.")
cbgpPeerAddrFamilyAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerAddrFamilyAfi.setDescription("The AFI index of the entry. An implementation\nis only required to support IPv4 unicast and \nVPNv4 (Value - 1) address families.")
cbgpPeerAddrFamilySafi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1, 2), CbgpSafi()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerAddrFamilySafi.setDescription("The SAFI index of the entry. An implementation\nis only required to support IPv4 unicast(Value \n- 1) and VPNv4( Value - 128) address families.")
cbgpPeerAddrFamilyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerAddrFamilyName.setDescription("Implementation specific Address Family name.")
cbgpPeerAddrFamilyPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyPrefixTable.setDescription("This table contains prefix related information \nrelated to address families supported by a peer. \nSupported address families of a peer are known \nduring BGP connection establishment. When a new \nsupported address family is known, this table \nis updated with a new entry. When an address \nfamily is not supported any more, corresponding \nentry is deleted from the table.")
cbgpPeerAddrFamilyPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1)).setIndexNames((0, "BGP4-MIB", "bgpPeerRemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilyAfi"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilySafi"))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyPrefixEntry.setDescription("An entry is identified by an AFI/SAFI pair and\npeer address. It contains information associated \nwith route prefixes belonging to an address family.")
cbgpPeerAcceptedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerAcceptedPrefixes.setDescription("Number of accepted route prefixes on this connection,\nwhich belong to an address family.")
cbgpPeerDeniedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerDeniedPrefixes.setDescription("This counter is incremented when a route prefix, which\nbelongs to an address family, received on this \nconnection is denied. It is initialized to zero when \nthe connection is undergone a hard reset.")
cbgpPeerPrefixAdminLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeerPrefixAdminLimit.setDescription("Max number of route prefixes accepted for an address\nfamily on this connection.")
cbgpPeerPrefixThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeerPrefixThreshold.setDescription("Prefix threshold value (%) for an address family\non this connection at which warning message stating\nthe prefix count is crossed the threshold or \ncorresponding SNMP notification is generated.")
cbgpPeerPrefixClearThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixClearThreshold.setDescription("Prefix threshold value (%) for an address family\non this connection at which SNMP clear notification\nis generated if prefix threshold notification is\nalready generated.")
cbgpPeerAdvertisedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerAdvertisedPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family is advertised\non this connection. It is initialized to zero when \nthe connection is undergone a hard reset.")
cbgpPeerSuppressedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerSuppressedPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family is suppressed\nfrom being sent on this connection. It is \ninitialized to zero when the connection is undergone\na hard reset.")
cbgpPeerWithdrawnPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerWithdrawnPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family, is withdrawn on\nthis connection. It is initialized to zero when the\nconnection is undergone a hard reset.")
ciscoBgp4NotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 2))
ciscoBgp4MIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 3))
ciscoBgp4MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1))
ciscoBgp4MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2))

# Augmentions
bgpPeerEntry, = mibBuilder.importSymbols("BGP4-MIB", "bgpPeerEntry")
bgpPeerEntry.registerAugmentions(("CISCO-BGP4-MIB", "cbgpPeerEntry"))
cbgpPeerEntry.setIndexNames(*bgpPeerEntry.getIndexNames())

# Notifications

cbgpFsmStateChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 1)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerLastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeerPrevState"), ("BGP4-MIB", "bgpPeerState"), ("BGP4-MIB", "bgpPeerLastError"), ) )
if mibBuilder.loadTexts: cbgpFsmStateChange.setDescription("The BGP cbgpFsmStateChange notification is generated\nfor every BGP FSM state change. The bgpPeerRemoteAddr\nvalue is attached to the notification object ID.")
cbgpBackwardTransition = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 2)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerLastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeerPrevState"), ("BGP4-MIB", "bgpPeerState"), ("BGP4-MIB", "bgpPeerLastError"), ) )
if mibBuilder.loadTexts: cbgpBackwardTransition.setDescription("The cbgpBackwardTransition Event is generated when the\nBGP FSM moves from a higher numbered state to a lower\nnumbered state. The bgpPeerRemoteAddr value is attached\nto the notification object ID.")
cbgpPrefixThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 3)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerPrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixThreshold"), ) )
if mibBuilder.loadTexts: cbgpPrefixThresholdExceeded.setDescription("The cbgpPrfefixMaxThresholdExceeded notification is\ngenerated when prefix count exceeds the configured\nwarning threshold on a session for an address\nfamily. The bgpPeerRemoteAddr, cbgpPeerAddrFamilyAfi\nand cbgpPeerAddrFamilySafi values are attached to the\nnotification object ID.")
cbgpPrefixThresholdClear = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 4)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerPrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixClearThreshold"), ) )
if mibBuilder.loadTexts: cbgpPrefixThresholdClear.setDescription("The cbgpPrefixThresholdClear notification is\ngenerated when prefix count drops below the configured\nclear threshold on a session for an address family once\ncbgpPrefixThresholdExceeded is generated. This won't\nbe generated if the peer session goes down after the\ngeneration of cbgpPrefixThresholdExceeded.\nThe bgpPeerRemoteAddr, cbgpPeerAddrFamilyAfi and\ncbgpPeerAddrFamilySafi values are attached to the\nnotification object ID.")

# Groups

ciscoBgp4RouteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 1)).setObjects(*(("CISCO-BGP4-MIB", "cbgpRouteAggregatorAddr"), ("CISCO-BGP4-MIB", "cbgpRouteAtomicAggregate"), ("CISCO-BGP4-MIB", "cbgpRouteASPathSegment"), ("CISCO-BGP4-MIB", "cbgpRouteLocalPref"), ("CISCO-BGP4-MIB", "cbgpRouteUnknownAttr"), ("CISCO-BGP4-MIB", "cbgpRouteBest"), ("CISCO-BGP4-MIB", "cbgpRouteNextHop"), ("CISCO-BGP4-MIB", "cbgpRouteMedPresent"), ("CISCO-BGP4-MIB", "cbgpRouteLocalPrefPresent"), ("CISCO-BGP4-MIB", "cbgpRouteOrigin"), ("CISCO-BGP4-MIB", "cbgpRouteAggregatorAS"), ("CISCO-BGP4-MIB", "cbgpRouteAggregatorAddrType"), ("CISCO-BGP4-MIB", "cbgpRouteMultiExitDisc"), ) )
if mibBuilder.loadTexts: ciscoBgp4RouteGroup.setDescription("A collection of objects providing information \nabout routes received by BGP speaker.")
ciscoBgp4PeerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 2)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerPrefixLimit"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixWithdrawn"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixDenied"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixSuppressed"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixAdvertised"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixAccepted"), ) )
if mibBuilder.loadTexts: ciscoBgp4PeerGroup.setDescription("A collection of objects providing information \nabout routes received by BGP speaker.")
ciscoBgp4NotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 3)).setObjects(*(("CISCO-BGP4-MIB", "cbgpFsmStateChange"), ) )
if mibBuilder.loadTexts: ciscoBgp4NotificationsGroup.setDescription("The collection of  notifications related to BGP.")
ciscoBgp4PeerGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 4)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerAdvertisedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerAcceptedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerLastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeerCapValue"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeerAddrFamilyName"), ("CISCO-BGP4-MIB", "cbgpPeerPrevState"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixThreshold"), ("CISCO-BGP4-MIB", "cbgpPeerSuppressedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixClearThreshold"), ("CISCO-BGP4-MIB", "cbgpPeerWithdrawnPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerDeniedPrefixes"), ) )
if mibBuilder.loadTexts: ciscoBgp4PeerGroup1.setDescription("A collection of objects providing information\nabout a BGP peer.")
ciscoBgp4NotificationsGroup1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 5)).setObjects(*(("CISCO-BGP4-MIB", "cbgpFsmStateChange"), ("CISCO-BGP4-MIB", "cbgpBackwardTransition"), ("CISCO-BGP4-MIB", "cbgpPrefixThresholdClear"), ("CISCO-BGP4-MIB", "cbgpPrefixThresholdExceeded"), ) )
if mibBuilder.loadTexts: ciscoBgp4NotificationsGroup1.setDescription("The collection of  notifications related to BGP.")

# Compliances

ciscoBgp4MIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 1)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBCompliance.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")
ciscoBgp4MIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 2)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4PeerGroup"), ("CISCO-BGP4-MIB", "ciscoBgp4NotificationsGroup"), ("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBComplianceRev1.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")
ciscoBgp4MIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 3)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4NotificationsGroup1"), ("CISCO-BGP4-MIB", "ciscoBgp4PeerGroup1"), ("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBComplianceRev2.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-BGP4-MIB", PYSNMP_MODULE_ID=ciscoBgp4MIB)

# Types
mibBuilder.exportSymbols("CISCO-BGP4-MIB", CbgpNetworkAddress=CbgpNetworkAddress, CbgpSafi=CbgpSafi)

# Objects
mibBuilder.exportSymbols("CISCO-BGP4-MIB", ciscoBgp4MIB=ciscoBgp4MIB, ciscoBgp4NotifyPrefix=ciscoBgp4NotifyPrefix, ciscoBgp4MIBObjects=ciscoBgp4MIBObjects, cbgpRoute=cbgpRoute, cbgpRouteTable=cbgpRouteTable, cbgpRouteEntry=cbgpRouteEntry, cbgpRouteAfi=cbgpRouteAfi, cbgpRouteSafi=cbgpRouteSafi, cbgpRoutePeerType=cbgpRoutePeerType, cbgpRoutePeer=cbgpRoutePeer, cbgpRouteAddrPrefix=cbgpRouteAddrPrefix, cbgpRouteAddrPrefixLen=cbgpRouteAddrPrefixLen, cbgpRouteOrigin=cbgpRouteOrigin, cbgpRouteASPathSegment=cbgpRouteASPathSegment, cbgpRouteNextHop=cbgpRouteNextHop, cbgpRouteMedPresent=cbgpRouteMedPresent, cbgpRouteMultiExitDisc=cbgpRouteMultiExitDisc, cbgpRouteLocalPrefPresent=cbgpRouteLocalPrefPresent, cbgpRouteLocalPref=cbgpRouteLocalPref, cbgpRouteAtomicAggregate=cbgpRouteAtomicAggregate, cbgpRouteAggregatorAS=cbgpRouteAggregatorAS, cbgpRouteAggregatorAddrType=cbgpRouteAggregatorAddrType, cbgpRouteAggregatorAddr=cbgpRouteAggregatorAddr, cbgpRouteBest=cbgpRouteBest, cbgpRouteUnknownAttr=cbgpRouteUnknownAttr, cbgpPeer=cbgpPeer, cbgpPeerTable=cbgpPeerTable, cbgpPeerEntry=cbgpPeerEntry, cbgpPeerPrefixAccepted=cbgpPeerPrefixAccepted, cbgpPeerPrefixDenied=cbgpPeerPrefixDenied, cbgpPeerPrefixLimit=cbgpPeerPrefixLimit, cbgpPeerPrefixAdvertised=cbgpPeerPrefixAdvertised, cbgpPeerPrefixSuppressed=cbgpPeerPrefixSuppressed, cbgpPeerPrefixWithdrawn=cbgpPeerPrefixWithdrawn, cbgpPeerLastErrorTxt=cbgpPeerLastErrorTxt, cbgpPeerPrevState=cbgpPeerPrevState, cbgpPeerCapsTable=cbgpPeerCapsTable, cbgpPeerCapsEntry=cbgpPeerCapsEntry, cbgpPeerCapCode=cbgpPeerCapCode, cbgpPeerCapIndex=cbgpPeerCapIndex, cbgpPeerCapValue=cbgpPeerCapValue, cbgpPeerAddrFamilyTable=cbgpPeerAddrFamilyTable, cbgpPeerAddrFamilyEntry=cbgpPeerAddrFamilyEntry, cbgpPeerAddrFamilyAfi=cbgpPeerAddrFamilyAfi, cbgpPeerAddrFamilySafi=cbgpPeerAddrFamilySafi, cbgpPeerAddrFamilyName=cbgpPeerAddrFamilyName, cbgpPeerAddrFamilyPrefixTable=cbgpPeerAddrFamilyPrefixTable, cbgpPeerAddrFamilyPrefixEntry=cbgpPeerAddrFamilyPrefixEntry, cbgpPeerAcceptedPrefixes=cbgpPeerAcceptedPrefixes, cbgpPeerDeniedPrefixes=cbgpPeerDeniedPrefixes, cbgpPeerPrefixAdminLimit=cbgpPeerPrefixAdminLimit, cbgpPeerPrefixThreshold=cbgpPeerPrefixThreshold, cbgpPeerPrefixClearThreshold=cbgpPeerPrefixClearThreshold, cbgpPeerAdvertisedPrefixes=cbgpPeerAdvertisedPrefixes, cbgpPeerSuppressedPrefixes=cbgpPeerSuppressedPrefixes, cbgpPeerWithdrawnPrefixes=cbgpPeerWithdrawnPrefixes, ciscoBgp4NotificationPrefix=ciscoBgp4NotificationPrefix, ciscoBgp4MIBConformance=ciscoBgp4MIBConformance, ciscoBgp4MIBCompliances=ciscoBgp4MIBCompliances, ciscoBgp4MIBGroups=ciscoBgp4MIBGroups)

# Notifications
mibBuilder.exportSymbols("CISCO-BGP4-MIB", cbgpFsmStateChange=cbgpFsmStateChange, cbgpBackwardTransition=cbgpBackwardTransition, cbgpPrefixThresholdExceeded=cbgpPrefixThresholdExceeded, cbgpPrefixThresholdClear=cbgpPrefixThresholdClear)

# Groups
mibBuilder.exportSymbols("CISCO-BGP4-MIB", ciscoBgp4RouteGroup=ciscoBgp4RouteGroup, ciscoBgp4PeerGroup=ciscoBgp4PeerGroup, ciscoBgp4NotificationsGroup=ciscoBgp4NotificationsGroup, ciscoBgp4PeerGroup1=ciscoBgp4PeerGroup1, ciscoBgp4NotificationsGroup1=ciscoBgp4NotificationsGroup1)

# Compliances
mibBuilder.exportSymbols("CISCO-BGP4-MIB", ciscoBgp4MIBCompliance=ciscoBgp4MIBCompliance, ciscoBgp4MIBComplianceRev1=ciscoBgp4MIBComplianceRev1, ciscoBgp4MIBComplianceRev2=ciscoBgp4MIBComplianceRev2)
