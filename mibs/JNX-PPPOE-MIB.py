# PySNMP SMI module. Autogenerated from smidump -f python JNX-PPPOE-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:55 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InterfaceIndex, InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
( jnxPppoeMibRoot, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxPppoeMibRoot")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( DisplayString, MacAddress, RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "MacAddress", "RowStatus", "TextualConvention", "TruthValue")

# Types

class JnxPPPoEServiceNameAction(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,1,)
    namedValues = NamedValues(("drop", 0), ("terminate", 1), )
    

# Objects

jnxPPPoEMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1)).setRevisions(("2013-06-13 00:00","2010-07-22 09:42","2010-07-22 09:42",))
if mibBuilder.loadTexts: jnxPPPoEMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxPPPoEMIB.setContactInfo("       Juniper Networks, Inc.\nPostal: 10 Technology Park Drive\n        Westford, MA  01886-3146\n        USA\nTel:    +1 978 589 5800\nEmail:  support@Juniper.net")
if mibBuilder.loadTexts: jnxPPPoEMIB.setDescription("The Point-to-Point Protocol over Ethernet (PPPoE) MIB for the Junos\nproduct family.  This MIB contains managed objects for each of\ntwo interface layers: PPPoE interfaces, and PPPoE subinterfaces.  For\neach of these layers, management objects are provided to query for an\navailable interface index, and to create/delete interfaces of that type.")
jnxPPPoEObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1))
jnxPPPoEIfLayer = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1))
jnxPPPoENextIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoENextIfIndex.setDescription("Coordinate ifIndex value allocation for entries in jnxPPPoEIfTable.\n\nA GET of this object returns the next available ifIndex value to be used\nto create an entry in the associated interface table; or zero, if no\nvalid ifIndex value is available.  This object also returns a value of\nzero when it is the lexicographic successor of a varbind presented in an\nSNMP GETNEXT or GETBULK request, for which circumstance it is assumed\nthat ifIndex allocation is unintended.\n\nSuccessive GETs will typically return different values, thus avoiding\ncollisions among cooperating management clients seeking to create table\nentries simultaneously.")
jnxPPPoEIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2))
if mibBuilder.loadTexts: jnxPPPoEIfTable.setDescription("The parameters for the PPPoEservice on this interface.")
jnxPPPoEIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEIfIfIndex"))
if mibBuilder.loadTexts: jnxPPPoEIfEntry.setDescription("The Parameters for a particular PPPoEinterface.\n\nCreating/deleting entries in this table causes corresponding entries for\nbe created/deleted in ifTable/ifXTable/jnxIfTable, and\njnxPPPoEIfStatsTable.")
jnxPPPoEIfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoEIfIfIndex.setDescription("The ifIndex value of the corresponding ifEntry.")
jnxPPPoEIfMaxNumSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65335)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfMaxNumSessions.setDescription("The number of sessions allowed on the PPPoEinterface, zero indicates\nunlimited.")
jnxPPPoEIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 3), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfRowStatus.setDescription("Controls creation/deletion of entries in this table with READ-CREATE\nmaximum access, according to the\nRowStatus textual convention, constrained to support the following\nvalues only:\n   createAndGo\n   destroy\n\nTo create an entry in this table, the following entry objects MUST be\nexplicitly configured:\n   jnxPPPoEIfRowStatus\n   jnxPPPoEIfLowerIfIndex\n\nIn addition, when creating an entry the following conditions must hold:\n   A value for jnxPPPoEIfIndex must have been determined previously,\n   by reading jnxPPPoENextIfIndex.\n\n   The interface identified by jnxPPPoEIfLowerIfIndex must exist, and\n   must be an interface type that permits layering of PPPoEabove it.\n\nA corresponding entry in ifTable/ifXTable/jnxIfTable is created or\ndestroyed as a result of creating or destroying an entry in this table.\n\nThe following values can be read from this object:\n    active(1)")
jnxPPPoEIfLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLowerIfIndex.setDescription("The ifIndex of an interface over which this PPPoEinterface is to be\nlayered.  A value of zero indicates no layering.  An implementation may\nchoose to require that a nonzero value be configured at entry creation.")
jnxPPPoEIfAcName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfAcName.setDescription("The name to use for the AC-NAME tag that is sent in any PADO that is\nsent on this interface.")
jnxPPPoEIfDupProtect = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfDupProtect.setDescription("Flag to allow duplicate MAC addresses.")
jnxPPPoEIfPADIFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfPADIFlag.setDescription("This flag controls whether we always respond to a PADI with a PADO\nregardless of the ability to create the session and allows the session\nestablish phase to resolve it.")
jnxPPPoEIfAutoconfig = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfAutoconfig.setDescription("This flags determines whether the upper PPPoEinterface is created\ndynamically or statically.  When enable(1) the interface is created\ndynamically.")
jnxPPPoEIfServiceNameTable = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfServiceNameTable.setDescription("Associate a PPPoEService Name Table with this interface for PADI\nprocessing.")
jnxPPPoEIfPadrRemoteCircuitIdCapture = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfPadrRemoteCircuitIdCapture.setDescription("This flags determines whether the remote circuit id string will\nbe captured and subsequently used as the NAS-PORT-ID radius\nattribute when it arrives as a tag in the PADR packet.")
jnxPPPoEIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1,2),ValueRangeConstraint(66,65535),)).clone(1494)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfMtu.setDescription("The initial Maximum Transmit Unit (MTU) that the PPPoEmajor interface\nentity will advertise to the remote entity.\n\nIf the value of this variable is 1 then the local PPPoEentity will\nuse an MTU value determined by its underlying media interface.\n\nIf the value of this variable is 2 then the local PPPoEentity will\nuse a value determined by the PPPoEMax-Mtu-Tag transmitted from the\nclient in the PADR packet.  If no Max-Mtu-Tag is received, the value\ndefaults to a maximum of 1494.\n\n		The operational MTU is limited by the MTU of the underlying media\ninterface minus the PPPoEframe overhead.")
jnxPPPoEIfLockoutMin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutMin.setDescription("The lower bound, in seconds, of the time range used to specify \nthe duration of the lockout of the client from recognition for\nthe specified interface.  This only takes effect if\njnxPPPoEIfAutoconfig is set for this interface.\n\nThe ability to lockout the client in the event of an error in\ncreating a PPP interface is enabled by default.  The initial lockout\nduration is this object's value and increases exponentially for\neach failure that occurs for the client creating a PPP interface\nfor the PPPoEinterface within the greater of 15 minutes\nand jnxPPPoEIfLockoutMax.\n\nThe lockout duration for the client will not exceed jnxPPPoEIfLockoutMax.\nIf the time between creation errors for the PPP interface for this\ninterface is greater than the greater of 15 minutes and\njnxPPPoEIfLockoutMax, then the lockout duration reverts to this\nobject's value.\n\n\nTo disable the ability to lockout the client from recognition in the\nevent of an error in creating a PPP interface for the specified interface,\nthe value of this object and jnxPPPoEIfLockoutMin must be set to 0.\nIt is not recommended that this lockout feature be disabled except for \ndebugging purposes or when this interface supports more than one session.")
jnxPPPoEIfLockoutMax = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutMax.setDescription("The upper bound, in seconds, of the time range used to specify \nthe duration of the lockout of the client from recognition for\nthe specified interface.  This only takes effect if\njnxPPPoEIfAutoconfig is set for this interface.\n\nThe ability to lockout the client from recognition in the event\nof an error in creating a PPP interface is enabled by default.\nThe initial lockout duration is jnxPPPoEIfLockoutMin and\nincreases exponentially for each failure that occurs for the client\ninterface within the greater of 15 minutes and this object's value.\n\nThe lockout duration for the client will not exceed jnxPPPoEIfLockoutMax.\nIf the time between creation errors for the PPP interface for this\ninterface is greater than the greater of 15 minutes and\njnxPPPoEIfLockoutMax, then the lockout duration reverts to\njnxPPPoEIfLockoutMin.\n\nTo disable the ability to lockout the client from recognition in the\nevent of an error in creating a PPP interface for the specified interface,\nthe value of this object and jnxPPPoEIfLockoutMin must be set to 0.\nIt is not recommended that this lockout feature be disabled except for \ndebugging purposes or when this interface supports more than one session.")
jnxPPPoEIfDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 2, 1, 14), DisplayString().clone(' ')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfDynamicProfile.setDescription("Attach dynamic-profile to this interface")
jnxPPPoEIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3))
if mibBuilder.loadTexts: jnxPPPoEIfStatsTable.setDescription("The statistics for the PPP over Ethernet Interface for the PPPoE\nservice on this interface.")
jnxPPPoEIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEIfIfIndex"))
if mibBuilder.loadTexts: jnxPPPoEIfStatsEntry.setDescription("The statistics for a particular PPPoEInterface.")
jnxPPPoEIfStatsRxPADI = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADI.setDescription("Number of PADI packets received.")
jnxPPPoEIfStatsTxPADO = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADO.setDescription("Number of PADO packets transmitted.")
jnxPPPoEIfStatsRxPADR = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADR.setDescription("Number of PADR packets received.")
jnxPPPoEIfStatsTxPADS = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADS.setDescription("Number of PADS packets transmitted.")
jnxPPPoEIfStatsRxPADT = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxPADT.setDescription("Number of PADT packets received.")
jnxPPPoEIfStatsTxPADT = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADT.setDescription("Number of PADT packets transmitted.")
jnxPPPoEIfStatsRxInvVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvVersion.setDescription("Number of packets received with invalid version.")
jnxPPPoEIfStatsRxInvCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvCode.setDescription("Number of packets received with invalid code.")
jnxPPPoEIfStatsRxInvTags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTags.setDescription("Number of packets received with invalid tags.")
jnxPPPoEIfStatsRxInvSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvSession.setDescription("Number of packets received with invalid session identifiers.\n\nThis object became obsolete when separate counters were added for PADI\nand PADR packets.")
jnxPPPoEIfStatsRxInvTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTypes.setDescription("Number of packets received with invalid types.")
jnxPPPoEIfStatsRxInvPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPackets.setDescription("Number of invalid packets received.")
jnxPPPoEIfStatsRxInsufficientResources = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInsufficientResources.setDescription("Number of session requests that could not be honored due to invalid\nresources.")
jnxPPPoEIfStatsTxPADM = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADM.setDescription("Number of PADM packets transmitted.")
jnxPPPoEIfStatsTxPADN = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsTxPADN.setDescription("Number of PADN packets transmitted.")
jnxPPPoEIfStatsRxInvTagLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvTagLength.setDescription("Number of packets received with invalid tag length.")
jnxPPPoEIfStatsRxInvLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvLength.setDescription("Number of packets received with invalid length.")
jnxPPPoEIfStatsRxInvPadISession = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPadISession.setDescription("Number of PADI packets received with invalid session identifiers.")
jnxPPPoEIfStatsRxInvPadRSession = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfStatsRxInvPadRSession.setDescription("Number of PADR packets received with invalid session identifiers.")
jnxPPPoEIfLockoutTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4))
if mibBuilder.loadTexts: jnxPPPoEIfLockoutTable.setDescription("The lockout configuration and state of a PPPoEclient on this interface.")
jnxPPPoEIfLockoutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEIfIfIndex"), (0, "JNX-PPPOE-MIB", "jnxPPPoEIfLockoutClientAddress"))
if mibBuilder.loadTexts: jnxPPPoEIfLockoutEntry.setDescription("Each entry contains the configuration and state of a particular\nPPPoEinterface client lockout.")
jnxPPPoEIfLockoutClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 1), MacAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutClientAddress.setDescription("The source MAC address if the client.")
jnxPPPoEIfLockoutTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutTime.setDescription("The time duration, in seconds, currently used to lockout the\nspecified encapsulation type from recognition for the specified\ninterface.  The reported value is within the range specified by\njnxPPPoEIfLockoutMin and jnxPPPoEIfLockoutMax.  A value of 0 \nindicates that no lockout is occurring for the encapsulation type\nfor the specified interface.")
jnxPPPoEIfLockoutElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutElapsedTime.setDescription("The elapsed time, in seconds, that the specified encapsulation type\nhas been locked-out from recognition for the specified interface. \nIts value will not exceed that of jnxPPPoEIfLockoutTime.  A value of \n0 indicates that no lockout is occurring for the encapsulation type\nfor the specified interface.")
jnxPPPoEIfLockoutNextTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEIfLockoutNextTime.setDescription("The time duration, in seconds, that will be used to lockout the \nspecified encapsulation type from recognition for the specified\ninterface for the next event that results in a lockout condition.\nThe reported value is within the range specified by\njnxPPPoEIfLockoutMin and jnxPPPoEIfLockoutMax.  When\njnxPPPoEIfEnable is set to enable, a value of 0 indicates that\nlockout is prevented from occurring for the encapsulation type\nfor the specified interface (i.e., jnxPPPoEIfLockoutMin and\njnxPPPoEIfLockoutMax are both set to 0).")
jnxPPPoESubIfLayer = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2))
jnxPPPoESubIfNextIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 1), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfNextIfIndex.setDescription("Coordinate ifIndex value allocation for entries in jnxPPPoESubIfTable.\n\nA GET of this object returns the next available ifIndex value to be used\nto create an entry in the associated interface table; or zero, if no\nvalid ifIndex value is available.  This object also returns a value of\nzero when it is the lexicographic successor of a varbind presented in an\nSNMP GETNEXT or GETBULK request, for which circumstance it is assumed\nthat ifIndex allocation is unintended.\n\nSuccessive GETs will typically return different values, thus avoiding\ncollisions among cooperating management clients seeking to create table\nentries simultaneously.")
jnxPPPoESubIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2))
if mibBuilder.loadTexts: jnxPPPoESubIfTable.setDescription("This table contains entries for PPPoESubinterfaces present in the\nsystem.")
jnxPPPoESubIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoESubIfIndex"))
if mibBuilder.loadTexts: jnxPPPoESubIfEntry.setDescription("Each entry describes the characteristics of a PPPoESubinterface.\nWith READ-CREATE maximum access ,creating/deleting entries in this \ntable causes corresponding entries for\nbe created /deleted in ifTable/ifXTable/jnxIfTable.")
jnxPPPoESubIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoESubIfIndex.setDescription("The ifIndex of the PPPoESubinterface.  When creating entries in this\ntable, suitable values for this object are determined by reading\njnxPPPoESubNextIfIndex.")
jnxPPPoESubIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfRowStatus.setDescription("Controls creation/deletion of entries in this table with READ-CREATE\nmaximum access ,according to the\nRowStatus textual convention, constrained to support the following\nvalues only:\n   createAndGo\n   destroy\n\nTo create an entry in this table, the following entry objects MUST be\nexplicitly configured:\n   jnxPPPoESubIfRowStatus\n   jnxPPPoESubIfLowerIfIndex\n\nIn addition, when creating an entry the following conditions must hold:\n   A value for jnxPPPoESubIfIndex must have been determined\n   previously, by reading jnxPPPoESubIfNextIfIndex.\n\n   The interface identified by jnxPPPoESubIfLowerIfIndex must exist,\n   and must be a PPPoEinterface.\n\n   A positive value configured for jnxPPPoESubIfId must not already be\n   assigned to another subinterface layered onto the same underlying\n   PPPoEinterface.\n\nA corresponding entry in ifTable/ifXTable/jnxIfTable is created or\ndestroyed as a result of creating or destroying an entry in this table.\n\nThe following values can be read from this object:\n    active(1) ")
jnxPPPoESubIfLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfLowerIfIndex.setDescription("The ifIndex of a PPPoEinterface over which this PPPoESubinterface is\nto be layered.  A value of zero indicates no layering.  An\nimplementation may choose to require that a nonzero value be configured\nat entry creation.")
jnxPPPoESubIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfId.setDescription("An integer identifier for the PPPoEsubinterface, used in conjunction\nwith the command-line interface.  It is provided here for\ncross-reference purposes only.\n\nThe value must be unique among subinterfaces configured on the same\nunderlying PPPoEinterface.\n\nIf this object is not configured, or is configured with a value of -1, a\nnonzero value will be allocated internally and can be retrieved from\nthis object after table entry creation has succeeded.\n\nA value of zero for this object is reserved for future use.")
jnxPPPoESubIfSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfSessionId.setDescription("The current sessionId associated with this sub-interface.")
jnxPPPoESubIfMotm = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfMotm.setDescription("A message to send via a PADM on the sub-interface when the\nsub-interface transitions to the ifOperStatusUp state.  The client may\nchoose to display this message to the user.")
jnxPPPoESubIfUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESubIfUrl.setDescription("A URL to be sent via a PADM on the sub-interface when the sub-interface\ntransitions to the ifOperStatusUp state.  The client may use this URL as\nthe initial web-page for the user.")
jnxPppoeSubIfQueueStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3))
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsTable.setDescription("Table containing the Queue parameters for the PPPoEsessions.")
jnxPppoeSubIfPerQueueStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoESubIfIndex"), (0, "JNX-PPPOE-MIB", "jnxPppoeSubIfQueueIndex"))
if mibBuilder.loadTexts: jnxPppoeSubIfPerQueueStatsEntry.setDescription("The statistics for a particular trrafic class queue for \nPPPoEsub Interface(i.e. session). ). Forwarding class to\n queue number mapping is not always one-to-one. Forwarding\n  classes and queues are the same only when default \n  forwarding-class-to-queue mapping is in effect ")
jnxPppoeSubIfQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueIndex.setDescription("This attribute returns the queue index ranging from 0 to 7 of the\nqueue configure on the PPPoEsubinterface to support the traffic class for \nPPPoEsession configured on that subinterface. Forwarding class to queue\nnumber mapping is not always one-to-one. Forwarding classes and queues are\n the same only when default forwarding-class-to-queue mapping is in effect.")
jnxPppoeSubIfQueueStatsPacketSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsPacketSent.setDescription("This attribute returns the counts of number of packet sent\nper PPPoEsession and per queue.")
jnxPppoeSubIfQueueStatsBytesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsBytesSent.setDescription("This attribute returns the counts of number of bytes sent \nper PPPoEsession and per queue.")
jnxPppoeSubIfQueueStatsPacketDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsPacketDropped.setDescription("This attribute returns the number of packet dropped per \nPPPoEsession and per queue.")
jnxPppoeSubIfQueueStatsBytesDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsBytesDropped.setDescription("This attribute returns the number of bytes dropped per \nPPPoEsession and per queue.")
jnxPppoeSubIfQueueStatsActualBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsActualBitRate.setDescription("This attribute returns the actual bit rate for per\nPPPoEsession and per queue.")
jnxPppoeSubIfQueueStatsActualDroppedBitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 2, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppoeSubIfQueueStatsActualDroppedBitRate.setDescription("This attribute returns the actual dropped bit rate for per \nPPPoEsession and per queue.")
jnxPPPoESummary = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3))
jnxPPPoEMajorInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEMajorInterfaceCount.setDescription("The total number of PPPoEmajor interfaces configured and created in\nthe system.")
jnxPPPoESummaryMajorIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminUp.setDescription("The total number of PPPoEmajor interfaces in the system that are\nadministratively configured to up(1).")
jnxPPPoESummaryMajorIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfAdminDown.setDescription("The total number of PPPoEmajor interfaces in the system that are\nadministrateively configued to down(2).")
jnxPPPoESummaryMajorIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperUp.setDescription("The total number of PPPoEmajor interfaces in the system with an\noperational state of up(1).")
jnxPPPoESummaryMajorIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfOperDown.setDescription("The total number of PPPoEmajor interfaces in the system with an\noperational state of down(2).")
jnxPPPoESummaryMajorIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfLowerLayerDown.setDescription("The total number of PPPoEmajor interfaces in the system with an\noperational state of lowerLayerDown(7).")
jnxPPPoESummaryMajorIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummaryMajorIfNotPresent.setDescription("The total number of PPPoEmajor interfaces in the system with an\noperational state of notPresent(6).")
jnxPPPoESummarySubInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubInterfaceCount.setDescription("The total number of PPPoEsubinterfaces configured in the system.")
jnxPPPoESummarySubIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminUp.setDescription("The total number of PPPoEsubinterfaces in the system that are\nadministratively configured to up(1).")
jnxPPPoESummarySubIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfAdminDown.setDescription("The total number of PPPoEsubinterfaces in the system that are\nadministrateively configued to down(2).")
jnxPPPoESummarySubIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperUp.setDescription("The total number of PPPoEsubinterfaces in the system with an\noperational state of up(1).")
jnxPPPoESummarySubIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfOperDown.setDescription("The total number of PPPoEsubinterfaces in the system with an\noperational state of down(2).")
jnxPPPoESummarySubIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfLowerLayerDown.setDescription("The total number of PPPoEsubinterfaces in the system with an\noperational state of lowerLayerDown(7).")
jnxPPPoESummarySubIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoESummarySubIfNotPresent.setDescription("The total number of PPPoEsubinterfaces in the system with an\noperational state of notPresent(6).")
jnxPPPoEServices = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4))
jnxPPPoEServiceNameTableTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1))
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableTable.setDescription("This table contains entries for the PPPoEService-name tables.")
jnxPPPoEServiceNameTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameTableName"))
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableEntry.setDescription("The parameters for the PPPoEservice-name table.")
jnxPPPoEServiceNameTableName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableName.setDescription("Service-name table name.")
jnxPPPoEServiceNameTableRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 1, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameTableRowStatus.setDescription("Controls creation/deletion of entries in this table with READ-CREATE\nmaximum access,according to the\nRowStatus textual convention, constrained to support the following\nvalues only:\n   createAndGo\n   destroy\n\nTo create an entry in this table, the following entry objects MUST be\nexplicitly configured:\n   jnxPPPoEServiceNameTableRowStatus\n   jnxPPPoEServiceNameTableName\n  \n\nThe Empty Service and  Any  service will be automatically configured \nfor each Service Name Table created. On creating or deleting an entry in \nthis table will create/destroy an entry for <Empty >Service and <Any> \nservice in jnxServiceNameTable.\n\nA corresponding entry in jnxServiceNameTable gets created or destroyed\nas a result of creating or destroying an entry in this table.\nThe following values can be read from this object:\n    active(1) ")
jnxPPPoEServiceNameTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2))
if mibBuilder.loadTexts: jnxPPPoEServiceNameTable.setDescription("This table contains entries for the PPPoEService-names.")
jnxPPPoEServiceNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameTableName"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceName"))
if mibBuilder.loadTexts: jnxPPPoEServiceNameEntry.setDescription("The parameters for the PPPoEservice-name table entry.")
jnxPPPoEServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoEServiceName.setDescription("Service-name tag value.")
jnxPPPoEServiceNameAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 2), JnxPPPoEServiceNameAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAction.setDescription("Identifies the behavior when the the Service-name tag is received in a\nPADI frame.")
jnxPPPoEServiceNameDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameDynamicProfile.setDescription("Dynamic Profile associated with a Service-name.")
jnxPPPoEServiceNameRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameRoutingInstance.setDescription("Routing Instance associated with a Service-name.")
jnxPPPoEServiceNameMaxSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameMaxSessions.setDescription("The Max Sessions value used to cap the number of active PPPoEssessions \nthat may be established with the specified Service entry.")
jnxPPPoEServiceNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 2, 1, 6), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameRowStatus.setDescription("Controls creation/deletion of entries in this table with READ-CREATE \nmaximum access  ,according to the\nRowStatus textual convention, constrained to support the following\nvalues only:\n    createAndGo\n    destroy\n\nTo create an entry in this table, the following entry objects MUST be\nexplicitly configured:\n    jnxPPPoEServiceNameRowStatus\n\nThe Service name is configured via the INDEX specified.\n\nA corresponding entry in jnxPPPoEServiceNameAciAriTable is destroyed\nas a result of destroying an entry in this table.\n\nThe following values can be read from this object:\n     active(1)")
jnxPPPoEServiceNameAciAriTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3))
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriTable.setDescription("This table contains entries for the PPPoEServicename AciAri entries.")
jnxPPPoEServiceNameAciAriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1)).setIndexNames((0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameTableName"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceName"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameAgentCircuitId"), (0, "JNX-PPPOE-MIB", "jnxPPPoEServiceNameAgentRemoteId"))
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriEntry.setDescription("The parameters for the PPPoEservice-name AciAri table entry.")
jnxPPPoEServiceNameAgentCircuitId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAgentCircuitId.setDescription("ACI tag values that the PPPoEclient would send in the PADI/PADR \ncontrol packet.")
jnxPPPoEServiceNameAgentRemoteId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAgentRemoteId.setDescription("ACI tag values that the PPPoEclient would send in the PADI/PADR \ncontrol packet.")
jnxPPPoEServiceNameAciAriAction = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 3), JnxPPPoEServiceNameAction()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriAction.setDescription("Identifies the behavior when the the Service-name with ACI/ARI pairs \nis received in a PADI frame.")
jnxPPPoEServiceNameAciAriDynamicProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriDynamicProfile.setDescription("Dynamic Profile associated with a Service-name and ACI/ARI pairs")
jnxPPPoEServiceNameAciAriRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriRoutingInstance.setDescription("Routing-Instance associated with a Service-name and ACI/ARI pairs")
jnxPPPoEServiceNameAciAriStaticInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriStaticInterface.setDescription("Static Interface associated with each ACI/ARI Entry.")
jnxPPPoEServiceNameAciAriRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 1, 4, 3, 1, 7), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPPPoEServiceNameAciAriRowStatus.setDescription("Controls creation/deletion of entries in this table with READ-CREATE\nmaximum access, according to the\nRowStatus textual convention, constrained to support the following\nvalues only:\n   createAndGo\n   destroy\n\nTo create an entry in this table, the following entry objects MUST be\nexplicitly configured:\n   jnxPPPoEServiceNameAciAriRowStatus\n\nThe ACIARI Entry is configured via the INDEX specified.\n\nThe following values can be read from this object:\n    active(1)")
jnxPPPoEConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 4))
jnxPPPoECompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 4, 1))
jnxPPPoEGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 67, 1, 4, 2))

# Augmentions

# Exports

# Module identity
mibBuilder.exportSymbols("JNX-PPPOE-MIB", PYSNMP_MODULE_ID=jnxPPPoEMIB)

# Types
mibBuilder.exportSymbols("JNX-PPPOE-MIB", JnxPPPoEServiceNameAction=JnxPPPoEServiceNameAction)

# Objects
mibBuilder.exportSymbols("JNX-PPPOE-MIB", jnxPPPoEMIB=jnxPPPoEMIB, jnxPPPoEObjects=jnxPPPoEObjects, jnxPPPoEIfLayer=jnxPPPoEIfLayer, jnxPPPoENextIfIndex=jnxPPPoENextIfIndex, jnxPPPoEIfTable=jnxPPPoEIfTable, jnxPPPoEIfEntry=jnxPPPoEIfEntry, jnxPPPoEIfIfIndex=jnxPPPoEIfIfIndex, jnxPPPoEIfMaxNumSessions=jnxPPPoEIfMaxNumSessions, jnxPPPoEIfRowStatus=jnxPPPoEIfRowStatus, jnxPPPoEIfLowerIfIndex=jnxPPPoEIfLowerIfIndex, jnxPPPoEIfAcName=jnxPPPoEIfAcName, jnxPPPoEIfDupProtect=jnxPPPoEIfDupProtect, jnxPPPoEIfPADIFlag=jnxPPPoEIfPADIFlag, jnxPPPoEIfAutoconfig=jnxPPPoEIfAutoconfig, jnxPPPoEIfServiceNameTable=jnxPPPoEIfServiceNameTable, jnxPPPoEIfPadrRemoteCircuitIdCapture=jnxPPPoEIfPadrRemoteCircuitIdCapture, jnxPPPoEIfMtu=jnxPPPoEIfMtu, jnxPPPoEIfLockoutMin=jnxPPPoEIfLockoutMin, jnxPPPoEIfLockoutMax=jnxPPPoEIfLockoutMax, jnxPPPoEIfDynamicProfile=jnxPPPoEIfDynamicProfile, jnxPPPoEIfStatsTable=jnxPPPoEIfStatsTable, jnxPPPoEIfStatsEntry=jnxPPPoEIfStatsEntry, jnxPPPoEIfStatsRxPADI=jnxPPPoEIfStatsRxPADI, jnxPPPoEIfStatsTxPADO=jnxPPPoEIfStatsTxPADO, jnxPPPoEIfStatsRxPADR=jnxPPPoEIfStatsRxPADR, jnxPPPoEIfStatsTxPADS=jnxPPPoEIfStatsTxPADS, jnxPPPoEIfStatsRxPADT=jnxPPPoEIfStatsRxPADT, jnxPPPoEIfStatsTxPADT=jnxPPPoEIfStatsTxPADT, jnxPPPoEIfStatsRxInvVersion=jnxPPPoEIfStatsRxInvVersion, jnxPPPoEIfStatsRxInvCode=jnxPPPoEIfStatsRxInvCode, jnxPPPoEIfStatsRxInvTags=jnxPPPoEIfStatsRxInvTags, jnxPPPoEIfStatsRxInvSession=jnxPPPoEIfStatsRxInvSession, jnxPPPoEIfStatsRxInvTypes=jnxPPPoEIfStatsRxInvTypes, jnxPPPoEIfStatsRxInvPackets=jnxPPPoEIfStatsRxInvPackets, jnxPPPoEIfStatsRxInsufficientResources=jnxPPPoEIfStatsRxInsufficientResources, jnxPPPoEIfStatsTxPADM=jnxPPPoEIfStatsTxPADM, jnxPPPoEIfStatsTxPADN=jnxPPPoEIfStatsTxPADN, jnxPPPoEIfStatsRxInvTagLength=jnxPPPoEIfStatsRxInvTagLength, jnxPPPoEIfStatsRxInvLength=jnxPPPoEIfStatsRxInvLength, jnxPPPoEIfStatsRxInvPadISession=jnxPPPoEIfStatsRxInvPadISession, jnxPPPoEIfStatsRxInvPadRSession=jnxPPPoEIfStatsRxInvPadRSession, jnxPPPoEIfLockoutTable=jnxPPPoEIfLockoutTable, jnxPPPoEIfLockoutEntry=jnxPPPoEIfLockoutEntry, jnxPPPoEIfLockoutClientAddress=jnxPPPoEIfLockoutClientAddress, jnxPPPoEIfLockoutTime=jnxPPPoEIfLockoutTime, jnxPPPoEIfLockoutElapsedTime=jnxPPPoEIfLockoutElapsedTime, jnxPPPoEIfLockoutNextTime=jnxPPPoEIfLockoutNextTime, jnxPPPoESubIfLayer=jnxPPPoESubIfLayer, jnxPPPoESubIfNextIfIndex=jnxPPPoESubIfNextIfIndex, jnxPPPoESubIfTable=jnxPPPoESubIfTable, jnxPPPoESubIfEntry=jnxPPPoESubIfEntry, jnxPPPoESubIfIndex=jnxPPPoESubIfIndex, jnxPPPoESubIfRowStatus=jnxPPPoESubIfRowStatus, jnxPPPoESubIfLowerIfIndex=jnxPPPoESubIfLowerIfIndex, jnxPPPoESubIfId=jnxPPPoESubIfId, jnxPPPoESubIfSessionId=jnxPPPoESubIfSessionId, jnxPPPoESubIfMotm=jnxPPPoESubIfMotm, jnxPPPoESubIfUrl=jnxPPPoESubIfUrl, jnxPppoeSubIfQueueStatsTable=jnxPppoeSubIfQueueStatsTable, jnxPppoeSubIfPerQueueStatsEntry=jnxPppoeSubIfPerQueueStatsEntry, jnxPppoeSubIfQueueIndex=jnxPppoeSubIfQueueIndex, jnxPppoeSubIfQueueStatsPacketSent=jnxPppoeSubIfQueueStatsPacketSent, jnxPppoeSubIfQueueStatsBytesSent=jnxPppoeSubIfQueueStatsBytesSent, jnxPppoeSubIfQueueStatsPacketDropped=jnxPppoeSubIfQueueStatsPacketDropped, jnxPppoeSubIfQueueStatsBytesDropped=jnxPppoeSubIfQueueStatsBytesDropped, jnxPppoeSubIfQueueStatsActualBitRate=jnxPppoeSubIfQueueStatsActualBitRate, jnxPppoeSubIfQueueStatsActualDroppedBitRate=jnxPppoeSubIfQueueStatsActualDroppedBitRate, jnxPPPoESummary=jnxPPPoESummary, jnxPPPoEMajorInterfaceCount=jnxPPPoEMajorInterfaceCount, jnxPPPoESummaryMajorIfAdminUp=jnxPPPoESummaryMajorIfAdminUp, jnxPPPoESummaryMajorIfAdminDown=jnxPPPoESummaryMajorIfAdminDown, jnxPPPoESummaryMajorIfOperUp=jnxPPPoESummaryMajorIfOperUp, jnxPPPoESummaryMajorIfOperDown=jnxPPPoESummaryMajorIfOperDown, jnxPPPoESummaryMajorIfLowerLayerDown=jnxPPPoESummaryMajorIfLowerLayerDown, jnxPPPoESummaryMajorIfNotPresent=jnxPPPoESummaryMajorIfNotPresent, jnxPPPoESummarySubInterfaceCount=jnxPPPoESummarySubInterfaceCount, jnxPPPoESummarySubIfAdminUp=jnxPPPoESummarySubIfAdminUp, jnxPPPoESummarySubIfAdminDown=jnxPPPoESummarySubIfAdminDown, jnxPPPoESummarySubIfOperUp=jnxPPPoESummarySubIfOperUp, jnxPPPoESummarySubIfOperDown=jnxPPPoESummarySubIfOperDown, jnxPPPoESummarySubIfLowerLayerDown=jnxPPPoESummarySubIfLowerLayerDown, jnxPPPoESummarySubIfNotPresent=jnxPPPoESummarySubIfNotPresent, jnxPPPoEServices=jnxPPPoEServices, jnxPPPoEServiceNameTableTable=jnxPPPoEServiceNameTableTable, jnxPPPoEServiceNameTableEntry=jnxPPPoEServiceNameTableEntry, jnxPPPoEServiceNameTableName=jnxPPPoEServiceNameTableName, jnxPPPoEServiceNameTableRowStatus=jnxPPPoEServiceNameTableRowStatus, jnxPPPoEServiceNameTable=jnxPPPoEServiceNameTable, jnxPPPoEServiceNameEntry=jnxPPPoEServiceNameEntry, jnxPPPoEServiceName=jnxPPPoEServiceName, jnxPPPoEServiceNameAction=jnxPPPoEServiceNameAction, jnxPPPoEServiceNameDynamicProfile=jnxPPPoEServiceNameDynamicProfile, jnxPPPoEServiceNameRoutingInstance=jnxPPPoEServiceNameRoutingInstance, jnxPPPoEServiceNameMaxSessions=jnxPPPoEServiceNameMaxSessions, jnxPPPoEServiceNameRowStatus=jnxPPPoEServiceNameRowStatus, jnxPPPoEServiceNameAciAriTable=jnxPPPoEServiceNameAciAriTable, jnxPPPoEServiceNameAciAriEntry=jnxPPPoEServiceNameAciAriEntry, jnxPPPoEServiceNameAgentCircuitId=jnxPPPoEServiceNameAgentCircuitId, jnxPPPoEServiceNameAgentRemoteId=jnxPPPoEServiceNameAgentRemoteId, jnxPPPoEServiceNameAciAriAction=jnxPPPoEServiceNameAciAriAction, jnxPPPoEServiceNameAciAriDynamicProfile=jnxPPPoEServiceNameAciAriDynamicProfile, jnxPPPoEServiceNameAciAriRoutingInstance=jnxPPPoEServiceNameAciAriRoutingInstance, jnxPPPoEServiceNameAciAriStaticInterface=jnxPPPoEServiceNameAciAriStaticInterface, jnxPPPoEServiceNameAciAriRowStatus=jnxPPPoEServiceNameAciAriRowStatus, jnxPPPoEConformance=jnxPPPoEConformance, jnxPPPoECompliances=jnxPPPoECompliances, jnxPPPoEGroups=jnxPPPoEGroups)

