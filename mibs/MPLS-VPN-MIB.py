# PySNMP SMI module. Autogenerated from smidump -f python MPLS-VPN-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:58:05 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( bgp4PathAttrIpAddrPrefix, bgp4PathAttrIpAddrPrefixLen, bgp4PathAttrPeer, ) = mibBuilder.importSymbols("BGP4-MIB", "bgp4PathAttrIpAddrPrefix", "bgp4PathAttrIpAddrPrefixLen", "bgp4PathAttrPeer")
( InterfaceIndex, InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, experimental, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "experimental")
( DisplayString, RowStatus, StorageType, TextualConvention, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "StorageType", "TextualConvention", "TimeStamp", "TruthValue")
( VPNId, ) = mibBuilder.importSymbols("VPN-TC-STD-MIB", "VPNId")

# Types

class MplsVpnName(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,31)
    
class MplsVpnRouteDistinguisher(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,256)
    

# Objects

mplsVpnMIB = ModuleIdentity((1, 3, 6, 1, 3, 118)).setRevisions(("2011-03-26 12:00","2002-01-26 12:00","2001-11-13 12:00","2001-10-15 12:00","2001-10-05 12:00","2001-07-17 12:00","2001-07-10 12:00","2001-06-19 12:00","2001-05-30 12:00","2001-02-28 12:00","2000-09-30 12:00",))
if mibBuilder.loadTexts: mplsVpnMIB.setOrganization("Provider Provisioned Virtual Private\nNetworks Working Group.")
if mibBuilder.loadTexts: mplsVpnMIB.setContactInfo("        Thomas D. Nadeau\ntnadeau@cisco.com\n\nLuyuan Fang\nluyuanfang@att.com\n\nStephen Brannon\n\nFabio M. Chiussi\nfabio@bell-labs.com\n\nJoseph Dube\njdube@avici.com\n\nMartin Tatham\nmartin.tatham@bt.com\n\nHarmen van der Linde\nhvdl@att.com\n\nComments and discussion to ppvpn@ietf.org")
if mibBuilder.loadTexts: mplsVpnMIB.setDescription("This MIB contains managed object definitions for the\nMultiprotocol Label Switching (MPLS)/Border Gateway\nProtocol (BGP) Virtual Private Networks (VPNs) as\ndefined in : Rosen, E., Viswanathan, A., and R.\nCallon, Multiprotocol Label Switching Architecture,\nRFC3031, January 2001.")
mplsVpnNotifications = MibIdentifier((1, 3, 6, 1, 3, 118, 0))
mplsVpnObjects = MibIdentifier((1, 3, 6, 1, 3, 118, 1))
mplsVpnScalars = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 1))
mplsVpnConfiguredVrfs = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnConfiguredVrfs.setDescription("The number of VRFs which are configured on this node.")
mplsVpnActiveVrfs = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnActiveVrfs.setDescription("The number of VRFs which are active on this node.\nThat is, those VRFs whose corresponding mplsVpnVrfOperStatus \nobject value is equal to operational (1).")
mplsVpnConnectedInterfaces = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnConnectedInterfaces.setDescription("Total number of interfaces connected to a VRF.")
mplsVpnNotificationEnable = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsVpnNotificationEnable.setDescription("If this object is true, then it enables the\ngeneration of all notifications defined in \nthis MIB.")
mplsVpnVrfConfMaxPossibleRoutes = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfMaxPossibleRoutes.setDescription("Denotes maximum number of routes which the device\nwill allow all VRFs jointly to hold. If this value is\nset to 0, this indicates that the device is \nunable to determine the absolute maximum. In this\ncase, the configured maximum MAY not actually\nbe allowed by the device.")
mplsVpnVrfConfRouteMaxThreshTime = MibScalar((1, 3, 6, 1, 3, 118, 1, 1, 6), Unsigned32().clone(600)).setMaxAccess("readonly").setUnits("seconds")
if mibBuilder.loadTexts: mplsVpnVrfConfRouteMaxThreshTime.setDescription("Denotes the interval in seconds, at which the route max threshold \nnotification will be re-issued after the maximum value has been exceeded\n(or has been reached if mplsVpnVrfConfMaxRoutes and \nmplsVpnVrfConfHighRouteThreshold are equal) and the initial\nnotification has been issued. This value is intended to prevent continuous \ngeneration of notifications by an agent in the event that routes are \ncontinually added to a VRF after it has reached its maximum value. The \ndefault value is 10 minutes (600 seconds). If this value is set to 0, the agent \nshould only issue a single notification at the time that the maxium threshold \nhas been reached, and should not issue any more notifications until the value\nof routes has fallen below the configured threshold value.")
mplsVpnConf = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 2))
mplsVpnIfConfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 1))
if mibBuilder.loadTexts: mplsVpnIfConfTable.setDescription("This table specifies per-interface MPLS capability\nand associated information.")
mplsVpnIfConfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 1, 1)).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnIfConfIndex"))
if mibBuilder.loadTexts: mplsVpnIfConfEntry.setDescription("An entry in this table is created by an LSR for\nevery interface capable of supporting MPLS/BGP VPN.\nEach entry in this table is meant to correspond to\nan entry in the Interfaces Table.")
mplsVpnIfConfIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnIfConfIndex.setDescription("This is a unique index for an entry in the\nMplsVPNInterfaceConfTable. A non-zero index for an\nentry indicates the ifIndex for the corresponding\ninterface entry in the MPLS-VPN-layer in the ifTable.\nNote that this table does not necessarily correspond\none-to-one with all entries in the Interface MIB\nhaving an ifType of MPLS-layer; rather, only those\nwhich are enabled for MPLS/BGP VPN functionality.")
mplsVpnIfLabelEdgeType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("providerEdge", 1), ("customerEdge", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnIfLabelEdgeType.setDescription("Either the providerEdge(0) (PE) or customerEdge(1)\n(CE) bit MUST be set.")
mplsVpnIfVpnClassification = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("carrierOfCarrier", 1), ("enterprise", 2), ("interProvider", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfVpnClassification.setDescription("Denotes whether this link participates in a\ncarrier-of-carrier's, enterprise, or inter-provider\nscenario.")
mplsVpnIfVpnRouteDistProtocol = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 4), Bits().subtype(namedValues=NamedValues(("none", 0), ("bgp", 1), ("ospf", 2), ("rip", 3), ("isis", 4), ("other", 5), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfVpnRouteDistProtocol.setDescription("Denotes the route distribution protocol across the\nPE-CE link. Note that more than one routing protocol\nmay be enabled at the same time.")
mplsVpnIfConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfConfStorageType.setDescription("The storage type for this entry.")
mplsVpnIfConfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnIfConfRowStatus.setDescription("The row status for this entry. This value is\nused to create a row in this table, signifying\nthat the specified interface is to be associated\nwith the specified interface. If this operation\nsucceeds, the interface will have been associated,\notherwise the agent would not allow the association. \nIf the agent only allows read-only operations on\nthis table, it will create entries in this table\nas they are created.")
mplsVpnVrfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 2))
if mibBuilder.loadTexts: mplsVpnVrfTable.setDescription("This table specifies per-interface MPLS/BGP VPN\nVRF Table capability and associated information.\nEntries in this table define VRF routing instances\nassociated with MPLS/VPN interfaces. Note that\nmultiple interfaces can belong to the same VRF\ninstance. The collection of all VRF instances\ncomprises an actual VPN.")
mplsVpnVrfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 2, 1)).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"))
if mibBuilder.loadTexts: mplsVpnVrfEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS/BGP VPN. The\nindexing provides an ordering of VRFs per-VPN\ninterface.")
mplsVpnVrfName = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 1), MplsVpnName()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfName.setDescription("The human-readable name of this VPN. This MAY\nbe equivalent to the RFC2685 VPN-ID, but may\nalso vary. If it is set to the VPN ID, it MUST\nbe equivalent to the value of mplsVpnVrfVpnId.\nIt is strongly recommended that all sites supporting\nVRFs that are part of the same VPN use the same \nnaming convention for VRFs as well as the same VPN\nID.")
mplsVpnVrfVpnId = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 2), VPNId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfVpnId.setDescription("The VPN ID as specified in RFC 2685. If a VPN ID\nas not been specified for this VRF, then this variable\nSHOULD be set to an empty string.")
mplsVpnVrfDescription = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfDescription.setDescription("The human-readable description of this VRF.")
mplsVpnVrfRouteDistinguisher = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 4), MplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteDistinguisher.setDescription("The route distinguisher for this VRF.")
mplsVpnVrfCreationTime = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfCreationTime.setDescription("The time at which this VRF entry was created.")
mplsVpnVrfOperStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfOperStatus.setDescription("Denotes whether a VRF is operational or not. A VRF is \nup(1) when at least one interface associated with the\nVRF, which ifOperStatus is up(1). A VRF is down(2) when:\n\na. There does not exist at least one interface whose\n   ifOperStatus is up(1).\n\nb. There are no interfaces associated with the VRF.")
mplsVpnVrfActiveInterfaces = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfActiveInterfaces.setDescription("Total number of interfaces connected to this VRF with \nifOperStatus = up(1). \n\nThis counter should be incremented when:\n\na. When the ifOperStatus of one of the connected interfaces \n   changes from down(2) to up(1).\n\nb. When an interface with ifOperStatus = up(1) is connected\n   to this VRF.\n\nThis counter should be decremented when:\n\na. When the ifOperStatus of one of the connected interfaces \n   changes from up(1) to down(2).\n\nb. When one of the connected interfaces with \n   ifOperStatus = up(1) gets disconnected from this VRF.")
mplsVpnVrfAssociatedInterfaces = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfAssociatedInterfaces.setDescription("Total number of interfaces connected to this VRF \n(independent of ifOperStatus type).")
mplsVpnVrfConfMidRouteThreshold = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfMidRouteThreshold.setDescription("Denotes mid-level water marker for the number\nof routes which  this VRF may hold.")
mplsVpnVrfConfHighRouteThreshold = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfHighRouteThreshold.setDescription("Denotes high-level water marker for the number of\nroutes which  this VRF may hold.")
mplsVpnVrfConfMaxRoutes = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfMaxRoutes.setDescription("Denotes maximum number of routes which this VRF is\nconfigured to hold. This value MUST be less than or\nequal to mplsVrfMaxPossibleRoutes unless it is set\nto 0.")
mplsVpnVrfConfLastChanged = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfConfLastChanged.setDescription("The value of sysUpTime at the time of the last\nchange of this table entry, which includes changes of\nVRF parameters defined in this table or addition or\ndeletion of interfaces associated with this VRF.")
mplsVpnVrfConfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.")
mplsVpnVrfConfStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 2, 1, 14), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfConfStorageType.setDescription("The storage type for this entry.")
mplsVpnVrfRouteTargetTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 3))
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetTable.setDescription("This table specifies per-VRF route target association.\nEach entry identifies a connectivity policy supported\nas part of a VPN.")
mplsVpnVrfRouteTargetEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 3, 1)).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTargetIndex"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTargetType"))
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetEntry.setDescription(" An entry in this table is created by an LSR for\neach route target configured for a VRF supporting\na MPLS/BGP VPN instance. The indexing provides an\nordering per-VRF instance.")
mplsVpnVrfRouteTargetIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 2), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetIndex.setDescription("Auxiliary index for route-targets configured for a \nparticular VRF.")
mplsVpnVrfRouteTargetType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("import", 1), ("export", 2), ("both", 3), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetType.setDescription("The route target export distribution type.")
mplsVpnVrfRouteTarget = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 4), MplsVpnRouteDistinguisher()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTarget.setDescription("The route target distribution policy.")
mplsVpnVrfRouteTargetDescr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetDescr.setDescription("Description of the route target.")
mplsVpnVrfRouteTargetRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetRowStatus.setDescription("Row status for this entry.")
mplsVpnVrfBgpNbrAddrTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 4))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrTable.setDescription("Each entry in this table specifies a per-interface \nMPLS/EBGP neighbor.")
mplsVpnVrfBgpNbrAddrEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 4, 1)).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnIfConfIndex"), (0, "MPLS-VPN-MIB", "mplsVpnVrfBgpNbrIndex"))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddrEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS/BGP VPN. The\nindexing provides an ordering of VRFs per-VPN\ninterface.")
mplsVpnVrfBgpNbrIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 1), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrIndex.setDescription("This is a unique tertiary index for an entry in the\nMplsVpnVrfBgpNbrAddrEntry Table.")
mplsVpnVrfBgpNbrRole = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("ce", 1), ("pe", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRole.setDescription("Denotes the role played by this EBGP neighbor\nwith respect to this VRF.")
mplsVpnVrfBgpNbrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrType.setDescription("Denotes the address family of the PE address.")
mplsVpnVrfBgpNbrAddr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrAddr.setDescription("Denotes the EBGP neighbor address.")
mplsVpnVrfBgpNbrRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.")
mplsVpnVrfBgpNbrStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 4, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrStorageType.setDescription("The storage type for this entry.")
mplsVpnVrfBgpNbrPrefixTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 5))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixTable.setDescription("This table specifies per-VRF vpnv4 multi-protocol\nprefixes supported by BGP.")
mplsVpnVrfBgpNbrPrefixEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 5, 1)).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "BGP4-MIB", "bgp4PathAttrIpAddrPrefix"), (0, "BGP4-MIB", "bgp4PathAttrIpAddrPrefixLen"), (0, "BGP4-MIB", "bgp4PathAttrPeer"))
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrPrefixEntry.setDescription("An entry in this table is created by an LSR for\nevery BGP prefix associated with a VRF supporting a \nMPLS/BGP VPN. The indexing provides an ordering of \nBGP prefixes per VRF.")
mplsVpnVrfBgpPAtrPeer = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 1), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrPeer.setDescription("The IP address of the peer where the path\ninformation was learned.")
mplsVpnVrfBgpPAtrIpAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 2), Integer32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrIpAddrPrefixLen.setDescription("Length in bits of the IP address prefix\nin the Network Layer Reachability\nInformation field.")
mplsVpnVrfBgpPAtrIpAddrPrefix = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrIpAddrPrefix.setDescription("An IP address prefix in the Network Layer\nReachability Information field.  This object\nis an IP address containing the prefix with\nlength specified by mplsVpnVrfBgpPAtrIpAddrPrefixLen.\nAny bits beyond the length specified by\nmplsVpnVrfBgpPAtrIpAddrPrefixLen are zeroed.")
mplsVpnVrfBgpPAtrOrigin = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrOrigin.setDescription("The ultimate origin of the path\ninformation.")
mplsVpnVrfBgpPAtrASPathSegment = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrASPathSegment.setDescription("The sequence of AS path segments.  Each AS\npath segment is represented by a triple\n<type, length, value>.\n\n The type is a 1-octet field which has two\n possible values:\n     1      AS_SET: unordered set of ASs a\n            route in the UPDATE\n            message has traversed\n     2      AS_SEQUENCE: ordered set of ASs\n            a route in the UPDATE\n            message has traversed.\n            The length is a 1-octet field containing the\n            number of ASs in the value field.\n\n            The value field contains one or more AS\n            numbers, each AS is represented in the octet\n            string as a pair of octets according to the\n            following algorithm:\n\n            first-byte-of-pair = ASNumber / 256;\n            second-byte-of-pair = ASNumber & 255;")
mplsVpnVrfBgpPAtrNextHop = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrNextHop.setDescription("The address of the border router that\nshould be used for the destination\nnetwork.")
mplsVpnVrfBgpPAtrMultiExitDisc = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrMultiExitDisc.setDescription("This metric is used to discriminate\nbetween multiple exit points to an\nadjacent autonomous system.  A value of -1\nindicates the absence of this attribute.")
mplsVpnVrfBgpPAtrLocalPref = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrLocalPref.setDescription("The originating BGP4 speaker's degree of\npreference for an advertised route.  A\nvalue of -1 indicates the absence of this\nattribute.")
mplsVpnVrfBgpPAtrAtomicAggregate = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("lessSpecificRrouteNotSelected", 1), ("lessSpecificRouteSelected", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAtomicAggregate.setDescription("Whether or not the local system has\nselected a less specific route without\nselecting a more specific route.")
mplsVpnVrfBgpPAtrAggregatorAS = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAggregatorAS.setDescription("The AS number of the last BGP4 speaker that\nperformed route aggregation.  A value of\nzero (0) indicates the absence of this\nattribute.")
mplsVpnVrfBgpPAtrAggregatorAddr = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrAggregatorAddr.setDescription("The IP address of the last BGP4 speaker\nthat performed route aggregation.  A value\nof 0.0.0.0 indicates the absence of this\nattribute.")
mplsVpnVrfBgpPAtrCalcLocalPref = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrCalcLocalPref.setDescription("The degree of preference calculated by the\nreceiving BGP4 speaker for an advertised\nroute.  A value of -1 indicates the\nabsence of this attribute.")
mplsVpnVrfBgpPAtrBest = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("false", 1), ("true", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrBest.setDescription("An indication of whether or not this route\nwas chosen as the best BGP4 route.")
mplsVpnVrfBgpPAtrUnknown = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 5, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfBgpPAtrUnknown.setDescription("One or more path attributes not understood\nby this BGP4 speaker.  Size zero (0)\nindicates the absence of such\nattribute(s).  Octets beyond the maximum\nsize, if any, are not recorded by this\nobject.")
mplsVpnVrfSecTable = MibTable((1, 3, 6, 1, 3, 118, 1, 2, 6))
if mibBuilder.loadTexts: mplsVpnVrfSecTable.setDescription("This table specifies per MPLS/BGP VPN VRF Table security\nfeatures.")
mplsVpnVrfSecEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 2, 6, 1))
if mibBuilder.loadTexts: mplsVpnVrfSecEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS/BGP VPN. Each\nentry in this table is used to indicate security-related\ninformation for each VRF entry.")
mplsVpnVrfSecIllegalLblVltns = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLblVltns.setDescription("Indicates the number of illegally received labels on this VPN/VRF.")
mplsVpnVrfSecIllegalLblRcvThrsh = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 2, 6, 1, 2), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfSecIllegalLblRcvThrsh.setDescription("The number of illegally received labels above which this \nnotification is issued.")
mplsVpnPerf = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 3))
mplsVpnVrfPerfTable = MibTable((1, 3, 6, 1, 3, 118, 1, 3, 1))
if mibBuilder.loadTexts: mplsVpnVrfPerfTable.setDescription("This table specifies per MPLS/BGP VPN VRF Table performance\ninformation.")
mplsVpnVrfPerfEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 3, 1, 1))
if mibBuilder.loadTexts: mplsVpnVrfPerfEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS/BGP VPN.")
mplsVpnVrfPerfRoutesAdded = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesAdded.setDescription("Indicates the number of routes added to this VPN/VRF over the\ncoarse of its lifetime.")
mplsVpnVrfPerfRoutesDeleted = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfRoutesDeleted.setDescription("Indicates the number of routes removed from this VPN/VRF.")
mplsVpnVrfPerfCurrNumRoutes = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfPerfCurrNumRoutes.setDescription("Indicates the number of routes currently used by this VRF.")
mplsVpnRoute = MibIdentifier((1, 3, 6, 1, 3, 118, 1, 4))
mplsVpnVrfRouteTable = MibTable((1, 3, 6, 1, 3, 118, 1, 4, 1))
if mibBuilder.loadTexts: mplsVpnVrfRouteTable.setDescription("This table specifies per-interface MPLS/BGP VPN VRF Table\nrouting information. Entries in this table define VRF routing\nentries associated with the specified MPLS/VPN interfaces. Note\nthat this table contains both BGP and IGP routes, as both may\nappear in the same VRF.")
mplsVpnVrfRouteEntry = MibTableRow((1, 3, 6, 1, 3, 118, 1, 4, 1, 1)).setIndexNames((0, "MPLS-VPN-MIB", "mplsVpnVrfName"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteDest"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteMask"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteTos"), (0, "MPLS-VPN-MIB", "mplsVpnVrfRouteNextHop"))
if mibBuilder.loadTexts: mplsVpnVrfRouteEntry.setDescription("An entry in this table is created by an LSR for every route\npresent configured (either dynamically or statically) within\nthe context of a specific VRF capable of supporting MPLS/BGP\nVPN. The indexing provides an ordering of VRFs per-VPN\ninterface.")
mplsVpnVrfRouteDest = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 1), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfRouteDest.setDescription("The destination IP address of this route.\nThis object may not take a Multicast (Class D)\naddress value.\n\nAny assignment (implicit or otherwise) of an\ninstance of this object to a value x must be\nrejected if the bit-wise logical-AND of x with\nthe value of the corresponding instance of the\nmplsVpnVrfRouteMask object is not equal to x.")
mplsVpnVrfRouteDestAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteDestAddrType.setDescription("The address type of the mplsVpnVrfRouteDest\nentry.")
mplsVpnVrfRouteMask = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 3), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfRouteMask.setDescription("Indicate the mask to be logical-ANDed with the\ndestination  address  before  being compared to\nthe value  in  the  mplsVpnVrfRouteDest field.\nFor those  systems  that  do  not support\narbitrary subnet masks, an agent constructs the\nvalue of the mplsVpnVrfRouteMask by reference\nto the IP Address Class.\n\nAny assignment (implicit or otherwise) of an\ninstance of this object to a value x must be\nrejected if the bit-wise logical-AND of x with\nthe value of the corresponding instance of the\nmplsVpnVrfRouteDest object is not equal to\nmplsVpnVrfRouteDest.")
mplsVpnVrfRouteMaskAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMaskAddrType.setDescription("The address type of mplsVpnVrfRouteMask.")
mplsVpnVrfRouteTos = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 5), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsVpnVrfRouteTos.setDescription("The IP TOS Field is used to specify the policy to\nbe applied to this route.  The encoding of IP TOS\nis as specified  by  the  following convention.\nZero indicates the default path if no more\nspecific policy applies.\n\n+-----+-----+-----+-----+-----+-----+-----+-----+\n|                 |                       |     |\n|   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n|                 |                       |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n\n           IP TOS                IP TOS\n      Field     Policy      Field     Policy\n      Contents    Code      Contents    Code\n      0 0 0 0  ==>   0      0 0 0 1  ==>   2\n      0 0 1 0  ==>   4      0 0 1 1  ==>   6\n      0 1 0 0  ==>   8      0 1 0 1  ==>  10\n      0 1 1 0  ==>  12      0 1 1 1  ==>  14\n      1 0 0 0  ==>  16      1 0 0 1  ==>  18\n      1 0 1 0  ==>  20      1 0 1 1  ==>  22\n      1 1 0 0  ==>  24      1 1 0 1  ==>  26\n      1 1 1 0  ==>  28      1 1 1 1  ==>  30.")
mplsVpnVrfRouteNextHop = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHop.setDescription("On remote routes, the address of the next\nsystem en route; Otherwise, 0.0.0.0. .")
mplsVpnVrfRouteNextHopAddrType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 7), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAddrType.setDescription("The address type of the mplsVpnVrfRouteNextHopAddrType\nobject.")
mplsVpnVrfRouteIfIndex = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteIfIndex.setDescription("The ifIndex value that identifies the local\ninterface  through  which  the next hop of this\nroute should be reached. If this value is set to 0,\nthis indicates that no interface is associated with \nthis route.")
mplsVpnVrfRouteType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(4,1,3,2,)).subtype(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteType.setDescription("The type of route.  Note that local(3)  refers\nto a route for which the next hop is the final\ndestination; remote(4) refers to a route for\nthat the next  hop is not the final destination.\nRoutes which do not result in traffic forwarding or\nrejection should not be displayed even if the\nimplementation keeps them stored internally.\n\nreject (2) refers to a route which, if matched,\ndiscards the message as unreachable. This is used\nin some protocols as a means of correctly aggregating\nroutes.")
mplsVpnVrfRouteProto = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(10,9,3,13,16,5,8,14,15,11,1,12,4,2,7,6,)).subtype(namedValues=NamedValues(("other", 1), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteProto.setDescription("The routing mechanism via which this route was\nlearned.  Inclusion of values for gateway rout-\ning protocols is not  intended  to  imply  that\nhosts should support those protocols.")
mplsVpnVrfRouteAge = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsVpnVrfRouteAge.setDescription("The number of seconds since this route was\nlast updated or otherwise determined to be\ncorrect. Note that no semantics of `too old'\ncan be implied except through knowledge of the\nrouting protocol by which the route was\nlearned.")
mplsVpnVrfRouteInfo = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 12), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteInfo.setDescription("A reference to MIB definitions specific to the\nparticular routing protocol which is responsi-\nble for this route, as determined by the  value\nspecified  in the route's mplsVpnVrfRouteProto\nvalue. If this information is not present, its\nvalue SHOULD be set to the OBJECT IDENTIFIER\n{ 0 0 }, which is a syntactically valid object\nidentif-ier, and any implementation conforming\nto ASN.1 and the Basic Encoding Rules must be\nable to generate and recognize this value.")
mplsVpnVrfRouteNextHopAS = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 13), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteNextHopAS.setDescription("The Autonomous System Number of the Next Hop.\nThe semantics of this object are determined by\nthe routing-protocol specified in the route's\nmplsVpnVrfRouteProto value. When this object is\nunknown or not relevant its value should be set\nto zero.")
mplsVpnVrfRouteMetric1 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric1.setDescription("The primary routing metric for this route.\nThe semantics of this metric are determined by\nthe routing-protocol specified in  the  route's\nmplsVpnVrfRouteProto value. If this metric is not\nused, its value should be set to -1.")
mplsVpnVrfRouteMetric2 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric2.setDescription("An alternate routing metric for this route.\nThe semantics of this metric are determined by\nthe routing-protocol specified in  the  route's\nmplsVpnVrfRouteProto value. If this metric is not\nused, its value should be set to -1.")
mplsVpnVrfRouteMetric3 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric3.setDescription("An alternate routing metric for this route.\nThe semantics of this metric are determined by\nthe routing-protocol specified in  the  route's\nmplsVpnVrfRouteProto value. If this metric is not\nused, its value should be set to -1.")
mplsVpnVrfRouteMetric4 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric4.setDescription("An alternate routing metric for this route.\nThe semantics of this metric are determined by\nthe routing-protocol specified in  the  route's\nmplsVpnVrfRouteProto value. If this metric is not\nused, its value should be set to -1.")
mplsVpnVrfRouteMetric5 = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteMetric5.setDescription("An alternate routing metric for this route.\nThe semantics of this metric are determined by\nthe routing-protocol specified in  the  route's\nmplsVpnVrfRouteProto value. If this metric is not\nused, its value should be set to -1.")
mplsVpnVrfRouteRowStatus = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteRowStatus.setDescription("Row status for this table. It is used according\nto row installation and removal conventions.")
mplsVpnVrfRouteStorageType = MibTableColumn((1, 3, 6, 1, 3, 118, 1, 4, 1, 1, 20), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsVpnVrfRouteStorageType.setDescription("Storage type value.")
mplsVpnConformance = MibIdentifier((1, 3, 6, 1, 3, 118, 3))
mplsVpnGroups = MibIdentifier((1, 3, 6, 1, 3, 118, 3, 1))
mplsVpnCompliances = MibIdentifier((1, 3, 6, 1, 3, 118, 3, 2))

# Augmentions
mplsVpnVrfEntry.registerAugmentions(("MPLS-VPN-MIB", "mplsVpnVrfSecEntry"))
mplsVpnVrfSecEntry.setIndexNames(*mplsVpnVrfEntry.getIndexNames())
mplsVpnVrfEntry.registerAugmentions(("MPLS-VPN-MIB", "mplsVpnVrfPerfEntry"))
mplsVpnVrfPerfEntry.setIndexNames(*mplsVpnVrfEntry.getIndexNames())

# Notifications

mplsVrfIfUp = NotificationType((1, 3, 6, 1, 3, 118, 0, 1)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"), ("MPLS-VPN-MIB", "mplsVpnIfConfRowStatus"), ) )
if mibBuilder.loadTexts: mplsVrfIfUp.setDescription("This notification is generated when:\na. The ifOperStatus of an interface associated with a VRF \n   changes to the up(1) state.\nb. When an interface with ifOperStatus = up(1) is \n   associated with a VRF.")
mplsVrfIfDown = NotificationType((1, 3, 6, 1, 3, 118, 0, 2)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"), ("MPLS-VPN-MIB", "mplsVpnIfConfRowStatus"), ) )
if mibBuilder.loadTexts: mplsVrfIfDown.setDescription("This notification is generated when:\na. The ifOperStatus of an interface associated with a VRF \n   changes to the down(1) state.\nb. When an interface with ifOperStatus = up(1) state is \n   disassociated with a VRF.")
mplsNumVrfRouteMidThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 3)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMidRouteThreshold"), ) )
if mibBuilder.loadTexts: mplsNumVrfRouteMidThreshExceeded.setDescription("This notification is generated when the number of routes\ncontained by the specified VRF exceeds the value indicated by\nmplsVrfMidRouteThreshold. A single notification MUST be generated\nwhen this threshold is exceeded, and no other notifications of\nthis type should be issued until the value of \nmplsVpnVrfPerfCurrNumRoutes has fallen below that of \nmplsVpnVrfConfMidRouteThreshold.")
mplsNumVrfRouteMaxThreshExceeded = NotificationType((1, 3, 6, 1, 3, 118, 0, 4)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfConfHighRouteThreshold"), ) )
if mibBuilder.loadTexts: mplsNumVrfRouteMaxThreshExceeded.setDescription("This notification is generated when the number of routes\ncontained by the specified VRF reaches or attempts to exceed\nthe maximum allowed value as indicated by\nmplsVrfMaxRouteThreshold. In cases where \nmplsVpnVrfConfHighRouteThreshold is set to the same value \nas mplsVpnVrfConfMaxRoutes, mplsVpnVrfConfHighRouteThreshold\nneed not be exceeded; rather, just reached for this notification\nto be issued.\n\nNote that mplsVpnVrfConfRouteMaxThreshTime denotes the interval at \nwhich the this notification will be re-issued after the maximum value \nhas been exceeded (or reached if mplsVpnVrfConfMaxRoutes and \nmplsVpnVrfConfHighRouteThreshold are equal) and the initial\nnotification has been issued. This value is intended to prevent continuous \ngeneration of notifications by an agent in the event that routes are \ncontinually added to a VRF after it has reached its maximum value. The \ndefault value is 10 minutes. If this value is set to 0, the agent should \nonly issue a single notification at the time that the maximum threshold has\nbeen reached, and should not issue any more notifications until the value\nof routes has fallen below the configured threshold value.")
mplsNumVrfSecIllglLblThrshExcd = NotificationType((1, 3, 6, 1, 3, 118, 0, 5)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLblVltns"), ) )
if mibBuilder.loadTexts: mplsNumVrfSecIllglLblThrshExcd.setDescription("This notification is generated when the number of illegal\nlabel violations on a VRF as indicated by \nmplsVpnVrfSecIllegalLblVltns has exceeded \nmplsVpnVrfSecIllegalLblRcvThrsh. The threshold is not \nincluded in the varbind here because the value of \nmplsVpnVrfSecIllegalLblVltns should be one greater than \nthe threshold at the time this notification is issued.")

# Groups

mplsVpnScalarGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 1)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnNotificationEnable"), ("MPLS-VPN-MIB", "mplsVpnConfiguredVrfs"), ("MPLS-VPN-MIB", "mplsVpnVrfConfRouteMaxThreshTime"), ("MPLS-VPN-MIB", "mplsVpnActiveVrfs"), ("MPLS-VPN-MIB", "mplsVpnConnectedInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMaxPossibleRoutes"), ) )
if mibBuilder.loadTexts: mplsVpnScalarGroup.setDescription("Collection of scalar objects required for MPLS VPN\nmanagement.")
mplsVpnVrfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 2)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfAssociatedInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMaxRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfOperStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfVpnId"), ("MPLS-VPN-MIB", "mplsVpnVrfConfStorageType"), ("MPLS-VPN-MIB", "mplsVpnVrfConfMidRouteThreshold"), ("MPLS-VPN-MIB", "mplsVpnVrfCreationTime"), ("MPLS-VPN-MIB", "mplsVpnVrfActiveInterfaces"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteDistinguisher"), ("MPLS-VPN-MIB", "mplsVpnVrfConfHighRouteThreshold"), ("MPLS-VPN-MIB", "mplsVpnVrfConfRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfDescription"), ("MPLS-VPN-MIB", "mplsVpnVrfConfLastChanged"), ) )
if mibBuilder.loadTexts: mplsVpnVrfGroup.setDescription("Collection of objects needed for MPLS VPN VRF\nmanagement.")
mplsVpnIfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 3)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnIfLabelEdgeType"), ("MPLS-VPN-MIB", "mplsVpnIfVpnClassification"), ("MPLS-VPN-MIB", "mplsVpnIfVpnRouteDistProtocol"), ("MPLS-VPN-MIB", "mplsVpnIfConfRowStatus"), ("MPLS-VPN-MIB", "mplsVpnIfConfStorageType"), ) )
if mibBuilder.loadTexts: mplsVpnIfGroup.setDescription("Collection of objects needed for MPLS VPN interface\nmanagement.")
mplsVpnPerfGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 4)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfPerfRoutesAdded"), ("MPLS-VPN-MIB", "mplsVpnVrfPerfCurrNumRoutes"), ("MPLS-VPN-MIB", "mplsVpnVrfPerfRoutesDeleted"), ) )
if mibBuilder.loadTexts: mplsVpnPerfGroup.setDescription("Collection of objects needed for MPLS VPN\nperformance information.")
mplsVpnVrfBgpNbrGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 5)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrAddr"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrRole"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrStorageType"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrType"), ) )
if mibBuilder.loadTexts: mplsVpnVrfBgpNbrGroup.setDescription("Collection of objects needed for MPLS VPN\nbgp neighbor-related information.")
mplsVpnVrfBgpPrefixGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 6)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrLocalPref"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrBest"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrMultiExitDisc"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrCalcLocalPref"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrAggregatorAddr"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrOrigin"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrUnknown"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrNextHop"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrASPathSegment"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrAggregatorAS"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPAtrAtomicAggregate"), ) )
if mibBuilder.loadTexts: mplsVpnVrfBgpPrefixGroup.setDescription("Collection of objects needed for MPLS VPN\nbgp neighbor-related information.")
mplsVpnSecGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 7)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLblVltns"), ("MPLS-VPN-MIB", "mplsVpnVrfSecIllegalLblRcvThrsh"), ) )
if mibBuilder.loadTexts: mplsVpnSecGroup.setDescription("Collection of objects needed for MPLS VPN\nsecurity-related information.")
mplsVpnVrfRouteGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 8)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfRouteProto"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteStorageType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric2"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMaskAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteIfIndex"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHopAS"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric5"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric3"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric4"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteMetric1"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteDestAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHopAddrType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteAge"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteType"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteNextHop"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteInfo"), ) )
if mibBuilder.loadTexts: mplsVpnVrfRouteGroup.setDescription("Objects required for VRF route table management.")
mplsVpnVrfRouteTargetGroup = ObjectGroup((1, 3, 6, 1, 3, 118, 3, 1, 9)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetRowStatus"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTarget"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetDescr"), ) )
if mibBuilder.loadTexts: mplsVpnVrfRouteTargetGroup.setDescription("Objects required for VRF route target management.")
mplsVpnNotificationGroup = NotificationGroup((1, 3, 6, 1, 3, 118, 3, 1, 10)).setObjects(*(("MPLS-VPN-MIB", "mplsNumVrfRouteMidThreshExceeded"), ("MPLS-VPN-MIB", "mplsVrfIfDown"), ("MPLS-VPN-MIB", "mplsVrfIfUp"), ("MPLS-VPN-MIB", "mplsNumVrfRouteMaxThreshExceeded"), ("MPLS-VPN-MIB", "mplsNumVrfSecIllglLblThrshExcd"), ) )
if mibBuilder.loadTexts: mplsVpnNotificationGroup.setDescription("Objects required for MPLS VPN notifications.")

# Compliances

mplsVpnModuleCompliance = ModuleCompliance((1, 3, 6, 1, 3, 118, 3, 2, 1)).setObjects(*(("MPLS-VPN-MIB", "mplsVpnSecGroup"), ("MPLS-VPN-MIB", "mplsVpnIfGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpPrefixGroup"), ("MPLS-VPN-MIB", "mplsVpnScalarGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteTargetGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfRouteGroup"), ("MPLS-VPN-MIB", "mplsVpnVrfBgpNbrGroup"), ("MPLS-VPN-MIB", "mplsVpnNotificationGroup"), ("MPLS-VPN-MIB", "mplsVpnPerfGroup"), ) )
if mibBuilder.loadTexts: mplsVpnModuleCompliance.setDescription("Compliance statement for agents that support the\nMPLS VPN MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("MPLS-VPN-MIB", PYSNMP_MODULE_ID=mplsVpnMIB)

# Types
mibBuilder.exportSymbols("MPLS-VPN-MIB", MplsVpnName=MplsVpnName, MplsVpnRouteDistinguisher=MplsVpnRouteDistinguisher)

# Objects
mibBuilder.exportSymbols("MPLS-VPN-MIB", mplsVpnMIB=mplsVpnMIB, mplsVpnNotifications=mplsVpnNotifications, mplsVpnObjects=mplsVpnObjects, mplsVpnScalars=mplsVpnScalars, mplsVpnConfiguredVrfs=mplsVpnConfiguredVrfs, mplsVpnActiveVrfs=mplsVpnActiveVrfs, mplsVpnConnectedInterfaces=mplsVpnConnectedInterfaces, mplsVpnNotificationEnable=mplsVpnNotificationEnable, mplsVpnVrfConfMaxPossibleRoutes=mplsVpnVrfConfMaxPossibleRoutes, mplsVpnVrfConfRouteMaxThreshTime=mplsVpnVrfConfRouteMaxThreshTime, mplsVpnConf=mplsVpnConf, mplsVpnIfConfTable=mplsVpnIfConfTable, mplsVpnIfConfEntry=mplsVpnIfConfEntry, mplsVpnIfConfIndex=mplsVpnIfConfIndex, mplsVpnIfLabelEdgeType=mplsVpnIfLabelEdgeType, mplsVpnIfVpnClassification=mplsVpnIfVpnClassification, mplsVpnIfVpnRouteDistProtocol=mplsVpnIfVpnRouteDistProtocol, mplsVpnIfConfStorageType=mplsVpnIfConfStorageType, mplsVpnIfConfRowStatus=mplsVpnIfConfRowStatus, mplsVpnVrfTable=mplsVpnVrfTable, mplsVpnVrfEntry=mplsVpnVrfEntry, mplsVpnVrfName=mplsVpnVrfName, mplsVpnVrfVpnId=mplsVpnVrfVpnId, mplsVpnVrfDescription=mplsVpnVrfDescription, mplsVpnVrfRouteDistinguisher=mplsVpnVrfRouteDistinguisher, mplsVpnVrfCreationTime=mplsVpnVrfCreationTime, mplsVpnVrfOperStatus=mplsVpnVrfOperStatus, mplsVpnVrfActiveInterfaces=mplsVpnVrfActiveInterfaces, mplsVpnVrfAssociatedInterfaces=mplsVpnVrfAssociatedInterfaces, mplsVpnVrfConfMidRouteThreshold=mplsVpnVrfConfMidRouteThreshold, mplsVpnVrfConfHighRouteThreshold=mplsVpnVrfConfHighRouteThreshold, mplsVpnVrfConfMaxRoutes=mplsVpnVrfConfMaxRoutes, mplsVpnVrfConfLastChanged=mplsVpnVrfConfLastChanged, mplsVpnVrfConfRowStatus=mplsVpnVrfConfRowStatus, mplsVpnVrfConfStorageType=mplsVpnVrfConfStorageType, mplsVpnVrfRouteTargetTable=mplsVpnVrfRouteTargetTable, mplsVpnVrfRouteTargetEntry=mplsVpnVrfRouteTargetEntry, mplsVpnVrfRouteTargetIndex=mplsVpnVrfRouteTargetIndex, mplsVpnVrfRouteTargetType=mplsVpnVrfRouteTargetType, mplsVpnVrfRouteTarget=mplsVpnVrfRouteTarget, mplsVpnVrfRouteTargetDescr=mplsVpnVrfRouteTargetDescr, mplsVpnVrfRouteTargetRowStatus=mplsVpnVrfRouteTargetRowStatus, mplsVpnVrfBgpNbrAddrTable=mplsVpnVrfBgpNbrAddrTable, mplsVpnVrfBgpNbrAddrEntry=mplsVpnVrfBgpNbrAddrEntry, mplsVpnVrfBgpNbrIndex=mplsVpnVrfBgpNbrIndex, mplsVpnVrfBgpNbrRole=mplsVpnVrfBgpNbrRole, mplsVpnVrfBgpNbrType=mplsVpnVrfBgpNbrType, mplsVpnVrfBgpNbrAddr=mplsVpnVrfBgpNbrAddr, mplsVpnVrfBgpNbrRowStatus=mplsVpnVrfBgpNbrRowStatus, mplsVpnVrfBgpNbrStorageType=mplsVpnVrfBgpNbrStorageType, mplsVpnVrfBgpNbrPrefixTable=mplsVpnVrfBgpNbrPrefixTable, mplsVpnVrfBgpNbrPrefixEntry=mplsVpnVrfBgpNbrPrefixEntry, mplsVpnVrfBgpPAtrPeer=mplsVpnVrfBgpPAtrPeer, mplsVpnVrfBgpPAtrIpAddrPrefixLen=mplsVpnVrfBgpPAtrIpAddrPrefixLen, mplsVpnVrfBgpPAtrIpAddrPrefix=mplsVpnVrfBgpPAtrIpAddrPrefix, mplsVpnVrfBgpPAtrOrigin=mplsVpnVrfBgpPAtrOrigin, mplsVpnVrfBgpPAtrASPathSegment=mplsVpnVrfBgpPAtrASPathSegment, mplsVpnVrfBgpPAtrNextHop=mplsVpnVrfBgpPAtrNextHop, mplsVpnVrfBgpPAtrMultiExitDisc=mplsVpnVrfBgpPAtrMultiExitDisc, mplsVpnVrfBgpPAtrLocalPref=mplsVpnVrfBgpPAtrLocalPref, mplsVpnVrfBgpPAtrAtomicAggregate=mplsVpnVrfBgpPAtrAtomicAggregate, mplsVpnVrfBgpPAtrAggregatorAS=mplsVpnVrfBgpPAtrAggregatorAS, mplsVpnVrfBgpPAtrAggregatorAddr=mplsVpnVrfBgpPAtrAggregatorAddr, mplsVpnVrfBgpPAtrCalcLocalPref=mplsVpnVrfBgpPAtrCalcLocalPref, mplsVpnVrfBgpPAtrBest=mplsVpnVrfBgpPAtrBest, mplsVpnVrfBgpPAtrUnknown=mplsVpnVrfBgpPAtrUnknown, mplsVpnVrfSecTable=mplsVpnVrfSecTable, mplsVpnVrfSecEntry=mplsVpnVrfSecEntry, mplsVpnVrfSecIllegalLblVltns=mplsVpnVrfSecIllegalLblVltns, mplsVpnVrfSecIllegalLblRcvThrsh=mplsVpnVrfSecIllegalLblRcvThrsh, mplsVpnPerf=mplsVpnPerf, mplsVpnVrfPerfTable=mplsVpnVrfPerfTable, mplsVpnVrfPerfEntry=mplsVpnVrfPerfEntry, mplsVpnVrfPerfRoutesAdded=mplsVpnVrfPerfRoutesAdded, mplsVpnVrfPerfRoutesDeleted=mplsVpnVrfPerfRoutesDeleted, mplsVpnVrfPerfCurrNumRoutes=mplsVpnVrfPerfCurrNumRoutes, mplsVpnRoute=mplsVpnRoute, mplsVpnVrfRouteTable=mplsVpnVrfRouteTable, mplsVpnVrfRouteEntry=mplsVpnVrfRouteEntry, mplsVpnVrfRouteDest=mplsVpnVrfRouteDest, mplsVpnVrfRouteDestAddrType=mplsVpnVrfRouteDestAddrType, mplsVpnVrfRouteMask=mplsVpnVrfRouteMask, mplsVpnVrfRouteMaskAddrType=mplsVpnVrfRouteMaskAddrType, mplsVpnVrfRouteTos=mplsVpnVrfRouteTos, mplsVpnVrfRouteNextHop=mplsVpnVrfRouteNextHop, mplsVpnVrfRouteNextHopAddrType=mplsVpnVrfRouteNextHopAddrType, mplsVpnVrfRouteIfIndex=mplsVpnVrfRouteIfIndex, mplsVpnVrfRouteType=mplsVpnVrfRouteType, mplsVpnVrfRouteProto=mplsVpnVrfRouteProto, mplsVpnVrfRouteAge=mplsVpnVrfRouteAge, mplsVpnVrfRouteInfo=mplsVpnVrfRouteInfo, mplsVpnVrfRouteNextHopAS=mplsVpnVrfRouteNextHopAS, mplsVpnVrfRouteMetric1=mplsVpnVrfRouteMetric1, mplsVpnVrfRouteMetric2=mplsVpnVrfRouteMetric2, mplsVpnVrfRouteMetric3=mplsVpnVrfRouteMetric3, mplsVpnVrfRouteMetric4=mplsVpnVrfRouteMetric4, mplsVpnVrfRouteMetric5=mplsVpnVrfRouteMetric5, mplsVpnVrfRouteRowStatus=mplsVpnVrfRouteRowStatus, mplsVpnVrfRouteStorageType=mplsVpnVrfRouteStorageType, mplsVpnConformance=mplsVpnConformance, mplsVpnGroups=mplsVpnGroups, mplsVpnCompliances=mplsVpnCompliances)

# Notifications
mibBuilder.exportSymbols("MPLS-VPN-MIB", mplsVrfIfUp=mplsVrfIfUp, mplsVrfIfDown=mplsVrfIfDown, mplsNumVrfRouteMidThreshExceeded=mplsNumVrfRouteMidThreshExceeded, mplsNumVrfRouteMaxThreshExceeded=mplsNumVrfRouteMaxThreshExceeded, mplsNumVrfSecIllglLblThrshExcd=mplsNumVrfSecIllglLblThrshExcd)

# Groups
mibBuilder.exportSymbols("MPLS-VPN-MIB", mplsVpnScalarGroup=mplsVpnScalarGroup, mplsVpnVrfGroup=mplsVpnVrfGroup, mplsVpnIfGroup=mplsVpnIfGroup, mplsVpnPerfGroup=mplsVpnPerfGroup, mplsVpnVrfBgpNbrGroup=mplsVpnVrfBgpNbrGroup, mplsVpnVrfBgpPrefixGroup=mplsVpnVrfBgpPrefixGroup, mplsVpnSecGroup=mplsVpnSecGroup, mplsVpnVrfRouteGroup=mplsVpnVrfRouteGroup, mplsVpnVrfRouteTargetGroup=mplsVpnVrfRouteTargetGroup, mplsVpnNotificationGroup=mplsVpnNotificationGroup)

# Compliances
mibBuilder.exportSymbols("MPLS-VPN-MIB", mplsVpnModuleCompliance=mplsVpnModuleCompliance)
