# PySNMP SMI module. Autogenerated from smidump -f python IPMROUTE-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:57 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InterfaceIndex, InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Gauge32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, experimental, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Gauge32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "experimental")
( DisplayString, RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention", "TruthValue")

# Types

class IpMRoute1Protocol(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(9,5,8,7,12,10,4,3,6,1,2,11,)
    namedValues = NamedValues(("other", 1), ("igmpOnly", 10), ("bgmp", 11), ("msdp", 12), ("local", 2), ("netmgmt", 3), ("dvmrp", 4), ("mospf", 5), ("pimSparseDense", 6), ("cbt", 7), ("pimSparseMode", 8), ("pimDenseMode", 9), )
    

# Objects

ipMRoute1MIB = ModuleIdentity((1, 3, 6, 1, 3, 60)).setRevisions(("1999-07-22 12:00",))
if mibBuilder.loadTexts: ipMRoute1MIB.setOrganization("IETF IDMR Working Group")
if mibBuilder.loadTexts: ipMRoute1MIB.setContactInfo(" Dave Thaler\nMicrosoft Corporation\nOne Microsoft Way\nRedmond, WA  98052-6399\nUS\n\nPhone: +1 425 703 8835\nEMail: dthaler@dthaler.microsoft.com")
if mibBuilder.loadTexts: ipMRoute1MIB.setDescription("The MIB module for management of IP Multicast routing, but\nindependent of the specific multicast routing protocol in\nuse.")
ipMRoute1MIBObjects = MibIdentifier((1, 3, 6, 1, 3, 60, 1))
ipMRoute1 = MibIdentifier((1, 3, 6, 1, 3, 60, 1, 1))
ipMRoute1Enable = MibScalar((1, 3, 6, 1, 3, 60, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1Enable.setDescription("The enabled status of IP Multicast routing on this router.")
ipMRoute1Table = MibTable((1, 3, 6, 1, 3, 60, 1, 1, 2))
if mibBuilder.loadTexts: ipMRoute1Table.setDescription("The (conceptual) table containing multicast routing\ninformation for IP datagrams sent by particular sources to\nthe IP multicast groups known to this router.")
ipMRoute1Entry = MibTableRow((1, 3, 6, 1, 3, 60, 1, 1, 2, 1)).setIndexNames((0, "IPMROUTE-MIB", "ipMRoute1Group"), (0, "IPMROUTE-MIB", "ipMRoute1Source"), (0, "IPMROUTE-MIB", "ipMRoute1SourceMask"))
if mibBuilder.loadTexts: ipMRoute1Entry.setDescription("An entry (conceptual row) containing the multicast routing\ninformation for IP datagrams from a particular source and\naddressed to a particular IP multicast group address.\nDiscontinuities in counters in this entry can be detected by\nobserving the value of ipMRoute1UpTime.")
ipMRoute1Group = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 1), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1Group.setDescription("The IP multicast group address for which this entry\ncontains multicast routing information.")
ipMRoute1Source = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1Source.setDescription("The network address which when combined with the\ncorresponding value of ipMRoute1SourceMask identifies the\nsources for which this entry contains multicast routing\ninformation.")
ipMRoute1SourceMask = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 3), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1SourceMask.setDescription("The network mask which when combined with the corresponding\nvalue of ipMRoute1Source identifies the sources for which\nthis entry contains multicast routing information.")
ipMRoute1UpstreamNeighbor = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1UpstreamNeighbor.setDescription("The address of the upstream neighbor (e.g., RPF neighbor)\nfrom which IP datagrams from these sources to this multicast\naddress are received, or 0.0.0.0 if the upstream neighbor is\nunknown (e.g., in CBT).")
ipMRoute1InIfIndex = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InIfIndex.setDescription("The value of ifIndex for the interface on which IP\ndatagrams sent by these sources to this multicast address\nare received.  A value of 0 indicates that datagrams are not\nsubject to an incoming interface check, but may be accepted\non multiple interfaces (e.g., in CBT).")
ipMRoute1UpTime = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1UpTime.setDescription("The time since the multicast routing information\nrepresented by this entry was learned by the router.")
ipMRoute1ExpiryTime = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1ExpiryTime.setDescription("The minimum amount of time remaining before this entry will\nbe aged out.  The value 0 indicates that the entry is not\nsubject to aging.")
ipMRoute1Pkts = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1Pkts.setDescription("The number of packets which this router has received from\nthese sources and addressed to this multicast group\naddress.")
ipMRoute1DifferentInIfPackets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1DifferentInIfPackets.setDescription("The number of packets which this router has received from\nthese sources and addressed to this multicast group address,\nwhich were dropped because they were not received on the\ninterface indicated by ipMRoute1InIfIndex.  Packets which are\nnot subject to an incoming interface check (e.g., using CBT)\nare not counted.")
ipMRoute1Octets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1Octets.setDescription("The number of octets contained in IP datagrams which were\n\n\nreceived from these sources and addressed to this multicast\ngroup address, and which were forwarded by this router.")
ipMRoute1Protocol = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 11), IpMRoute1Protocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1Protocol.setDescription("The multicast routing protocol via which this multicast\nforwarding entry was learned.")
ipMRoute1RtProto = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(10,9,3,13,16,5,8,14,15,11,1,17,12,4,2,7,6,)).subtype(namedValues=NamedValues(("other", 1), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("ciscoEigrp", 16), ("dvmrp", 17), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1RtProto.setDescription("The routing mechanism via which the route used to find the\nupstream or parent interface for this multicast forwarding\nentry was learned.  Inclusion of values for routing\nprotocols is not intended to imply that those protocols need\nbe supported.")
ipMRoute1RtAddress = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1RtAddress.setDescription("The address portion of the route used to find the upstream\nor parent interface for this multicast forwarding entry.")
ipMRoute1RtMask = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1RtMask.setDescription("The mask associated with the route used to find the upstream\nor parent interface for this multicast forwarding entry.")
ipMRoute1RtType = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("unicast", 1), ("multicast", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1RtType.setDescription("The reason the given route was placed in the (logical)\nmulticast Routing Information Base (RIB).  A value of\nunicast means that the route would normally be placed only\nin the unicast RIB, but was placed in the multicast RIB\n(instead or in addition) due to local configuration, such as\nwhen running PIM over RIP.  A value of multicast means that\nthe route was explicitly added to the multicast RIB by the\nrouting protocol, such as DVMRP or Multiprotocol BGP.")
ipMRoute1HCOctets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1HCOctets.setDescription("The number of octets contained in IP datagrams which were\nreceived from these sources and addressed to this multicast\ngroup address, and which were forwarded by this router.\nThis object is a 64-bit version of ipMRoute1Octets.")
ipMRoute1NextHopTable = MibTable((1, 3, 6, 1, 3, 60, 1, 1, 3))
if mibBuilder.loadTexts: ipMRoute1NextHopTable.setDescription("The (conceptual) table containing information on the next-\nhops on outgoing interfaces for routing IP multicast\ndatagrams.  Each entry is one of a list of next-hops on\noutgoing interfaces for particular sources sending to a\nparticular multicast group address.")
ipMRoute1NextHopEntry = MibTableRow((1, 3, 6, 1, 3, 60, 1, 1, 3, 1)).setIndexNames((0, "IPMROUTE-MIB", "ipMRoute1NextHopGroup"), (0, "IPMROUTE-MIB", "ipMRoute1NextHopSource"), (0, "IPMROUTE-MIB", "ipMRoute1NextHopSourceMask"), (0, "IPMROUTE-MIB", "ipMRoute1NextHopIfIndex"), (0, "IPMROUTE-MIB", "ipMRoute1NextHopAddress"))
if mibBuilder.loadTexts: ipMRoute1NextHopEntry.setDescription("An entry (conceptual row) in the list of next-hops on\noutgoing interfaces to which IP multicast datagrams from\nparticular sources to a IP multicast group address are\nrouted.  Discontinuities in counters in this entry can be\ndetected by observing the value of ipMRoute1UpTime.")
ipMRoute1NextHopGroup = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 1), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1NextHopGroup.setDescription("The IP multicast group for which this entry specifies a\nnext-hop on an outgoing interface.")
ipMRoute1NextHopSource = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 2), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1NextHopSource.setDescription("The network address which when combined with the\ncorresponding value of ipMRoute1NextHopSourceMask identifies\nthe sources for which this entry specifies a next-hop on an\noutgoing interface.")
ipMRoute1NextHopSourceMask = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 3), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1NextHopSourceMask.setDescription("The network mask which when combined with the corresponding\nvalue of ipMRoute1NextHopSource identifies the sources for\nwhich this entry specifies a next-hop on an outgoing\ninterface.")
ipMRoute1NextHopIfIndex = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 4), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1NextHopIfIndex.setDescription("The ifIndex value of the interface for the outgoing\ninterface for this next-hop.")
ipMRoute1NextHopAddress = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 5), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1NextHopAddress.setDescription("The address of the next-hop specific to this entry.  For\nmost interfaces, this is identical to ipMRoute1NextHopGroup.\nNBMA interfaces, however, may have multiple next-hop\naddresses out a single outgoing interface.")
ipMRoute1NextHopState = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("pruned", 1), ("forwarding", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1NextHopState.setDescription("An indication of whether the outgoing interface and next-\nhop represented by this entry is currently being used to\nforward IP datagrams.  The value 'forwarding' indicates it\nis currently being used; the value 'pruned' indicates it is\nnot.")
ipMRoute1NextHopUpTime = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1NextHopUpTime.setDescription("The time since the multicast routing information\nrepresented by this entry was learned by the router.")
ipMRoute1NextHopExpiryTime = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1NextHopExpiryTime.setDescription("The minimum amount of time remaining before this entry will\nbe aged out.  If ipMRoute1NextHopState is pruned(1), the\nremaining time until the prune expires and the state reverts\nto forwarding(2).  Otherwise, the remaining time until this\nentry is removed from the table.  The time remaining may be\ncopied from ipMRoute1ExpiryTime if the protocol in use for\nthis entry dos not specify next-hop timers.  The value 0\nindicates that the entry is not subject to aging.")
ipMRoute1NextHopClosestMemberHops = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1NextHopClosestMemberHops.setDescription("The minimum number of hops between this router and any\nmember of this IP multicast group reached via this next-hop\non this outgoing interface.  Any IP multicast datagrams for\nthe group which have a TTL less than this number of hops\nwill not be forwarded to this next-hop.")
ipMRoute1NextHopProtocol = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 10), IpMRoute1Protocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1NextHopProtocol.setDescription("The routing mechanism via which this next-hop was learned.")
ipMRoute1NextHopPkts = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1NextHopPkts.setDescription("The number of packets which have been forwarded using this\nroute.")
ipMRoute1InterfaceTable = MibTable((1, 3, 6, 1, 3, 60, 1, 1, 4))
if mibBuilder.loadTexts: ipMRoute1InterfaceTable.setDescription("The (conceptual) table containg multicast routing\ninformation specific to interfaces.")
ipMRoute1InterfaceEntry = MibTableRow((1, 3, 6, 1, 3, 60, 1, 1, 4, 1)).setIndexNames((0, "IPMROUTE-MIB", "ipMRoute1InterfaceIfIndex"))
if mibBuilder.loadTexts: ipMRoute1InterfaceEntry.setDescription("An entry (conceptual row) containing the multicast routing\ninformation for a particular interface.")
ipMRoute1InterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1InterfaceIfIndex.setDescription("The ifIndex value of the interface for which this entry\ncontains information.")
ipMRoute1InterfaceTtl = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceTtl.setDescription("The datagram TTL threshold for the interface. Any IP\nmulticast datagrams with a TTL less than this threshold will\nnot be forwarded out the interface. The default value of 0\nmeans all multicast packets are forwarded out the\ninterface.")
ipMRoute1InterfaceProtocol = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 3), IpMRoute1Protocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceProtocol.setDescription("The routing protocol running on this interface.")
ipMRoute1InterfaceRateLimit = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 4), Integer32().clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceRateLimit.setDescription("The rate-limit, in kilobits per second, of forwarded\nmulticast traffic on the interface.  A rate-limit of 0\nindicates that no rate limiting is done.")
ipMRoute1InterfaceInMcastOctets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceInMcastOctets.setDescription("The number of octets of multicast packets that have arrived\non the interface, including framing characters.  This object\nis similar to ifInOctets in the Interfaces MIB, except that\nonly multicast packets are counted.")
ipMRoute1InterfaceOutMcastOctets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceOutMcastOctets.setDescription("The number of octets of multicast packets that have been\nsent on the interface.")
ipMRoute1InterfaceHCInMcastOctets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceHCInMcastOctets.setDescription("The number of octets of multicast packets that have arrived\non the interface, including framing characters.  This object\nis a 64-bit version of ipMRoute1InterfaceInMcastOctets.  It\nis similar to ifHCInOctets in the Interfaces MIB, except\nthat only multicast packets are counted.")
ipMRoute1InterfaceHCOutMcastOctets = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1InterfaceHCOutMcastOctets.setDescription("The number of octets of multicast packets that have been\nsent on the interface.  This object is a 64-bit version of\nipMRoute1InterfaceOutMcastOctets.")
ipMRoute1BoundaryTable = MibTable((1, 3, 6, 1, 3, 60, 1, 1, 5))
if mibBuilder.loadTexts: ipMRoute1BoundaryTable.setDescription("The (conceptual) table listing the router's scoped\nmulticast address boundaries.")
ipMRoute1BoundaryEntry = MibTableRow((1, 3, 6, 1, 3, 60, 1, 1, 5, 1)).setIndexNames((0, "IPMROUTE-MIB", "ipMRoute1BoundaryIfIndex"), (0, "IPMROUTE-MIB", "ipMRoute1BoundaryAddress"), (0, "IPMROUTE-MIB", "ipMRoute1BoundaryAddressMask"))
if mibBuilder.loadTexts: ipMRoute1BoundaryEntry.setDescription("An entry (conceptual row) in the ipMRoute1BoundaryTable\nrepresenting a scoped boundary.")
ipMRoute1BoundaryIfIndex = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 5, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1BoundaryIfIndex.setDescription("The IfIndex value for the interface to which this boundary\napplies.  Packets with a destination address in the\nassociated address/mask range will not be forwarded out this\ninterface.")
ipMRoute1BoundaryAddress = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 5, 1, 2), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1BoundaryAddress.setDescription("The group address which when combined with the\ncorresponding value of ipMRoute1BoundaryAddressMask\nidentifies the group range for which the scoped boundary\nexists.  Scoped addresses must come from the range 239.x.x.x\nas specified in RFC 2365.")
ipMRoute1BoundaryAddressMask = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 5, 1, 3), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1BoundaryAddressMask.setDescription("The group address mask which when combined with the\ncorresponding value of ipMRoute1BoundaryAddress identifies\nthe group range for which the scoped boundary exists.")
ipMRoute1BoundaryStatus = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 5, 1, 4), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1BoundaryStatus.setDescription("The status of this row, by which new entries may be\ncreated, or old entries deleted from this table.")
ipMRoute1ScopeNameTable = MibTable((1, 3, 6, 1, 3, 60, 1, 1, 6))
if mibBuilder.loadTexts: ipMRoute1ScopeNameTable.setDescription("The (conceptual) table listing the multicast scope names.")
ipMRoute1ScopeNameEntry = MibTableRow((1, 3, 6, 1, 3, 60, 1, 1, 6, 1)).setIndexNames((0, "IPMROUTE-MIB", "ipMRoute1ScopeNameAddress"), (0, "IPMROUTE-MIB", "ipMRoute1ScopeNameAddressMask"), (1, "IPMROUTE-MIB", "ipMRoute1ScopeNameLanguage"))
if mibBuilder.loadTexts: ipMRoute1ScopeNameEntry.setDescription("An entry (conceptual row) in the ipMRoute1ScopeNameTable\nrepresenting a multicast scope name.")
ipMRoute1ScopeNameAddress = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 6, 1, 1), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1ScopeNameAddress.setDescription("The group address which when combined with the\ncorresponding value of ipMRoute1ScopeNameAddressMask\nidentifies the group range associated with the multicast\nscope.  Scoped addresses must come from the range\n239.x.x.x.")
ipMRoute1ScopeNameAddressMask = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 6, 1, 2), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1ScopeNameAddressMask.setDescription("The group address mask which when combined with the\ncorresponding value of ipMRoute1ScopeNameAddress identifies\nthe group range associated with the multicast scope.")
ipMRoute1ScopeNameLanguage = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: ipMRoute1ScopeNameLanguage.setDescription("An RFC 1766-style language tag, with all alphabetic\n\n\ncharacters converted to lowercase.  This restriction is\nintended to make the lexical ordering imposed by SNMP useful\nwhen applied to language tags.  Note that it is\ntheoretically possible for a valid language tag to exceed\nthe allowed length of this object, and thus be impossible to\nrepresent in this table.  Sampling of language tags in\ncurrent use on the Internet suggests that this limit does\nnot pose a serious problem in practice.")
ipMRoute1ScopeNameString = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 6, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1ScopeNameString.setDescription("The textual name associated with the multicast scope.  The\nvalue of this object should be suitable for displaying to\nend-users, such as when allocating a multicast address in\nthis scope.  When no name is specified, the default value of\nthis object should be the string 239.x.x.x/y with x and y\nreplaced appropriately to describe the address and mask\nlength associated with the scope.")
ipMRoute1ScopeNameDefault = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 6, 1, 5), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1ScopeNameDefault.setDescription("If true, indicates a preference that the name in the\nfollowing language should be used by applications if no name\nis available in a desired language.")
ipMRoute1ScopeNameStatus = MibTableColumn((1, 3, 6, 1, 3, 60, 1, 1, 6, 1, 6), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1ScopeNameStatus.setDescription("The status of this row, by which new entries may be\ncreated, or old entries deleted from this table.")
ipMRoute1EntryCount = MibScalar((1, 3, 6, 1, 3, 60, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipMRoute1EntryCount.setDescription("The number of rows in the ipMRoute1Table.  This can be used\nto monitor the multicast routing table size.")
ipMRoute1MIBConformance = MibIdentifier((1, 3, 6, 1, 3, 60, 2))
ipMRoute1MIBCompliances = MibIdentifier((1, 3, 6, 1, 3, 60, 2, 1))
ipMRoute1MIBGroups = MibIdentifier((1, 3, 6, 1, 3, 60, 2, 2))

# Augmentions

# Groups

ipMRoute1MIBBasicGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 1)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1NextHopExpiryTime"), ("IPMROUTE-MIB", "ipMRoute1NextHopProtocol"), ("IPMROUTE-MIB", "ipMRoute1EntryCount"), ("IPMROUTE-MIB", "ipMRoute1InterfaceRateLimit"), ("IPMROUTE-MIB", "ipMRoute1InterfaceInMcastOctets"), ("IPMROUTE-MIB", "ipMRoute1InterfaceTtl"), ("IPMROUTE-MIB", "ipMRoute1NextHopPkts"), ("IPMROUTE-MIB", "ipMRoute1InIfIndex"), ("IPMROUTE-MIB", "ipMRoute1NextHopState"), ("IPMROUTE-MIB", "ipMRoute1InterfaceProtocol"), ("IPMROUTE-MIB", "ipMRoute1UpstreamNeighbor"), ("IPMROUTE-MIB", "ipMRoute1Enable"), ("IPMROUTE-MIB", "ipMRoute1UpTime"), ("IPMROUTE-MIB", "ipMRoute1InterfaceOutMcastOctets"), ("IPMROUTE-MIB", "ipMRoute1ExpiryTime"), ("IPMROUTE-MIB", "ipMRoute1NextHopUpTime"), ("IPMROUTE-MIB", "ipMRoute1Protocol"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBBasicGroup.setDescription("A collection of objects to support basic management of IP\nMulticast routing.")
ipMRoute1MIBHopCountGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 2)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1NextHopClosestMemberHops"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBHopCountGroup.setDescription("A collection of objects to support management of the use of\nhop counts in IP Multicast routing.")
ipMRoute1MIBBoundaryGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 3)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1ScopeNameDefault"), ("IPMROUTE-MIB", "ipMRoute1ScopeNameStatus"), ("IPMROUTE-MIB", "ipMRoute1ScopeNameString"), ("IPMROUTE-MIB", "ipMRoute1BoundaryStatus"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBBoundaryGroup.setDescription("A collection of objects to support management of scoped\nmulticast address boundaries.")
ipMRoute1MIBPktsOutGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 4)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1NextHopPkts"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBPktsOutGroup.setDescription("A collection of objects to support management of packet\ncounters for each outgoing interface entry of a route.")
ipMRoute1MIBHCInterfaceGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 5)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1InterfaceHCInMcastOctets"), ("IPMROUTE-MIB", "ipMRoute1InterfaceHCOutMcastOctets"), ("IPMROUTE-MIB", "ipMRoute1HCOctets"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBHCInterfaceGroup.setDescription("A collection of objects providing information specific to\nhigh speed (greater than 20,000,000 bits/second) network\ninterfaces.")
ipMRoute1MIBRouteGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 6)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1RtAddress"), ("IPMROUTE-MIB", "ipMRoute1RtProto"), ("IPMROUTE-MIB", "ipMRoute1RtMask"), ("IPMROUTE-MIB", "ipMRoute1RtType"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBRouteGroup.setDescription("A collection of objects providing information on the\nrelationship between multicast routing information, and the\nIP Forwarding Table.")
ipMRoute1MIBPktsGroup = ObjectGroup((1, 3, 6, 1, 3, 60, 2, 2, 7)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1Pkts"), ("IPMROUTE-MIB", "ipMRoute1Octets"), ("IPMROUTE-MIB", "ipMRoute1DifferentInIfPackets"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBPktsGroup.setDescription("A collection of objects to support management of packet\ncounters for each forwarding entry.")

# Compliances

ipMRoute1MIBCompliance = ModuleCompliance((1, 3, 6, 1, 3, 60, 2, 1, 1)).setObjects(*(("IPMROUTE-MIB", "ipMRoute1MIBBoundaryGroup"), ("IPMROUTE-MIB", "ipMRoute1MIBHCInterfaceGroup"), ("IPMROUTE-MIB", "ipMRoute1MIBRouteGroup"), ("IPMROUTE-MIB", "ipMRoute1MIBBasicGroup"), ) )
if mibBuilder.loadTexts: ipMRoute1MIBCompliance.setDescription("The compliance statement for the IP Multicast MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("IPMROUTE-MIB", PYSNMP_MODULE_ID=ipMRoute1MIB)

# Types
mibBuilder.exportSymbols("IPMROUTE-MIB", IpMRoute1Protocol=IpMRoute1Protocol)

# Objects
mibBuilder.exportSymbols("IPMROUTE-MIB", ipMRoute1MIB=ipMRoute1MIB, ipMRoute1MIBObjects=ipMRoute1MIBObjects, ipMRoute1=ipMRoute1, ipMRoute1Enable=ipMRoute1Enable, ipMRoute1Table=ipMRoute1Table, ipMRoute1Entry=ipMRoute1Entry, ipMRoute1Group=ipMRoute1Group, ipMRoute1Source=ipMRoute1Source, ipMRoute1SourceMask=ipMRoute1SourceMask, ipMRoute1UpstreamNeighbor=ipMRoute1UpstreamNeighbor, ipMRoute1InIfIndex=ipMRoute1InIfIndex, ipMRoute1UpTime=ipMRoute1UpTime, ipMRoute1ExpiryTime=ipMRoute1ExpiryTime, ipMRoute1Pkts=ipMRoute1Pkts, ipMRoute1DifferentInIfPackets=ipMRoute1DifferentInIfPackets, ipMRoute1Octets=ipMRoute1Octets, ipMRoute1Protocol=ipMRoute1Protocol, ipMRoute1RtProto=ipMRoute1RtProto, ipMRoute1RtAddress=ipMRoute1RtAddress, ipMRoute1RtMask=ipMRoute1RtMask, ipMRoute1RtType=ipMRoute1RtType, ipMRoute1HCOctets=ipMRoute1HCOctets, ipMRoute1NextHopTable=ipMRoute1NextHopTable, ipMRoute1NextHopEntry=ipMRoute1NextHopEntry, ipMRoute1NextHopGroup=ipMRoute1NextHopGroup, ipMRoute1NextHopSource=ipMRoute1NextHopSource, ipMRoute1NextHopSourceMask=ipMRoute1NextHopSourceMask, ipMRoute1NextHopIfIndex=ipMRoute1NextHopIfIndex, ipMRoute1NextHopAddress=ipMRoute1NextHopAddress, ipMRoute1NextHopState=ipMRoute1NextHopState, ipMRoute1NextHopUpTime=ipMRoute1NextHopUpTime, ipMRoute1NextHopExpiryTime=ipMRoute1NextHopExpiryTime, ipMRoute1NextHopClosestMemberHops=ipMRoute1NextHopClosestMemberHops, ipMRoute1NextHopProtocol=ipMRoute1NextHopProtocol, ipMRoute1NextHopPkts=ipMRoute1NextHopPkts, ipMRoute1InterfaceTable=ipMRoute1InterfaceTable, ipMRoute1InterfaceEntry=ipMRoute1InterfaceEntry, ipMRoute1InterfaceIfIndex=ipMRoute1InterfaceIfIndex, ipMRoute1InterfaceTtl=ipMRoute1InterfaceTtl, ipMRoute1InterfaceProtocol=ipMRoute1InterfaceProtocol, ipMRoute1InterfaceRateLimit=ipMRoute1InterfaceRateLimit, ipMRoute1InterfaceInMcastOctets=ipMRoute1InterfaceInMcastOctets, ipMRoute1InterfaceOutMcastOctets=ipMRoute1InterfaceOutMcastOctets, ipMRoute1InterfaceHCInMcastOctets=ipMRoute1InterfaceHCInMcastOctets, ipMRoute1InterfaceHCOutMcastOctets=ipMRoute1InterfaceHCOutMcastOctets, ipMRoute1BoundaryTable=ipMRoute1BoundaryTable, ipMRoute1BoundaryEntry=ipMRoute1BoundaryEntry, ipMRoute1BoundaryIfIndex=ipMRoute1BoundaryIfIndex, ipMRoute1BoundaryAddress=ipMRoute1BoundaryAddress, ipMRoute1BoundaryAddressMask=ipMRoute1BoundaryAddressMask, ipMRoute1BoundaryStatus=ipMRoute1BoundaryStatus, ipMRoute1ScopeNameTable=ipMRoute1ScopeNameTable, ipMRoute1ScopeNameEntry=ipMRoute1ScopeNameEntry, ipMRoute1ScopeNameAddress=ipMRoute1ScopeNameAddress, ipMRoute1ScopeNameAddressMask=ipMRoute1ScopeNameAddressMask, ipMRoute1ScopeNameLanguage=ipMRoute1ScopeNameLanguage, ipMRoute1ScopeNameString=ipMRoute1ScopeNameString, ipMRoute1ScopeNameDefault=ipMRoute1ScopeNameDefault, ipMRoute1ScopeNameStatus=ipMRoute1ScopeNameStatus, ipMRoute1EntryCount=ipMRoute1EntryCount, ipMRoute1MIBConformance=ipMRoute1MIBConformance, ipMRoute1MIBCompliances=ipMRoute1MIBCompliances, ipMRoute1MIBGroups=ipMRoute1MIBGroups)

# Groups
mibBuilder.exportSymbols("IPMROUTE-MIB", ipMRoute1MIBBasicGroup=ipMRoute1MIBBasicGroup, ipMRoute1MIBHopCountGroup=ipMRoute1MIBHopCountGroup, ipMRoute1MIBBoundaryGroup=ipMRoute1MIBBoundaryGroup, ipMRoute1MIBPktsOutGroup=ipMRoute1MIBPktsOutGroup, ipMRoute1MIBHCInterfaceGroup=ipMRoute1MIBHCInterfaceGroup, ipMRoute1MIBRouteGroup=ipMRoute1MIBRouteGroup, ipMRoute1MIBPktsGroup=ipMRoute1MIBPktsGroup)

# Compliances
mibBuilder.exportSymbols("IPMROUTE-MIB", ipMRoute1MIBCompliance=ipMRoute1MIBCompliance)
