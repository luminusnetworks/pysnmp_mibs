# PySNMP SMI module. Autogenerated from smidump -f python VPLS-LDP-DRAFT-01-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:57 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( jnxExperiment, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxExperiment")
( NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, transmission, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "transmission")
( RowStatus, StorageType, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TextualConvention", "TruthValue")
( jnxVplsConfigIndex, jnxVplsPwBindIndex, ) = mibBuilder.importSymbols("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex", "jnxVplsPwBindIndex")

# Objects

jnxVplsLdpDraft01MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 5, 9)).setRevisions(("2006-08-30 12:00",))
if mibBuilder.loadTexts: jnxVplsLdpDraft01MIB.setOrganization("Layer 2 Virtual Private Networks (L2VPN)\nWorking  Group")
if mibBuilder.loadTexts: jnxVplsLdpDraft01MIB.setContactInfo("\nThomas D. Nadeau\nEmail:  tnadeau@cisco.com\n\nThe L2VPN Working Group (email distribution l2vpn@ietf.org,\nhttp://www.ietf.org/html.charters/l2vpn-charter.html)")
if mibBuilder.loadTexts: jnxVplsLdpDraft01MIB.setDescription("Copyright (C) The IETF Trust (2010). The initial\nversion of this MIB module was published in RFC XXXX.\n\n-- RFC Editor: Please replace XXXX with RFC number & remove\n--                    this note.\n\nFor full legal notices see the RFC itself or see:\nhttp://www.ietf.org/copyrights/ianamib.html\n\nThis MIB module contains managed object definitions for\nLDP signalled Virtual Private LAN Services as in\n[RFC4762]\n\nThis MIB module enables the use of any underlying PseudoWire\nnetwork. ")
jnxVplsLdpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 9, 0))
jnxVplsLdpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1))
jnxVplsLdpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1, 1))
if mibBuilder.loadTexts: jnxVplsLdpConfigTable.setDescription("This table specifies information for configuring\nand monitoring LDP specific parameters for\nVirtual Private Lan Services(VPLS).")
jnxVplsLdpConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1, 1, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"))
if mibBuilder.loadTexts: jnxVplsLdpConfigEntry.setDescription("A row in this table represents LDP specific information\nfor Virtual Private Lan Service(VPLS) in a packet network.\nIt is indexed by jnxVplsConfigIndex, which uniquely\nidentifies a single VPLS.\n\nA row is automatically created when a VPLS service is\nconfigured using LDP signalling.\n\nNone of the read-create objects values can be\nchanged when jnxVplsRowStatus is in the active(1)\nstate. Changes are allowed when the jnxVplsRowStatus\nis in notInService(2) or notReady(3) states only.\nIf the operator need to change one of the values\nfor an active row the jnxVplsConfigRowStatus should be\nfirst changed to notInService(2), the objects may\nbe changed now, and later to active(1) in order to\nre-initiate the signaling process with the new\nvalues in effect.")
jnxVplsLdpConfigMacAddrWithdraw = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1, 1, 1, 1), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsLdpConfigMacAddrWithdraw.setDescription("This object specifies if MAC address withdrawal\nis enabled in this service. If this object is true then\nMac address withdrawl Learning is enabled. If false,\nthen Mac Learning is disabled.")
jnxVplsLdpPwBindTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1, 2))
if mibBuilder.loadTexts: jnxVplsLdpPwBindTable.setDescription("This table provides LDP specific information for\nan association between a VPLS service and the\ncorresponding Pseudo Wires. A service can have more\nthan one Pseudo Wire association. Pseudo Wires are\ndefined in the pwTable.")
jnxVplsLdpPwBindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1, 2, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"), (0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsPwBindIndex"))
if mibBuilder.loadTexts: jnxVplsLdpPwBindEntry.setDescription("Each row represents an association between a\nVPLS instance and one or more Pseudo Wires\ndefined in the pwTable. Each index is unique\nin describing an entry in this table. However\nboth indexes are required to define the one\nto many association of service to pseudowire.\n\nAn entry in this table in instantiated only when\nLDP signalling is used to configure VPLS service.\n\nEach entry in this table provides LDP specific\ninformation for the VPlS represented by \n\n\njnxVplsConfigIndex.")
jnxVplsLdpPwBindMacAddressLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 9, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsLdpPwBindMacAddressLimit.setDescription("The value of this object specifies the maximum number\nof learned and static entries allowed in the\nForwarding database for this PW Binding. The value 0\nmeans there is no limit for this PW Binding.")
jnxVplsLdpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 9, 2))

# Augmentions

# Notifications

jnxVplsLdpPwBindMacTableFull = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 9, 0, 1)).setObjects(*(("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsPwBindIndex"), ) )
if mibBuilder.loadTexts: jnxVplsLdpPwBindMacTableFull.setDescription("The jnxVplsLdpPwBindMacTableFull notification is generated\nwhen the number of learned MAC-Addresses increases to \nthe value specified in jnxVplsLdpPwBindMacAddressLimit.")

# Exports

# Module identity
mibBuilder.exportSymbols("VPLS-LDP-DRAFT-01-MIB", PYSNMP_MODULE_ID=jnxVplsLdpDraft01MIB)

# Objects
mibBuilder.exportSymbols("VPLS-LDP-DRAFT-01-MIB", jnxVplsLdpDraft01MIB=jnxVplsLdpDraft01MIB, jnxVplsLdpNotifications=jnxVplsLdpNotifications, jnxVplsLdpObjects=jnxVplsLdpObjects, jnxVplsLdpConfigTable=jnxVplsLdpConfigTable, jnxVplsLdpConfigEntry=jnxVplsLdpConfigEntry, jnxVplsLdpConfigMacAddrWithdraw=jnxVplsLdpConfigMacAddrWithdraw, jnxVplsLdpPwBindTable=jnxVplsLdpPwBindTable, jnxVplsLdpPwBindEntry=jnxVplsLdpPwBindEntry, jnxVplsLdpPwBindMacAddressLimit=jnxVplsLdpPwBindMacAddressLimit, jnxVplsLdpConformance=jnxVplsLdpConformance)

# Notifications
mibBuilder.exportSymbols("VPLS-LDP-DRAFT-01-MIB", jnxVplsLdpPwBindMacTableFull=jnxVplsLdpPwBindMacTableFull)

