# PySNMP SMI module. Autogenerated from smidump -f python ARISTA-BGP4V2-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:32 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( AristaBgp4V2AddressFamilyIdentifierTC, AristaBgp4V2IdentifierTC, AristaBgp4V2SubsequentAddressFamilyIdentifierTC, ) = mibBuilder.importSymbols("ARISTA-BGP4V2-TC-MIB", "AristaBgp4V2AddressFamilyIdentifierTC", "AristaBgp4V2IdentifierTC", "AristaBgp4V2SubsequentAddressFamilyIdentifierTC")
( aristaExperiment, ) = mibBuilder.importSymbols("ARISTA-SMI-MIB", "aristaExperiment")
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InetAddress, InetAddressPrefixLength, InetAddressType, InetAutonomousSystemNumber, InetPortNumber, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType", "InetAutonomousSystemNumber", "InetPortNumber")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( RowPointer, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TimeStamp", "TruthValue")

# Objects

aristaBgp4V2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 30065, 4, 1)).setRevisions(("2012-10-19 00:00","2012-03-11 00:00",))
if mibBuilder.loadTexts: aristaBgp4V2.setOrganization("Arista Networks, Inc.")
if mibBuilder.loadTexts: aristaBgp4V2.setContactInfo("Arista Networks, Inc.\n\nPostal: 5470 Great America Parkway\n        Santa Clara, CA 95054\n\nTel: +1 408 547-5500\n\nE-mail: snmp@aristanetworks.com")
if mibBuilder.loadTexts: aristaBgp4V2.setDescription("The MIB module for the BGP-4 protocol.\nThis version was published in\ndraft-ietf-idr-bgp4-mibv2-13, and\nmodified to be homed inside the Arista\nenterprise.  There were no other\nmodifications.\n\nCopyright (C) The IETF Trust (2012).  This\nversion of this MIB module is part of\ndraft-ietf-idr-bgp4-mibv2-13.txt;\nsee the draft itself for full legal notices.")
aristaBgp4V2Notifications = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 0))
aristaBgp4V2Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1))
aristaBgp4V2DiscontinuityTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 1))
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityTable.setDescription("Table of BGP-4 discontinuities.  Discontinuities that have\nexternal visibility occur on a per-BGP instance basis.\nTransitions by a given BGP peer will result in a consistent\nBGP view within that instance and thus do not represent a\ndiscontinuity from a protocol standpoint.")
aristaBgp4V2DiscontinuityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 1, 1)).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"))
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityEntry.setDescription("Entry repsenting information about a discontinuity event\nfor a given BGP instance.")
aristaBgp4V2DiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 1, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2DiscontinuityTime.setDescription("The value of sysUpTime at the most recent occasion at which\nthis BGP management instance has suffered a discontinuity.")
aristaBgp4V2PeerTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2))
if mibBuilder.loadTexts: aristaBgp4V2PeerTable.setDescription("BGP peer table.  This table contains, one entry per BGP\npeer, information about the connections with BGP peers.")
aristaBgp4V2PeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1)).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"))
if mibBuilder.loadTexts: aristaBgp4V2PeerEntry.setDescription("Entry containing information about the connection with\na remote BGP peer.")
aristaBgp4V2PeerInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2PeerInstance.setDescription("The routing instance index.\n\nSome BGP implementations permit the creation of\nmultiple instances of a BGP routing process. An\nexample includes routers running BGP/MPLS IP Virtual\nPrivate Networks.\n\nImplementations that do not support multiple\nrouting instances should return 1 for this object.")
aristaBgp4V2PeerLocalAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAddrType.setDescription("The address family of the local end of the peering\nsession.")
aristaBgp4V2PeerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAddr.setDescription("The local IP address of this entry's BGP connection.\n\nAn implementation is required to support IPv4 peering\nsessions in which case the length of this object is 4.\nAn implementation MAY support IPv6 peering\nsessions in which case the length of this object is 16.\nIPv6 link-local peering sessions MAY be supported by\nthis MIB.  In this case the length of this object is 20.")
aristaBgp4V2PeerRemoteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 4), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAddrType.setDescription("The address family of the remote end of the peering\nsession.\n\nAn implementation is required to support IPv4 peering\nsessions in which case the length of this object is 4.\nAn implementation MAY support IPv6 peering\nsessions in which case the length of this object is 16.\nIPv6 link-local peering sessions MAY be supported by\nthis MIB.  In this case the length of this object is 20.")
aristaBgp4V2PeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 5), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAddr.setDescription("The remote IP address of this entry's BGP peer.")
aristaBgp4V2PeerLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 6), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalPort.setDescription("The local port for the TCP connection between the BGP\npeers.")
aristaBgp4V2PeerLocalAs = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 7), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalAs.setDescription("Some implementations of BGP can represent themselves\nas multiple ASes. This is the AS that this peering\nsession is representing itself as to the remote peer.")
aristaBgp4V2PeerLocalIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 8), AristaBgp4V2IdentifierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLocalIdentifier.setDescription("The BGP Identifier of the local system for this peering\nsession.  It is REQUIRED that all aristaBgp4V2PeerLocalIdentifier\nvalues for the same aristaBgp4V2PeerInstance be identical.")
aristaBgp4V2PeerRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 9), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemotePort.setDescription("The remote port for the TCP connection between the BGP\npeers.\n\nNote that the objects aristaBgp4V2PeerLocalAddr,\naristaBgp4V2PeerLocalPort, aristaBgp4V2PeerRemoteAddr and\naristaBgp4V2PeerRemotePort provide the appropriate reference to\nthe standard MIB TCP connection table, or even the ipv6\nTCP MIB as in RFC 4022.")
aristaBgp4V2PeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 10), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteAs.setDescription("The remote autonomous system number received in the BGP\nOPEN message.")
aristaBgp4V2PeerRemoteIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 11), AristaBgp4V2IdentifierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerRemoteIdentifier.setDescription("The BGP Identifier of this entry's remote BGP peer.\n\nThis entry should be 0.0.0.0 unless the\naristaBgp4V2PeerState is in the openconfirm or the\nestablished state.")
aristaBgp4V2PeerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("halted", 1), ("running", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerAdminStatus.setDescription("Whether or not the BGP FSM for this remote peer is\nhalted or running. The BGP FSM for a remote peer is\nhalted after processing a Stop event. Likewise, it is\nin the running state after a Start event.\n\nThe aristaBgp4V2PeerState will generally be in the idle state\nwhen the FSM is halted, although some extensions such\nas Graceful Restart will leave the peer in the Idle\nstate but with the FSM running.")
aristaBgp4V2PeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(6,5,4,1,2,3,)).subtype(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerState.setDescription("The BGP peer connection state.")
aristaBgp4V2PeerDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 2, 1, 14), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerDescription.setDescription("A user configured description identifying this peer.  When\nthis object is not the empty string, this object SHOULD\ncontain a description that is unique within a given BGP\ninstance for this peer.")
aristaBgp4V2PeerErrorsTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3))
if mibBuilder.loadTexts: aristaBgp4V2PeerErrorsTable.setDescription("On a per-peer basis, this table reflects the last\nprotocol-defined error encountered and reported on\nthe peer session.")
aristaBgp4V2PeerErrorsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1))
if mibBuilder.loadTexts: aristaBgp4V2PeerErrorsEntry.setDescription("Each entry contains information about errors sent\nand received for a particular BGP peer.")
aristaBgp4V2PeerLastErrorCodeReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeReceived.setDescription("The last error code received from this peer via\nNOTIFICATION message on this connection.  If no error has\noccurred, this field is zero.")
aristaBgp4V2PeerLastErrorSubCodeReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeReceived.setDescription("The last subcode received from this peer via NOTIFICATION\nmessage on this connection.  If no error has occurred, this\nfield is zero.")
aristaBgp4V2PeerLastErrorReceivedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedTime.setDescription("The timestamp that the last NOTIFICATION was received from\nthis peer.")
aristaBgp4V2PeerLastErrorReceivedText = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedText.setDescription("This object contains an implementation specific\nexplanation of the error that was reported.")
aristaBgp4V2PeerLastErrorReceivedData = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4075))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorReceivedData.setDescription("The last error code's data seen by this peer.\n\nPer RFC 2578, some implementations may have limitations\ndealing with OCTET STRINGS larger than 255.  Thus, this\ndata may be truncated.")
aristaBgp4V2PeerLastErrorCodeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorCodeSent.setDescription("The last error code sent to this peer via NOTIFICATION\nmessage on this connection.  If no error has occurred, this\nfield is zero.")
aristaBgp4V2PeerLastErrorSubCodeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSubCodeSent.setDescription("The last subcode sent to this peer via NOTIFICATION\nmessage on this connection.  If no error has occurred, this\nfield is zero.")
aristaBgp4V2PeerLastErrorSentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 8), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentTime.setDescription("The timestamp that the last NOTIFICATION was sent to\nthis peer.")
aristaBgp4V2PeerLastErrorSentText = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 9), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentText.setDescription("This object contains an implementation specific\nexplanation of the error that is being reported.")
aristaBgp4V2PeerLastErrorSentData = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4075))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerLastErrorSentData.setDescription("The last error code's data sent to this peer.\n\nPer RFC 2578, some implementations may have limitations\ndealing with OCTET STRINGS larger than 255.  Thus, this\ndata may be truncated.")
aristaBgp4V2PeerEventTimesTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4))
if mibBuilder.loadTexts: aristaBgp4V2PeerEventTimesTable.setDescription("A table reporting the per-peering session amount\nof time elapsed and update events since the peering\nsession advanced into the established state.")
aristaBgp4V2PeerEventTimesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4, 1))
if mibBuilder.loadTexts: aristaBgp4V2PeerEventTimesEntry.setDescription("Each row contains a set of statistics about time\nspent and events encountered in the peer session\nestablished state.")
aristaBgp4V2PeerFsmEstablishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTime.setDescription("This timer indicates how long (in seconds) this peer\nhas been in the established state or how long since this\npeer was last in the established state.  It is set to\nzero when a new peer is configured or when the router is\nbooted.  If the peer has never reached the established\nstate, the value remains zero.")
aristaBgp4V2PeerInUpdatesElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdatesElapsedTime.setDescription("Elapsed time (in seconds) since the last BGP UPDATE\nmessage was received from the peer.  Each time\nbgpPeerInUpdates is incremented, the value of this\nobject is set to zero (0).")
aristaBgp4V2PeerConfiguredTimersTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5))
if mibBuilder.loadTexts: aristaBgp4V2PeerConfiguredTimersTable.setDescription("Per peer management data on BGP session timers.")
aristaBgp4V2PeerConfiguredTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1))
if mibBuilder.loadTexts: aristaBgp4V2PeerConfiguredTimersEntry.setDescription("Each entry corresponds to the current state of\nBGP timers on a given peering session.")
aristaBgp4V2PeerConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerConnectRetryInterval.setDescription("Time interval (in seconds) for the ConnectRetry timer.\nThe suggested value for this timer is 120 seconds.")
aristaBgp4V2PeerHoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTimeConfigured.setDescription("Time interval (in seconds) for the Hold Timer\nestablished with the peer.  The value of this object is\ncalculated by this BGP speaker, using the smaller of the\nvalues in bgpPeerHoldTimeConfigured and the Hold Time\nreceived in the OPEN message.\n\nThis value must be at least three seconds if it is not\nzero (0).\n\nIf the Hold Timer has not been established with the\npeer this object MUST have a value of zero (0).\n\nIf the bgpPeerHoldTimeConfigured object has a value of\n(0), then this object MUST have a value of (0).")
aristaBgp4V2PeerKeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAliveConfigured.setDescription("Time interval (in seconds) for the KeepAlive timer\nconfigured for this BGP speaker with this peer.  The\nvalue of this object will only determine the KEEPALIVE\nmessages' frequency relative to the value specified in\nbgpPeerHoldTimeConfigured; the actual time interval for\nthe KEEPALIVE messages is indicated by bgpPeerKeepAlive.\n\nA reasonable maximum value for this timer would be one\nthird of that of bgpPeerHoldTimeConfigured.\n\nIf the value of this object is zero (0), no periodic\nKEEPALIVE messages are sent to the peer after the BGP\nconnection has been established.  The suggested value\nfor this timer is 30 seconds.")
aristaBgp4V2PeerMinASOrigInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerMinASOrigInterval.setDescription("Time interval (in seconds) for the\nMinASOriginationInterval timer.\n\nThe suggested value for this timer is 15 seconds.")
aristaBgp4V2PeerMinRouteAdverInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 5, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerMinRouteAdverInterval.setDescription("Time interval (in seconds) for the\nMinRouteAdvertisementInterval timer.\n\nThe suggested value for this timer is 30 seconds for\nEBGP connections and 5 seconds for IBGP connections.")
aristaBgp4V2PeerNegotiatedTimersTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6))
if mibBuilder.loadTexts: aristaBgp4V2PeerNegotiatedTimersTable.setDescription("Configured values of per-peer timers are seen\nin the aristaBgp4V2PeerConfiguredTimersTable.\n\nValues in this table reflect the current\noperational values, after negotiation from values\nderived from initial configuration.")
aristaBgp4V2PeerNegotiatedTimersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6, 1))
if mibBuilder.loadTexts: aristaBgp4V2PeerNegotiatedTimersEntry.setDescription("Each entry reflects a value of the currently\noperational, negotiated timer as reflected in the\nAristaBgp4V2PeerNegotiatedTimersEntry.")
aristaBgp4V2PeerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerHoldTime.setDescription("The value of this object is calculated by this BGP\nSpeaker as being;\n\nzero (0) - if this was the value sent by the peer and\nthis value is permitted by this BGP Speaker. In this\ncase, no keepalive messages are sent and the Hold Timer\nis not set.\n\nAt least three (3). This value is the smaller of\nthe value sent by this peer in the OPEN message and\naristaBgp4V2PeerHoldTimeConfigured for this peer.\n\nIf the peer is not in the established state, the value\nof this object is zero (0).")
aristaBgp4V2PeerKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 6, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerKeepAlive.setDescription("Time interval in seconds for the KeepAlive timer\nestablished with the peer. The value of this object\nis calculated by this BGP speaker such that, when\ncompared with aristaBgp4V2PeerHoldTime, it has the same\nproportion as what aristaBgp4V2PeerKeepAliveConfigured has\nwhen compared with aristaBgp4V2PeerHoldTimeConfigured. If\nthe value of this object is zero (0), it indicates\nthat the KeepAlive timer has not been established\nwith the peer, or, the value of\naristaBgp4V2PeerKeepAliveConfigured is zero (0).\n\nIf the peer is not in the established state, the value\nof this object is zero (0).")
aristaBgp4V2PeerCountersTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7))
if mibBuilder.loadTexts: aristaBgp4V2PeerCountersTable.setDescription("The counters associated with a BGP Peer.")
aristaBgp4V2PeerCountersEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1))
if mibBuilder.loadTexts: aristaBgp4V2PeerCountersEntry.setDescription("Each entry contains counters of message transmissions\nand FSM transitions for a given BGP Peering session.")
aristaBgp4V2PeerInUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerInUpdates.setDescription("The number of BGP UPDATE messages received on this\nconnection.")
aristaBgp4V2PeerOutUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerOutUpdates.setDescription("The number of BGP UPDATE messages transmitted on this\nconnection.")
aristaBgp4V2PeerInTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerInTotalMessages.setDescription("The total number of messages received from the remote\npeer on this connection.")
aristaBgp4V2PeerOutTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerOutTotalMessages.setDescription("The total number of messages transmitted to the remote\npeer on this connection.")
aristaBgp4V2PeerFsmEstablishedTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PeerFsmEstablishedTransitions.setDescription("The total number of times the BGP FSM transitioned into\nthe established state for this peer.")
aristaBgp4V2PrefixGaugesTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8))
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesTable.setDescription("Additional per-peer, per AFI-SAFI counters for\nprefixes")
aristaBgp4V2PrefixGaugesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1)).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixGaugesAfi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixGaugesSafi"))
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesEntry.setDescription("Entry containing information about a bgp-peers prefix\ncounters.")
aristaBgp4V2PrefixGaugesAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 1), AristaBgp4V2AddressFamilyIdentifierTC()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesAfi.setDescription("The AFI index of the per-peer, per prefix counters")
aristaBgp4V2PrefixGaugesSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 2), AristaBgp4V2SubsequentAddressFamilyIdentifierTC()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2PrefixGaugesSafi.setDescription("The SAFI index of the per-peer, per prefix counters")
aristaBgp4V2PrefixInPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixes.setDescription("The number of prefixes received from a peer and are\nstored in the Adj-Ribs-In for that peer.\n\nNote that this number does not reflect prefixes that\nhave been discarded due to policy.")
aristaBgp4V2PrefixInPrefixesAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PrefixInPrefixesAccepted.setDescription("The number of prefixes for a peer that are installed\nin the Adj-Ribs-In and are eligible to become active\nin the Loc-Rib.")
aristaBgp4V2PrefixOutPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 8, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2PrefixOutPrefixes.setDescription("The number of prefixes for a peer that are installed\nin that peer's Adj-Ribs-Out.")
aristaBgp4V2NlriTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9))
if mibBuilder.loadTexts: aristaBgp4V2NlriTable.setDescription("The BGP-4 Received Path Attribute Table contains\ninformation about paths to destination networks\nreceived from all BGP4 peers. Collectively, this\nrepresents the Adj-Ribs-In. The route where\naristaBgp4V2NlriBest is true represents, for this NLRI,\nthe route that is installed in the LocRib from the\nAdj-Ribs-In.")
aristaBgp4V2NlriEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1)).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAfi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriSafi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefix"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixLen"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriIndex"))
if mibBuilder.loadTexts: aristaBgp4V2NlriEntry.setDescription("Information about a path to a network.")
aristaBgp4V2NlriIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2NlriIndex.setDescription("This index allows for multiple instances of a base\nprefix for a certain AFI-SAFI from a given peer.\nThis is currently useful for two things:\n1. Allowing for a peer in future implementations to\n   send more than a single route instance.\n2. Allow for extensions which extend the NLRI field\n   to send the same prefix while utilizing other\n   extension specific information. An example of\n   this is RFC 3107 - Carrying MPLS labels in BGP.")
aristaBgp4V2NlriAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 2), AristaBgp4V2AddressFamilyIdentifierTC()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2NlriAfi.setDescription("The address family of the prefix for this NLRI.\n\nNote that the AFI is not necessarily equivalent to\nthe an InetAddressType.")
aristaBgp4V2NlriSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 3), AristaBgp4V2SubsequentAddressFamilyIdentifierTC()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2NlriSafi.setDescription("The subsequent address family of the prefix for\nthis NLRI")
aristaBgp4V2NlriPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 4), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefixType.setDescription("The type of the IP address prefix in the\nNetwork Layer Reachability Information field.\nThe value of this object is derived from the\nappropriate value from the aristaBgp4V2NlriAfi field.\nWhere an appropriate InetAddressType is not\navailable, the value of the object must be\nunknown(0).")
aristaBgp4V2NlriPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 5), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefix.setDescription("An IP address prefix in the Network Layer\nReachability Information field. This object\nis an IP address containing the prefix with\nlength specified by aristaBgp4V2NlriPrefixLen.\nAny bits beyond the length specified by\naristaBgp4V2NlriPrefixLen are zeroed.\n\nAn implementation is required to support IPv4\nprefixes.  In this case, the object length\nis (0..4).\n\nAn implementation MAY support IPv6 prefixes.\nIn this case, the object length is (0..16)")
aristaBgp4V2NlriPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 6), InetAddressPrefixLength()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2NlriPrefixLen.setDescription("Length in bits of the address prefix in\nthe Network Layer Reachability Information field.")
aristaBgp4V2NlriBest = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriBest.setDescription("An indication of whether or not this route\nwas chosen as the best BGP4 route for this\ndestination.")
aristaBgp4V2NlriCalcLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriCalcLocalPref.setDescription("The degree of preference calculated by the\nreceiving BGP4 speaker for an advertised\nroute.\n\nIn the case where this prefix is ineligible, the\nvalue of this object will be zero (0).")
aristaBgp4V2NlriOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriOrigin.setDescription("The ultimate origin of the path information.")
aristaBgp4V2NlriNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddrType.setDescription("The address family of the address for\nthe border router that should be used\nto access the destination network.")
aristaBgp4V2NlriNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 11), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(4, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriNextHopAddr.setDescription("The address of the border router that\nshould be used to access the destination\nnetwork. This address is the nexthop\naddress received in the UPDATE packet associated with\nthis prefix.\n\nNote that for RFC2545 style double nexthops,\nthis object will always contain the global scope\nnexthop. bgpPathAttrLinkLocalNextHop will contain\nthe linklocal scope nexthop, if it is present.\n\nIn the case a mechanism is developed to use only a link\nlocal nexthop, aristaBgp4V2NlriNextHopAddr will contain the\nlink local nexthop.")
aristaBgp4V2NlriLinkLocalNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 12), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddrType.setDescription("The address type for IPv6 link local addresses.\nThis is present only when receiving RFC 2545\nstyle double nexthops.\n\nThis object is optionally present in BGP\nimplementations that do not support IPv6.\n\nWhen no IPv6 link local nexthop is present, the value of\nthis object should be unknown(0).")
aristaBgp4V2NlriLinkLocalNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 13), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLinkLocalNextHopAddr.setDescription("This value contains an IPv6 link local address\nand is present only when receiving RFC 2545 style\ndouble nexthops.\n\nThis object is optionally present in BGP\nimplementations that do not support IPv6.\n\nWhen no IPv6 link local nexthop is present, the length of\nthis object should be zero.")
aristaBgp4V2NlriLocalPrefPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPrefPresent.setDescription("This value is true when the LOCAL_PREF value was sent in\nthe UPDATE message.")
aristaBgp4V2NlriLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 15), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriLocalPref.setDescription("The originating BGP4 speakers degree of preference for an\nadvertised route.")
aristaBgp4V2NlriMedPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriMedPresent.setDescription("This value is true when the MED value was sent in\nthe UPDATE message.")
aristaBgp4V2NlriMed = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriMed.setDescription("This metric is used to discriminate between multiple\nexit points to an adjacent autonomous system.  When the MED\nvalue is absent but has a calculated default value, this\nobject will contain the calculated value.")
aristaBgp4V2NlriAtomicAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAtomicAggregate.setDescription("This value is true when the ATOMIC_AGGREGATE Path Attribute\nis present and indicates that the NLRI MUST NOT be made\nmore specific.")
aristaBgp4V2NlriAggregatorPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorPresent.setDescription("This value is true when the AGGREGATOR path attribute\nwas sent in the UPDATE message.")
aristaBgp4V2NlriAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 20), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAS.setDescription("The AS number of the last BGP4 speaker that performed route\naggregation. When aristaBgp4V2NlriAggregatorPresent is\nfalse, the value of this object should be zero (0).")
aristaBgp4V2NlriAggregatorAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 21), AristaBgp4V2IdentifierTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAggregatorAddr.setDescription("The IP address of the last BGP4 speaker that performed\nroute aggregation.  When aristaBgp4V2NlriAggregatorPresent is\nfalse, the value of this object should be 0.0.0.0")
aristaBgp4V2NlriAsPathCalcLength = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathCalcLength.setDescription("This value represents the calculated length of the\nAS Path according to the rules of the BGP\nspecification.  This value is used in route selection.")
aristaBgp4V2NlriAsPathString = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 23), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPathString.setDescription("This is a string depicting the autonomous system\npath to this network which was received from the\npeer which advertised it. The format of the string\nis implementation-dependent, and should be designed\nfor operator readability.\n\nNote that SnmpAdminString is only capable of representing a\nmaximum of 255 characters.  This may lead to the string\nbeing truncated in the presence of a large AS Path.  It is\nRECOMMENDED that when this object's contents will be\ntruncated that the final 3 octets be reserved for the\nellipses string, '...'.  aristaBgp4V2NlriAsPath may give access\nto the full AS Path.")
aristaBgp4V2NlriAsPath = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 4072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriAsPath.setDescription("In order to provide a canonicalized form of the BGP-4\nAS_PATH along with the human-readable\naristaBgp4V2NlriAsPathString, which may be truncated, this object\ncontains the contents of the BGP-4 AS_PATH Path Attribute.\nThis object may be parsed using the rules defined for\nFour-octet ASes as defined in RFC 4893.  RFC 4271, Section\n4.3, 'Path Attributes: b) AS_PATH' as amended by RFC 5065,\nSection 3 defines the general format of the AS_PATH path\nattribute and its code points.\n\nIn brief, the AS_PATH is composed of a sequence of AS\nSegments.  Each AS Segment is represented by a triple:\n<path segment type, path segment length,\npath segment value>.\n\nThe path segment type and path segment length fields are\none octet in length each.\n\nThe path segment type field may be one of:\n  1 - AS_SET (RFC 4721, Section 4.3)\n  2 - AS_SEQUENCE (RFC 4721, Section 4.3)\n  3 - AS_CONFED_SEQUENCE (RFC 3065, Section 5)\n  4 - AS_CONFED_SET (RFC 3065, Section 5)\n\nThe path segment length field contains the number of ASes\n(not the number of octets) in the path segment value field.\nThe path segment value field contains one or more AS\nnumbers, each encoded as a 4-octet length field in network\nbyte order.\n\nNote that since an SNMP agent may truncate this object to\nless than its maximum theoretical length of 4072 octets\nusers of this object should be prepared to deal with a\ntruncated and thus malformed AS_PATH.  It is RECOMMENDED\nthat when such truncation would occur on the boundary of an\nencoded AS that the partial AS be discarded from this\nobject and the object's size be adjusted accordingly.\nFurther, it is also RECOMMENDED that when such truncation,\neither alone or in conjuction with the truncation of a\npartially encoded AS described previously, would yield an\nempty path segment value field that the path segment type\nand path segment length components of the truncated AS_PATH\nalso be discarded and the object's size be adjusted\naccordingly.")
aristaBgp4V2NlriPathAttrUnknown = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 9, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 4072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2NlriPathAttrUnknown.setDescription("Path Attributes not understood by this implementation\nSHOULD be be presented in this object.  Those Path\nAttributes use the type, length, value encoding documented\nin RFC 4271, Section 4.3, 'Path Attributes'.\n\nNote that since an SNMP agent may truncate this object to\nless than its maximum theoretical length of 4072 octets\nusers of this object should be prepared to deal with a\ntruncated and thus malformed Path Attribute.")
aristaBgp4V2AdjRibsOutTable = MibTable((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10))
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutTable.setDescription("This table contains on a per-peer basis one or more\nroutes from the aristaBgp4V2NlriTable that have been\nplaced in this peer's Adj-Ribs-Out.")
aristaBgp4V2AdjRibsOutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10, 1)).setIndexNames((0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInstance"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAfi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriSafi"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefix"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPrefixLen"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddrType"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAddr"), (0, "ARISTA-BGP4V2-MIB", "aristaBgp4V2AdjRibsOutIndex"))
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutEntry.setDescription("List of BGP routes that have been placed into a\npeer's Adj-Ribs-Out.")
aristaBgp4V2AdjRibsOutIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutIndex.setDescription("Certain extensions to BGP permit multiple instance of\na per afi, per safi prefix to be advertised to a peer.\nThis object allows the enumeration of them.")
aristaBgp4V2AdjRibsOutRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 30065, 4, 1, 1, 10, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aristaBgp4V2AdjRibsOutRoute.setDescription("This object points to the route in the aristaBgp4V2NlriTable\nthat corresponds to the entry in the peer's\nAdj-Rib-Out. Outgoing route maps are not\nreflected at this point as those are part of the\nUpdate-Send process.")
aristaBgp4V2Conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2))
aristaBgp4V2Compliances = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 1))
aristaBgp4V2Groups = MibIdentifier((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2))

# Augmentions
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerNegotiatedTimersEntry"))
aristaBgp4V2PeerNegotiatedTimersEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerConfiguredTimersEntry"))
aristaBgp4V2PeerConfiguredTimersEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerErrorsEntry"))
aristaBgp4V2PeerErrorsEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerCountersEntry"))
aristaBgp4V2PeerCountersEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())
aristaBgp4V2PeerEntry.registerAugmentions(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerEventTimesEntry"))
aristaBgp4V2PeerEventTimesEntry.setIndexNames(*aristaBgp4V2PeerEntry.getIndexNames())

# Notifications

aristaBgp4V2EstablishedNotification = NotificationType((1, 3, 6, 1, 4, 1, 30065, 4, 1, 0, 1)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerState"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemotePort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalPort"), ) )
if mibBuilder.loadTexts: aristaBgp4V2EstablishedNotification.setDescription("The BGP Established event is generated when\nthe BGP FSM enters the established state.")
aristaBgp4V2BackwardTransitionNotification = NotificationType((1, 3, 6, 1, 4, 1, 30065, 4, 1, 0, 2)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerState"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemotePort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSubCodeReceived"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalPort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedText"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorCodeReceived"), ) )
if mibBuilder.loadTexts: aristaBgp4V2BackwardTransitionNotification.setDescription("The BGPBackwardTransition Event is generated\nwhen the BGP FSM moves from a higher numbered\nstate to a lower numbered state.\n\nDue to the nature of the BGP state machine, an\nimplementation MAY rate limit the generation of this event.\nAn implementation MAY also generate this notification ONLY\nwhen the state machine moves out of the established state.\nAn implementation should document its specific behavior.")

# Groups

aristaBgp4V2GlobalsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 1)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2DiscontinuityTime"), ) )
if mibBuilder.loadTexts: aristaBgp4V2GlobalsGroup.setDescription("A collection of objects providing information on global\nBGP state.")
aristaBgp4V2StdMIBTimersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 2)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerHoldTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerMinASOrigInterval"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerHoldTimeConfigured"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerFsmEstablishedTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerKeepAlive"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInUpdatesElapsedTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerKeepAliveConfigured"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerMinRouteAdverInterval"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerConnectRetryInterval"), ) )
if mibBuilder.loadTexts: aristaBgp4V2StdMIBTimersGroup.setDescription("Objects associated with BGP peering timers.")
aristaBgp4V2StdMIBCountersGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 3)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixInPrefixes"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInUpdates"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerOutUpdates"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerOutTotalMessages"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixInPrefixesAccepted"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PrefixOutPrefixes"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerFsmEstablishedTransitions"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerInTotalMessages"), ) )
if mibBuilder.loadTexts: aristaBgp4V2StdMIBCountersGroup.setDescription("Objects to count discrete events and exchanges on BGP\nsessions.")
aristaBgp4V2StdMIBErrorsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 5)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSubCodeSent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSentData"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorCodeSent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedData"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSentText"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorReceivedText"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSentTime"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorCodeReceived"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLastErrorSubCodeReceived"), ) )
if mibBuilder.loadTexts: aristaBgp4V2StdMIBErrorsGroup.setDescription("Errors received on BGP peering sessions.")
aristaBgp4V2StdMIBPeerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 6)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerState"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalAs"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalAddrType"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemotePort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteAs"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalIdentifier"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalPort"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerAdminStatus"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerLocalAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerDescription"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2PeerRemoteIdentifier"), ) )
if mibBuilder.loadTexts: aristaBgp4V2StdMIBPeerGroup.setDescription("Core object types on BGP peering sessions.")
aristaBgp4V2StdMIBNlriGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 7)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriMedPresent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAsPathString"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLocalPrefPresent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAggregatorAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLinkLocalNextHopAddrType"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriPathAttrUnknown"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2AdjRibsOutRoute"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriNextHopAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAggregatorPresent"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriNextHopAddrType"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLocalPref"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriLinkLocalNextHopAddr"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriBest"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAsPath"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriOrigin"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriMed"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriCalcLocalPref"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAtomicAggregate"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAsPathCalcLength"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2NlriAggregatorAS"), ) )
if mibBuilder.loadTexts: aristaBgp4V2StdMIBNlriGroup.setDescription("Attributes received on BGP peering sessions.")
aristaBgp4V2StdMIBNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 2, 8)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2BackwardTransitionNotification"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2EstablishedNotification"), ) )
if mibBuilder.loadTexts: aristaBgp4V2StdMIBNotificationGroup.setDescription("Notifications in this modules are completely optional.")

# Compliances

aristaBgp4V2Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 30065, 4, 1, 2, 1, 4)).setObjects(*(("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBCountersGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBErrorsGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBPeerGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBNlriGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBTimersGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2GlobalsGroup"), ("ARISTA-BGP4V2-MIB", "aristaBgp4V2StdMIBNotificationGroup"), ) )
if mibBuilder.loadTexts: aristaBgp4V2Compliance.setDescription("The compliance statement for entities which\nimplement the BGP4 mib.")

# Exports

# Module identity
mibBuilder.exportSymbols("ARISTA-BGP4V2-MIB", PYSNMP_MODULE_ID=aristaBgp4V2)

# Objects
mibBuilder.exportSymbols("ARISTA-BGP4V2-MIB", aristaBgp4V2=aristaBgp4V2, aristaBgp4V2Notifications=aristaBgp4V2Notifications, aristaBgp4V2Objects=aristaBgp4V2Objects, aristaBgp4V2DiscontinuityTable=aristaBgp4V2DiscontinuityTable, aristaBgp4V2DiscontinuityEntry=aristaBgp4V2DiscontinuityEntry, aristaBgp4V2DiscontinuityTime=aristaBgp4V2DiscontinuityTime, aristaBgp4V2PeerTable=aristaBgp4V2PeerTable, aristaBgp4V2PeerEntry=aristaBgp4V2PeerEntry, aristaBgp4V2PeerInstance=aristaBgp4V2PeerInstance, aristaBgp4V2PeerLocalAddrType=aristaBgp4V2PeerLocalAddrType, aristaBgp4V2PeerLocalAddr=aristaBgp4V2PeerLocalAddr, aristaBgp4V2PeerRemoteAddrType=aristaBgp4V2PeerRemoteAddrType, aristaBgp4V2PeerRemoteAddr=aristaBgp4V2PeerRemoteAddr, aristaBgp4V2PeerLocalPort=aristaBgp4V2PeerLocalPort, aristaBgp4V2PeerLocalAs=aristaBgp4V2PeerLocalAs, aristaBgp4V2PeerLocalIdentifier=aristaBgp4V2PeerLocalIdentifier, aristaBgp4V2PeerRemotePort=aristaBgp4V2PeerRemotePort, aristaBgp4V2PeerRemoteAs=aristaBgp4V2PeerRemoteAs, aristaBgp4V2PeerRemoteIdentifier=aristaBgp4V2PeerRemoteIdentifier, aristaBgp4V2PeerAdminStatus=aristaBgp4V2PeerAdminStatus, aristaBgp4V2PeerState=aristaBgp4V2PeerState, aristaBgp4V2PeerDescription=aristaBgp4V2PeerDescription, aristaBgp4V2PeerErrorsTable=aristaBgp4V2PeerErrorsTable, aristaBgp4V2PeerErrorsEntry=aristaBgp4V2PeerErrorsEntry, aristaBgp4V2PeerLastErrorCodeReceived=aristaBgp4V2PeerLastErrorCodeReceived, aristaBgp4V2PeerLastErrorSubCodeReceived=aristaBgp4V2PeerLastErrorSubCodeReceived, aristaBgp4V2PeerLastErrorReceivedTime=aristaBgp4V2PeerLastErrorReceivedTime, aristaBgp4V2PeerLastErrorReceivedText=aristaBgp4V2PeerLastErrorReceivedText, aristaBgp4V2PeerLastErrorReceivedData=aristaBgp4V2PeerLastErrorReceivedData, aristaBgp4V2PeerLastErrorCodeSent=aristaBgp4V2PeerLastErrorCodeSent, aristaBgp4V2PeerLastErrorSubCodeSent=aristaBgp4V2PeerLastErrorSubCodeSent, aristaBgp4V2PeerLastErrorSentTime=aristaBgp4V2PeerLastErrorSentTime, aristaBgp4V2PeerLastErrorSentText=aristaBgp4V2PeerLastErrorSentText, aristaBgp4V2PeerLastErrorSentData=aristaBgp4V2PeerLastErrorSentData, aristaBgp4V2PeerEventTimesTable=aristaBgp4V2PeerEventTimesTable, aristaBgp4V2PeerEventTimesEntry=aristaBgp4V2PeerEventTimesEntry, aristaBgp4V2PeerFsmEstablishedTime=aristaBgp4V2PeerFsmEstablishedTime, aristaBgp4V2PeerInUpdatesElapsedTime=aristaBgp4V2PeerInUpdatesElapsedTime, aristaBgp4V2PeerConfiguredTimersTable=aristaBgp4V2PeerConfiguredTimersTable, aristaBgp4V2PeerConfiguredTimersEntry=aristaBgp4V2PeerConfiguredTimersEntry, aristaBgp4V2PeerConnectRetryInterval=aristaBgp4V2PeerConnectRetryInterval, aristaBgp4V2PeerHoldTimeConfigured=aristaBgp4V2PeerHoldTimeConfigured, aristaBgp4V2PeerKeepAliveConfigured=aristaBgp4V2PeerKeepAliveConfigured, aristaBgp4V2PeerMinASOrigInterval=aristaBgp4V2PeerMinASOrigInterval, aristaBgp4V2PeerMinRouteAdverInterval=aristaBgp4V2PeerMinRouteAdverInterval, aristaBgp4V2PeerNegotiatedTimersTable=aristaBgp4V2PeerNegotiatedTimersTable, aristaBgp4V2PeerNegotiatedTimersEntry=aristaBgp4V2PeerNegotiatedTimersEntry, aristaBgp4V2PeerHoldTime=aristaBgp4V2PeerHoldTime, aristaBgp4V2PeerKeepAlive=aristaBgp4V2PeerKeepAlive, aristaBgp4V2PeerCountersTable=aristaBgp4V2PeerCountersTable, aristaBgp4V2PeerCountersEntry=aristaBgp4V2PeerCountersEntry, aristaBgp4V2PeerInUpdates=aristaBgp4V2PeerInUpdates, aristaBgp4V2PeerOutUpdates=aristaBgp4V2PeerOutUpdates, aristaBgp4V2PeerInTotalMessages=aristaBgp4V2PeerInTotalMessages, aristaBgp4V2PeerOutTotalMessages=aristaBgp4V2PeerOutTotalMessages, aristaBgp4V2PeerFsmEstablishedTransitions=aristaBgp4V2PeerFsmEstablishedTransitions, aristaBgp4V2PrefixGaugesTable=aristaBgp4V2PrefixGaugesTable, aristaBgp4V2PrefixGaugesEntry=aristaBgp4V2PrefixGaugesEntry, aristaBgp4V2PrefixGaugesAfi=aristaBgp4V2PrefixGaugesAfi, aristaBgp4V2PrefixGaugesSafi=aristaBgp4V2PrefixGaugesSafi, aristaBgp4V2PrefixInPrefixes=aristaBgp4V2PrefixInPrefixes, aristaBgp4V2PrefixInPrefixesAccepted=aristaBgp4V2PrefixInPrefixesAccepted, aristaBgp4V2PrefixOutPrefixes=aristaBgp4V2PrefixOutPrefixes, aristaBgp4V2NlriTable=aristaBgp4V2NlriTable, aristaBgp4V2NlriEntry=aristaBgp4V2NlriEntry, aristaBgp4V2NlriIndex=aristaBgp4V2NlriIndex, aristaBgp4V2NlriAfi=aristaBgp4V2NlriAfi, aristaBgp4V2NlriSafi=aristaBgp4V2NlriSafi, aristaBgp4V2NlriPrefixType=aristaBgp4V2NlriPrefixType, aristaBgp4V2NlriPrefix=aristaBgp4V2NlriPrefix, aristaBgp4V2NlriPrefixLen=aristaBgp4V2NlriPrefixLen, aristaBgp4V2NlriBest=aristaBgp4V2NlriBest, aristaBgp4V2NlriCalcLocalPref=aristaBgp4V2NlriCalcLocalPref, aristaBgp4V2NlriOrigin=aristaBgp4V2NlriOrigin, aristaBgp4V2NlriNextHopAddrType=aristaBgp4V2NlriNextHopAddrType, aristaBgp4V2NlriNextHopAddr=aristaBgp4V2NlriNextHopAddr, aristaBgp4V2NlriLinkLocalNextHopAddrType=aristaBgp4V2NlriLinkLocalNextHopAddrType, aristaBgp4V2NlriLinkLocalNextHopAddr=aristaBgp4V2NlriLinkLocalNextHopAddr, aristaBgp4V2NlriLocalPrefPresent=aristaBgp4V2NlriLocalPrefPresent, aristaBgp4V2NlriLocalPref=aristaBgp4V2NlriLocalPref, aristaBgp4V2NlriMedPresent=aristaBgp4V2NlriMedPresent, aristaBgp4V2NlriMed=aristaBgp4V2NlriMed, aristaBgp4V2NlriAtomicAggregate=aristaBgp4V2NlriAtomicAggregate, aristaBgp4V2NlriAggregatorPresent=aristaBgp4V2NlriAggregatorPresent, aristaBgp4V2NlriAggregatorAS=aristaBgp4V2NlriAggregatorAS, aristaBgp4V2NlriAggregatorAddr=aristaBgp4V2NlriAggregatorAddr, aristaBgp4V2NlriAsPathCalcLength=aristaBgp4V2NlriAsPathCalcLength, aristaBgp4V2NlriAsPathString=aristaBgp4V2NlriAsPathString, aristaBgp4V2NlriAsPath=aristaBgp4V2NlriAsPath, aristaBgp4V2NlriPathAttrUnknown=aristaBgp4V2NlriPathAttrUnknown, aristaBgp4V2AdjRibsOutTable=aristaBgp4V2AdjRibsOutTable, aristaBgp4V2AdjRibsOutEntry=aristaBgp4V2AdjRibsOutEntry, aristaBgp4V2AdjRibsOutIndex=aristaBgp4V2AdjRibsOutIndex, aristaBgp4V2AdjRibsOutRoute=aristaBgp4V2AdjRibsOutRoute, aristaBgp4V2Conformance=aristaBgp4V2Conformance, aristaBgp4V2Compliances=aristaBgp4V2Compliances, aristaBgp4V2Groups=aristaBgp4V2Groups)

# Notifications
mibBuilder.exportSymbols("ARISTA-BGP4V2-MIB", aristaBgp4V2EstablishedNotification=aristaBgp4V2EstablishedNotification, aristaBgp4V2BackwardTransitionNotification=aristaBgp4V2BackwardTransitionNotification)

# Groups
mibBuilder.exportSymbols("ARISTA-BGP4V2-MIB", aristaBgp4V2GlobalsGroup=aristaBgp4V2GlobalsGroup, aristaBgp4V2StdMIBTimersGroup=aristaBgp4V2StdMIBTimersGroup, aristaBgp4V2StdMIBCountersGroup=aristaBgp4V2StdMIBCountersGroup, aristaBgp4V2StdMIBErrorsGroup=aristaBgp4V2StdMIBErrorsGroup, aristaBgp4V2StdMIBPeerGroup=aristaBgp4V2StdMIBPeerGroup, aristaBgp4V2StdMIBNlriGroup=aristaBgp4V2StdMIBNlriGroup, aristaBgp4V2StdMIBNotificationGroup=aristaBgp4V2StdMIBNotificationGroup)

# Compliances
mibBuilder.exportSymbols("ARISTA-BGP4V2-MIB", aristaBgp4V2Compliance=aristaBgp4V2Compliance)
