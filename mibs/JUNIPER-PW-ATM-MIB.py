# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-PW-ATM-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:55 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( AtmVcIdentifier, AtmVpIdentifier, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVcIdentifier", "AtmVpIdentifier")
( InterfaceIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
( jnxMibs, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
( jnxVpnPwIndex, jnxVpnPwVpnName, jnxVpnPwVpnType, ) = mibBuilder.importSymbols("JUNIPER-VPN-MIB", "jnxVpnPwIndex", "jnxVpnPwVpnName", "jnxVpnPwVpnType")
( PerfCurrentCount, PerfIntervalCount, ) = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfCurrentCount", "PerfIntervalCount")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "mib-2")
( RowPointer, RowStatus, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "RowStatus", "TruthValue")

# Objects

jnxPWAtmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 57)).setRevisions(("2009-09-01 00:00",))
if mibBuilder.loadTexts: jnxPWAtmMIB.setOrganization("Pseudo-Wire Emulation Edge-to-Edge (PWE3)\nWorking Group")
if mibBuilder.loadTexts: jnxPWAtmMIB.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxPWAtmMIB.setDescription("This MIB module defines objects used for managing \nthe atm pseudowires in Juniper products.")
jnxpwAtmNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 57, 0))
jnxpwAtmObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1))
jnxpwAtmCfgTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 1))
if mibBuilder.loadTexts: jnxpwAtmCfgTable.setDescription("This table specifies generic information for an ATM PW\nto be carried over PSN in any mode.")
jnxpwAtmCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 1, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwAtmCfgEntry.setDescription("This table contains a set of parameters for\nthe ATM PW that needs to be adapted and carried\nover PSN. This table is indexed by pwIndex from\npwTable. An entry is created for every newly ATM\ntype associated pwIndex in the pwTable. Unless\notherwise specified, all read-write objects in\nthis table MAY be changed when the PW is defined\nas not active and all RW objects values must\npersist after reboot")
jnxpwAtmCfgMaxCellConcatenation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmCfgMaxCellConcatenation.setDescription("The maximum number of ATM cells that can be\nconcatenated into one PW packet towards PSN.\nIn non LDP or other signaling protocol environment,\nthis object MAY be changed at anytime, but traffic\nmight be interuppted, otherwise, it may be changed\nwhen PW is not active.")
jnxpwAtmCfgFarEndMaxCellConcatenation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmCfgFarEndMaxCellConcatenation.setDescription("The maximum number of ATM cells that can be\nconcatenated into one PW packet towards PSN as reported by\nthe far end. If no LDP in use, the object will either\nreturn value 0 or allow setting it for calculating\nprotocol overhead.")
jnxpwAtmCfgTimeoutMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("notApplicable", 1), ("disabled", 2), ("enabled", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmCfgTimeoutMode.setDescription("This objects determines whether a packet can be\ntransmitted to the PSN based on time out expiration\nfor collecting cells or not. The actual handling of the\ntime out is implementation specific-as such this object\nmay be changed at any time under proper consideration of\ntraffic interupption effect.")
jnxpwAtmClpQosMapping = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmClpQosMapping.setDescription("This Object indicates whether the CLP bits should be\nconsidered when setting the value in the Quality\nof Service fields of the encapsulating protocol\n(e.g. EXP fields of the MPLS Label Stack).  Selecting\nTrue allows the drop precedence to be preserved\nacross the PSN. In transparent cell transport,\nthe value of this object MUST be false(2), in other\ncases it can be changed at any time.")
jnxpwAtmOutboundNto1Table = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2))
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1Table.setDescription("This table specifies the information for an ATM PW to\nbe carried over PSN in the outbound direction. Up to\nN entries can be created in this table for every\nentry in the pwTable with a pwType equal to:\natmCellNto1Vcc(9), or atmCellNto1Vpc(10).\n  An entry can be created only when the VP/VC are known.\nA single entry will be created in this table for every\nentry in the pwTable with a pwType equal to\none of the following: atmCell1to1Vcc(12), or\natmCell1to1Vpc(13), or atmAal5PduVcc(14), or\natmAal5SduVcc(2), or atmTransparent(3).")
jnxpwAtmOutboundNto1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1Entry.setDescription("A row in this table represents an ATM PW that needs to be\nadapted and carried over PSN. This table is indexed by\npwIndex from pwTable and the ATM interface with VPL/ VCLs.\nIn atmTransparent(3), Vpi and VCi will be 0xFFFF\nduring set operation.\nUnless otherwise specified, all read-create objects in this\ntable MUST NOT be changed after row activation\nand SHOULD remain unchanged after reboot.")
jnxpwAtmOutboundNto1AtmIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1AtmIf.setDescription("The ATM Interface that receives cells from the ATM network.")
jnxpwAtmOutboundNto1Vpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 2), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1Vpi.setDescription("VPI value of this ATM PW. In atmTransparent(3),\nVpi will be the equivalent of 0xFFFF")
jnxpwAtmOutboundNto1Vci = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 3), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1Vci.setDescription("VCI value of this ATM PW. In atmTransparent(3), or\nVP case, the value will be the equivalent of\n0xFFFF")
jnxpwAtmOutboundNto1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 4), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1RowStatus.setDescription("This Object is used to create, modify or delete a row in\nthis table.")
jnxpwAtmOutboundNto1TrafficParamDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1TrafficParamDescr.setDescription("This object represents a pointer to a ATM traffic parameter\nspecific row in either private or standard table which will\nbe employed while receiving cells from the ATM network.\nThis table should contain a set\nof self-consistent ATM traffic parameters including the ATM\ntraffic service category. A value of 0.0 indicates Best\nEffort.")
jnxpwAtmOutboundNto1MappedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 6), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1MappedVpi.setDescription("The egress generated VPI value of this ATM PW. The\nentry is valid for PW type of atmCellNto1Vcc(9),\natmCellNto1Vpc(10), atmCell1to1Vcc(12), or\natmCell1to1Vpc(13). In other types, the value will be the\nequivalent of 0xFFFF. Value MAY be changed when the\nPW is defined as not active ")
jnxpwAtmOutboundNto1MappedVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 2, 1, 7), AtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmOutboundNto1MappedVci.setDescription("The egress generated VCI value of this ATM PW. The\nentry is valid for PW type of atmCellNto1Vcc(9),\natmCellNto1Vpc(10), atmCell1to1Vcc(12), or\natmCell1to1Vpc(13. In VP case or other types, the\nvalue will be the equivalent of 0xFFFF.\nValue MAY be changed when the PW is defined\nas not active.")
jnxpwAtmInboundNto1Table = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3))
if mibBuilder.loadTexts: jnxpwAtmInboundNto1Table.setDescription("This table specifies the information for an ATM PW to\nbe carried over PSN in the Inbound direction. Up to\nN entries can be created in this table for every\nentry in the pwTable with a pwType equal to:\natmCellNto1Vcc(9), or atmCellNto1Vpc(10).\n  An entry can be created only when the VP/VC are known.\nA single entry will be created in this table for every\nentry in the pwTable with a pwType equal to\none of the following:atmCell1to1Vcc(12), or\natmCell1to1Vpc(13), or atmAal5PduVcc(14), or\natmAal5SduVcc(2), or atmTransparent(3).")
jnxpwAtmInboundNto1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwAtmInboundNto1Entry.setDescription("A row in this table represents an ATM PW that needs to be\nadapted and carried over PSN. This table is indexed by\npwIndex from pwTable and the ATM interface with VPL/ VCLs.\nIn atmTransparent(3), Vpi and VCi will be 0xFFFF\nduring set operation.\nUnless otherwise specified, all Read-Creat objects in this\ntable MUST NOT be changed after row activation\nand SHOULD remain unchanged after reboot.")
jnxpwAtmInboundNto1AtmIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1AtmIf.setDescription("The ATM Interface that receives cells from the ATM network.")
jnxpwAtmInboundNto1Vpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 2), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1Vpi.setDescription("VPI value of this ATM PW. In atmTransparent(3),\nVpi will be the equivalent of 0xFFFF.")
jnxpwAtmInboundNto1Vci = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 3), AtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1Vci.setDescription("VCI value of this ATM PW. In atmTransparent(3), or\nVP case, the value will be the equivalent of\n0xFFFF")
jnxpwAtmInboundNto1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 4), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1RowStatus.setDescription("This Object is used to create, modify or delete a row in\nthis table.")
jnxpwAtmInboundNto1TrafficParamDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1TrafficParamDescr.setDescription("This object represents a pointer to a ATM traffic parameter\nspecific row in either private or standard table which will\nbe employed while receiving cells from the ATM network.\nThis table should contain a set\nof self-consistent ATM traffic parameters including the ATM\ntraffic service category. A value of 0.0 indicates Best\nEffort.")
jnxpwAtmInboundNto1MappedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 6), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1MappedVpi.setDescription("The generated VPI value of this ATM PW. The\nentry is valid for PW type of atmCellNto1Vcc(9),\natmCellNto1Vpc(10), atmCell1to1Vcc(12), or\natmCell1to1Vpc(13). In other types, the value will be the\nequivalent of 0xFFFF. Value MAY be changed when the\nPW is defined as not active.")
jnxpwAtmInboundNto1MappedVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 3, 1, 7), AtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmInboundNto1MappedVci.setDescription("The generated VCI value of this ATM PW. The\nentry is valid for PW type of atmCellNto1Vcc(9),\natmCellNto1Vpc(10), atmCell1to1Vcc(12), or\natmCell1to1Vpc(13. In VP case or other types, the\nvalue will be the equivalent of 0xFFFF.\nValue MAY be changed when the\nPW is defined as not active.")
jnxpwAtmPerfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4))
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentTable.setDescription("The current 15 minute interval counts are in\nthis table.\nThis table provides performance information per ATM PW.")
jnxpwAtmPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentEntry.setDescription("An entry in this table is created by the agent for every\npwAtmCfgTable entry. After 15 minutes, the contents of this\ntable entry are copied to a new entry in the\npwAtmPerfInterval table and the counts in this entry\nare reset to zero.")
jnxpwAtmPerfCurrentMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentMissingPkts.setDescription("Number of missing packets (as detected via control word\nsequence number gaps).")
jnxpwAtmPerfCurrentPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentPktsReOrder.setDescription("Number of packets detected out of sequence (via control\nword sequence number), but successfully re-ordered.\nNote: some implementations may not support this Feature.")
jnxpwAtmPerfCurrentPktsMisOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentPktsMisOrder.setDescription("Number of packets detected out of order (via control word\nsequence numbers).")
jnxpwAtmPerfCurrentPktsTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentPktsTimeout.setDescription("Number of packets transmitted due to timeout expiration\nwhile attempting to collect cells.")
jnxpwAtmPerfCurrentPktsXmit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentPktsXmit.setDescription("Number of transmitted packets.")
jnxpwAtmPerfCurrentCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentCellsDropped.setDescription("Number of dropped cells.")
jnxpwAtmPerfCurrentPktsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentPktsReceived.setDescription("Number of received packets.")
jnxpwAtmPerfCurrentUnknownCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfCurrentUnknownCells.setDescription("Number of cells received from the PSN with unknown VPI or\nVCI values. This object is relevant only in N:1 mode.")
jnxpwAtmPerfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5))
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalTable.setDescription("This table provides performance information per ATM PW\nsimilar to the pwAtmPerfCurrentTable above. However,\nthese counts represent historical 15 minute intervals.\nTypically, this table will have a maximum of 96 entries\nfor a 24 hour period. ")
jnxpwAtmPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"), (0, "JUNIPER-PW-ATM-MIB", "jnxpwAtmPerfIntervalNumber"))
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalEntry.setDescription("An entry in this table is created by the agent for\nevery pwAtmPerfCurrentEntry that is 15 minutes old.\nThe contents of the Current entry are copied to the new\nentry here. The Current entry, then resets its counts\nto zero for the next current 15 minute interval. ")
jnxpwAtmPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalNumber.setDescription("A number (normally between 1 and 96 to cover a 24 hour\nperiod) which identifies the interval for which the set\nof statistics is available. The interval identified by 1\nis the most recently completed 15 minute interval, and\nthe interval identified by N is the interval immediately\npreceding the one identified by N-1. The minimum range of\nN is 1 through 4. The default range is 1 through 32. The\nmaximum value of N is 96.")
jnxpwAtmPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalValidData.setDescription("This variable indicates if the data for this interval\nis valid.")
jnxpwAtmPerfIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalDuration.setDescription("The duration of a particular interval in seconds,\nAdjustments in the system's time-of-day clock, may\ncause the interval to be greater or less than, the\nnormal value. Therefore this actual interval value\nis provided.")
jnxpwAtmPerfIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalMissingPkts.setDescription("Number of missing packets (as detected via control\nword sequence number gaps).")
jnxpwAtmPerfIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalPktsReOrder.setDescription("Number of packets detected out of sequence (via control\nword sequence number), but successfully re-ordered.\nNote: some implementations may not support this\nFeature.")
jnxpwAtmPerfIntervalPktsMisOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalPktsMisOrder.setDescription("Number of packets detected out of order (via control word\nsequence numbers).")
jnxpwAtmPerfIntervalPktsTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalPktsTimeout.setDescription("Number of packets transmitted due to timeout expiration.")
jnxpwAtmPerfIntervalPktsXmit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalPktsXmit.setDescription("Number of transmitted packets.")
jnxpwAtmPerfIntervalCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalCellsDropped.setDescription("Number of dropped cells.")
jnxpwAtmPerfIntervalPktsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalPktsReceived.setDescription("Number of received packets.")
jnxpwAtmPerfIntervalUnknownCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 5, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerfIntervalUnknownCells.setDescription("Number of cells received from the PSN  with unknown VPI or\nVCI values. This object is relevant only in N:1 mode.")
jnxpwAtmPerf1DayIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6))
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalTable.setDescription("This table provides performance information per ATM PW\nsimilar to the pwAtmPerfIntervalTable above. However,\nthese counters represent historical 1 day intervals up to\none full month.")
jnxpwAtmPerf1DayIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"), (0, "JUNIPER-PW-ATM-MIB", "jnxpwAtmPerf1DayIntervalNumber"))
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalEntry.setDescription("An entry is created in this table by the agent\nfor every entry in the pwAtmCfgTable table.")
jnxpwAtmPerf1DayIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 365))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalNumber.setDescription("The number of interval, where 1 indicates current day\nmeasured period and 2 and above indicate previous days\nrespectively")
jnxpwAtmPerf1DayIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalValidData.setDescription("This object indicates if the data for this interval\nis valid.")
jnxpwAtmPerf1DayIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalDuration.setDescription("The duration of a particular interval in seconds,\nAdjustments in the system's time-of-day clock, may\ncause the interval to be greater or less than, the\nnormal value. Therefore this actual interval value\nis provided.")
jnxpwAtmPerf1DayIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalMissingPkts.setDescription("Number of missing packets (as detected via control word\nsequence number gaps).")
jnxpwAtmPerf1DayIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalPktsReOrder.setDescription("Number of packets detected out of sequence (via control\nword sequence number), but successfully re-ordered.\nNote: some implementations may not support this\nfeature.")
jnxpwAtmPerf1DayIntervalPktsMisOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalPktsMisOrder.setDescription("Number of packets detected out of order(via control word\nsequence numbers), and could not be re-ordered.")
jnxpwAtmPerf1DayIntervalPktsTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalPktsTimeout.setDescription("Number of packets transmitted due to timeout expiration.")
jnxpwAtmPerf1DayIntervalPktsXmit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalPktsXmit.setDescription("Number of transmitted packets.")
jnxpwAtmPerf1DayIntervalCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalCellsDropped.setDescription("Number of dropped cells.")
jnxpwAtmPerf1DayIntervalPktsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalPktsReceived.setDescription("Number of received packets.")
jnxpwAtmPerf1DayIntervalUnknownCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 57, 1, 6, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwAtmPerf1DayIntervalUnknownCells.setDescription("Number of cells received from the PSN  with unknown VPI\nor VCI value. This object is relevant only in N:1 mode.")
jnxpwAtmConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 57, 2))

# Augmentions

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-PW-ATM-MIB", PYSNMP_MODULE_ID=jnxPWAtmMIB)

# Objects
mibBuilder.exportSymbols("JUNIPER-PW-ATM-MIB", jnxPWAtmMIB=jnxPWAtmMIB, jnxpwAtmNotifications=jnxpwAtmNotifications, jnxpwAtmObjects=jnxpwAtmObjects, jnxpwAtmCfgTable=jnxpwAtmCfgTable, jnxpwAtmCfgEntry=jnxpwAtmCfgEntry, jnxpwAtmCfgMaxCellConcatenation=jnxpwAtmCfgMaxCellConcatenation, jnxpwAtmCfgFarEndMaxCellConcatenation=jnxpwAtmCfgFarEndMaxCellConcatenation, jnxpwAtmCfgTimeoutMode=jnxpwAtmCfgTimeoutMode, jnxpwAtmClpQosMapping=jnxpwAtmClpQosMapping, jnxpwAtmOutboundNto1Table=jnxpwAtmOutboundNto1Table, jnxpwAtmOutboundNto1Entry=jnxpwAtmOutboundNto1Entry, jnxpwAtmOutboundNto1AtmIf=jnxpwAtmOutboundNto1AtmIf, jnxpwAtmOutboundNto1Vpi=jnxpwAtmOutboundNto1Vpi, jnxpwAtmOutboundNto1Vci=jnxpwAtmOutboundNto1Vci, jnxpwAtmOutboundNto1RowStatus=jnxpwAtmOutboundNto1RowStatus, jnxpwAtmOutboundNto1TrafficParamDescr=jnxpwAtmOutboundNto1TrafficParamDescr, jnxpwAtmOutboundNto1MappedVpi=jnxpwAtmOutboundNto1MappedVpi, jnxpwAtmOutboundNto1MappedVci=jnxpwAtmOutboundNto1MappedVci, jnxpwAtmInboundNto1Table=jnxpwAtmInboundNto1Table, jnxpwAtmInboundNto1Entry=jnxpwAtmInboundNto1Entry, jnxpwAtmInboundNto1AtmIf=jnxpwAtmInboundNto1AtmIf, jnxpwAtmInboundNto1Vpi=jnxpwAtmInboundNto1Vpi, jnxpwAtmInboundNto1Vci=jnxpwAtmInboundNto1Vci, jnxpwAtmInboundNto1RowStatus=jnxpwAtmInboundNto1RowStatus, jnxpwAtmInboundNto1TrafficParamDescr=jnxpwAtmInboundNto1TrafficParamDescr, jnxpwAtmInboundNto1MappedVpi=jnxpwAtmInboundNto1MappedVpi, jnxpwAtmInboundNto1MappedVci=jnxpwAtmInboundNto1MappedVci, jnxpwAtmPerfCurrentTable=jnxpwAtmPerfCurrentTable, jnxpwAtmPerfCurrentEntry=jnxpwAtmPerfCurrentEntry, jnxpwAtmPerfCurrentMissingPkts=jnxpwAtmPerfCurrentMissingPkts, jnxpwAtmPerfCurrentPktsReOrder=jnxpwAtmPerfCurrentPktsReOrder, jnxpwAtmPerfCurrentPktsMisOrder=jnxpwAtmPerfCurrentPktsMisOrder, jnxpwAtmPerfCurrentPktsTimeout=jnxpwAtmPerfCurrentPktsTimeout, jnxpwAtmPerfCurrentPktsXmit=jnxpwAtmPerfCurrentPktsXmit, jnxpwAtmPerfCurrentCellsDropped=jnxpwAtmPerfCurrentCellsDropped, jnxpwAtmPerfCurrentPktsReceived=jnxpwAtmPerfCurrentPktsReceived, jnxpwAtmPerfCurrentUnknownCells=jnxpwAtmPerfCurrentUnknownCells, jnxpwAtmPerfIntervalTable=jnxpwAtmPerfIntervalTable, jnxpwAtmPerfIntervalEntry=jnxpwAtmPerfIntervalEntry, jnxpwAtmPerfIntervalNumber=jnxpwAtmPerfIntervalNumber, jnxpwAtmPerfIntervalValidData=jnxpwAtmPerfIntervalValidData, jnxpwAtmPerfIntervalDuration=jnxpwAtmPerfIntervalDuration, jnxpwAtmPerfIntervalMissingPkts=jnxpwAtmPerfIntervalMissingPkts, jnxpwAtmPerfIntervalPktsReOrder=jnxpwAtmPerfIntervalPktsReOrder, jnxpwAtmPerfIntervalPktsMisOrder=jnxpwAtmPerfIntervalPktsMisOrder, jnxpwAtmPerfIntervalPktsTimeout=jnxpwAtmPerfIntervalPktsTimeout, jnxpwAtmPerfIntervalPktsXmit=jnxpwAtmPerfIntervalPktsXmit, jnxpwAtmPerfIntervalCellsDropped=jnxpwAtmPerfIntervalCellsDropped, jnxpwAtmPerfIntervalPktsReceived=jnxpwAtmPerfIntervalPktsReceived, jnxpwAtmPerfIntervalUnknownCells=jnxpwAtmPerfIntervalUnknownCells, jnxpwAtmPerf1DayIntervalTable=jnxpwAtmPerf1DayIntervalTable, jnxpwAtmPerf1DayIntervalEntry=jnxpwAtmPerf1DayIntervalEntry, jnxpwAtmPerf1DayIntervalNumber=jnxpwAtmPerf1DayIntervalNumber, jnxpwAtmPerf1DayIntervalValidData=jnxpwAtmPerf1DayIntervalValidData, jnxpwAtmPerf1DayIntervalDuration=jnxpwAtmPerf1DayIntervalDuration, jnxpwAtmPerf1DayIntervalMissingPkts=jnxpwAtmPerf1DayIntervalMissingPkts, jnxpwAtmPerf1DayIntervalPktsReOrder=jnxpwAtmPerf1DayIntervalPktsReOrder, jnxpwAtmPerf1DayIntervalPktsMisOrder=jnxpwAtmPerf1DayIntervalPktsMisOrder, jnxpwAtmPerf1DayIntervalPktsTimeout=jnxpwAtmPerf1DayIntervalPktsTimeout, jnxpwAtmPerf1DayIntervalPktsXmit=jnxpwAtmPerf1DayIntervalPktsXmit, jnxpwAtmPerf1DayIntervalCellsDropped=jnxpwAtmPerf1DayIntervalCellsDropped, jnxpwAtmPerf1DayIntervalPktsReceived=jnxpwAtmPerf1DayIntervalPktsReceived, jnxpwAtmPerf1DayIntervalUnknownCells=jnxpwAtmPerf1DayIntervalUnknownCells, jnxpwAtmConformance=jnxpwAtmConformance)

