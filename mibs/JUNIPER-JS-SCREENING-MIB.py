# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-JS-SCREENING-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:51 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ifName, ) = mibBuilder.importSymbols("IF-MIB", "ifName")
( jnxJsScreening, ) = mibBuilder.importSymbols("JUNIPER-JS-SMI", "jnxJsScreening")
( Bits, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( DisplayString, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString")

# Objects

jnxJsScreenMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1)).setRevisions(("2009-02-04 00:00","2009-01-23 16:44","2007-09-24 00:00",))
if mibBuilder.loadTexts: jnxJsScreenMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxJsScreenMIB.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\n\nE-mail: support@juniper.net\nHTTP://www.juniper.net")
if mibBuilder.loadTexts: jnxJsScreenMIB.setDescription("This module defines the MIB for Juniper Enterprise Firewall \nscreen functionality.  Juniper documentation is recommended\nas the reference. \n\nJuniper Security Firewall provides various detection methods\nand defense mechanisms to combat exploits at all stages of \nthe path of execution.  These includes:\n               Setting screen options\n               Firwall DOS attacks\n               Network DOS attack \n               OS specific DOS attack   \n               Fragment reassembly ")
jnxJsScreenNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 0))
jnxJsScreenObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1))
jnxJsScreenMonTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1))
if mibBuilder.loadTexts: jnxJsScreenMonTable.setDescription("Juniper security Firewall can allow DI protection on each of\nthe device's physical interface. This table collects the \nscreen attributes that monitor the various attacks. \n\n  The screen options can be enabled at security zone bounded to \na interface or interfaces. When these options apply to traffic \nreaching the device through interfaces (via a zone), they offers \nprotection against malicious information gathering probe or \nan attack to compromise, disable, or harm a network or network \nresources.")
jnxJsScreenMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1)).setIndexNames((1, "JUNIPER-JS-SCREENING-MIB", "jnxJsScreenZoneName"))
if mibBuilder.loadTexts: jnxJsScreenMonEntry.setDescription("The screen option monitoring statistics entry.  Each \nentry is uniquely identified by the zone name.\n\nThe data is collected on a per zone basis. There \ncan be multiple interfaces bound to a particular \nzones.  Hence, the statistics are aggregated across \nthe interfaces on a per zone basis.")
jnxJsScreenZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: jnxJsScreenZoneName.setDescription("The name of the security zone under which the statistics\nare collected. ")
jnxJsScreenNumOfIf = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenNumOfIf.setDescription("Number of interfaces bound to this zone.  Each counter  \ncontains the aggregated data of all the interfaces")
jnxJsScreenMonSynAttk = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynAttk.setDescription("The SYN (TCP connection request) attack is a common denial \nof service (DoS) technique characterized by the following \npattern:\n- Using a spoofed IP address not in use on the Internet, \nan attacker sends multiple SYN packets to the target machine.\n\n- For each SYN packet received, the target machine allocates \nresources and sends an acknowledgement (SYN-ACK) to the source \nIP address.  This can cause the target machine to allocate \nresources for more than 3 minutes to respond to just one i\nSYN attack, hence wasting resources.\n\nThis attribute records the number of SYN attacks.")
jnxJsScreenMonTearDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTearDrop.setDescription("Teardrop attacks exploit the reassembly of fragmented IP \npackets. In the IP header, one of the fields is the fragment \noffset field, which indicates one of the fields is the fragment \noffset field.  It indicates the starting position of the data \ncontained in a fragmented packet relative to the data of the \noriginal unfragmented packet. When the sum of the offset and \nsize of one fragmented packet differ from that of the next \nfragmented packet, the packets overlap. The server attempting \nto reassemble the packet can crash, especially if it is running \nan older operating system that has this vulnerability. \n\nWhen this option is enabled, the security device detects this \ndiscrepancy in a fragmented packet and drops it and this \nattribute counts the number of packets dropped.")
jnxJsScreenMonSrcRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSrcRoute.setDescription("IP source route options can be used to hide their true address \nand access restricted areas of a network by specifying a \ndifferent path. The security device should be able to either \nblock any packets with loose or strict source route options \nset or detect such packets and then record the event for the \ningress interface.\n\nThis attribute records either the loose source route option or\nstrict source route attack packets.")
jnxJsScreenMonPingDeath = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonPingDeath.setDescription("The maximum allowable IP packet size is 65,535 bytes, \nincluding the packet header (typically 20 bytes long). \nAn ICMP echo request is an IP packet with a pseudo header, \nwhich is 8 bytes long. Therefore, the maximum allowable \nsize of the data area of an ICMP echo request is 65,507 \nbytes. \n\nHowever, many ping implementations allow the user to specify \na packet size larger than 65,507 bytes. A grossly oversized \nICMP packet can trigger a range of adverse system reactions \nsuch as denial of service (DoS), crashing, freezing, and \nrebooting.   \n\nWhen the Ping Death option is enabled, the device detects and \nrejects such oversized and irregular packet sizes even when \nthe attacker hides the total packet size by purposefully \nfragmenting it. \n\nThis attributes counts the  ping of death attack packets.")
jnxJsScreenMonAddrSpoof = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonAddrSpoof.setDescription("One method to gain access to a restricted network is to insert \na bogus source address in the packet header to make the packet \nappear to come from a trusted source. This technique is called \nIP spoofing. The mechanism to detect IP spoofing relies on \nroute table entries. \n   \nFor example, if a packet with source IP address 10.1.1.6 arrives \nat port eth3, but the device has a route to 10.1.1.0/24 through \nport eth1. IP spoofing checking notes that this address arrived \nat an invalid interface as defined in the route table. A valid\npacket from 10.1.1.6 can only arrive via eth1, not eth3.  The \ndevice concludes that the packet has a spoofed source IP address \nand discards it. \n\nThis attribute records the address spoofing attack packets.")
jnxJsScreenMonLand = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonLand.setDescription("A combined SYN attack with IP spoof is referred to as \nLand attack.  A Land attack occurs when an attacker sends \nspoofed SYN packets containing the IP address of the victim as \nboth the destination and source IP address. The receiving \nsystem responds by sending the SYN-ACK packet to itself, \ncreating an empty connection that lasts until the idle timeout \nvalue is reached. Flooding a system with such empty connections \ncan overwhelm the system, causing a DoS. \n\nThis attribute records the land attack packets.")
jnxJsScreenMonIcmpFlood = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpFlood.setDescription("An ICMP flood typically occurs when ICMP echo requests overload \nits victim with so many requests that it expends all its \nresources responding until it can no longer process valid network \ntraffic. With the ICMP flood protection feature enabled, and a \nthreshold set.  If the threshold exceeded,  the system invokes the \nflood attack protection feature.  \n\nThe default threshold value is 1000 packets per second. If the \nthreshold is exceeded, the security device ignores further \nICMP echo requests for the remainder of that second plus the \nnext second as well. \n\nThis attribute records the ICMP flood attack packets.")
jnxJsScreenMonUdpFlood = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonUdpFlood.setDescription("UDP flooding occurs when an attacker sends IP packets containing\nUDP datagrams with the purpose of slowing down the victim to the \npoint that it can no longer handle valid connections. With the \nUDP flood protection feature enabled, a threshold can be set which \nonce exceeded, the system invokes the UDP flood attack protection \nfeature. \n\nThe default threshold value is 1000 packets per second. \nIf the number of UDP datagrams from one or more sources to a \nsingle destination exceeds this threshold, security device \nignores further UDP datagrams to that destination for the \nremainder of that second plus the next second as well. \n   \nThis attribute records the UDP flood attack packets.")
jnxJsScreenMonWinnuke = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonWinnuke.setDescription("WinNuke is a DoS attack targeting any computer on the internet \nrunning Windows.  The attacker sends a TCP segment, usually to \nNetBIOS port 139 with the urgent (URG) flag set, to a host with \nan established connection. This introduces a NetBIOS fragment \noverlap, which causes many machines running Windows to crash. \n\nThis attributes counts the netbios attack.")
jnxJsScreenMonPortScan = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonPortScan.setDescription("A port scan occurs when one source IP address sends IP packets \ncontaining TCP SYN segments to a defined number of different \nports at the same destination IP address within a defined interval. \nThe purpose of this attack is to scan the available services in \nthe hope that at least one port will respond, thus identifying \na service of the target. The device should internally log the \nnumber of different ports scanned from one remote source. \n\nThis attribute records the port scan attempt attack packets.")
jnxJsScreenMonIpSweep = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpSweep.setDescription("An address sweep occurs when one source IP address sends a \ndefined number of ICMP packets to different hosts within a \ndefined interval. The purpose of this attack is to send ICMP \npackets, typically echo requests, to various hosts in the \nhope that at least one replies, thus uncovering an address of \nthe target. The device internally log the number of ICMP packets \nto different addresses from one remote source. \n\nThis attributes records the address sweep attemp attack packets.")
jnxJsScreenMonSynFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynFrag.setDescription("IP encapsulates a TCP SYN segment in the IP packet that initiates \na TCP connection. The purpose is to initiate a connection and to \ninvoke a SYN/ACK segment response.  The SYN segment typically does \nnot contain any data since the IP packet is small and there is \nno legitimate reason for it to be fragmented. A fragmented SYN \npacket is anomalous and is suspectful. To be cautious, it might \nbe helpful to block such these fragments from entering the \nprotected network. \n\nWhen the syn fragmentation check is enable,  the security device \ndetects and drops the packets when the IP header indicates that \nthe packet has been fragmented while the SYN flag is set in the \nTCP header.  \n\nThis attributes records the detection of the SYN fragments.")
jnxJsScreenMonTcpNoFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpNoFlag.setDescription("A normal TCP segment header has at least one flag control set. \nA TCP segment with no control flags set is an anomalous event.  \nOperating systems respond to such anomalies in different ways. \nThe response, or even lack of response, from the targeted device \ncan provide a clue as to the target's OS type. \n\nWhen this option is enabled, if the device discovers such a \nheader with a missing or malformed flags field, it drops the\npacket. \n\nThe attribure records the detection of TCP without flag set packets.")
jnxJsScreenMonIpUnknownProt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpUnknownProt.setDescription("According to RFC 1700, some protocol types in IP header are \nreserved and unassigned at this time. Precisely because these \nprotocols are undefined, there is no way to know in advance \nif a particular unknown protocol is benign or malicious.  Unless \nyour network makes use of a non-standard protocol with reserved \nor unassigned protocol number, a cautious stance is to block \nsuch unknown elements from entering your protected network. \n\nWhen the Unknown Protocol Protection SCREEN option is enabled, \nthe security device drops packets when the protocol field \ncontains a protocol ID number of 137 or greater by default. \n\nThis attribute records the detection of Unknown protocol \nIP packets.")
jnxJsScreenMonIpOptBad = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptBad.setDescription("IP protocol specifies a set of eight options that provide \nspecial routing controls, diagnostic tools, and security. \nThese eight options can be used for malicious objectives.\n\nEither intentionally or accidentally, attackers sometimes \nmisconfigure IP options, producing either incomplete or \nmalformed fields. The misformatting is anomalous and \npotentially harmful to the intended recipient. \n\nWhen the Bad IP Option Protection SCREEN option is enabled, \nthe security device detects and blocks packets when any IP \noption in the IP packet header is incorrectly formatted. \n\nThis attributes records the detection of the IP bad option\npackets.")
jnxJsScreenMonIpOptRecRt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptRecRt.setDescription("The IP standard RFC 791 specifies a set of options to provide \nspecial routing controls, diagnostic tools, and security. \nThese options appear after the destination address in an IP packet \nheader.  When they do appear, they are frequently being put to \nsome nefarious use.  Record option is one of these options that an \nattacker can use for reconnaissance or for some unknown but \nsuspicious purpose \n\nWhen record IP option is received, the security device \nflags this as an network reconnaissance attack and records \nthe event for the ingress interface. \n\nThis attribute records the detection of IP record option \npackets.")
jnxJsScreenMonIpOptTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptTimestamp.setDescription("The IP standard RFC 791 specifies a set of options to provide \nspecial routing controls, diagnostic tools, and security. \nThese options appear after the destination address in an IP packet \nheader.  When they do appear, they are frequently being put to \nsome nefarious use.  Timestamp is one of these options that an \nattacker can use for reconnaissance or for some unknown but \nsuspicious purpose \n\nWhen timestamp IP option is received, the security device \nflags this as an network reconnaissance attack and records \nthe event for the ingress interface. \n\nThis attribute records the detection of IP timestamp option \npackets.")
jnxJsScreenMonIpOptSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptSecurity.setDescription("The IP standard RFC 791 specifies a set of options to provide \nspecial routing controls, diagnostic tools, and security. \nThese options appear after the destination address in an IP packet \nheader.  When they do appear, they are frequently being put to \nsome nefarious use.  Security is one of these options that an \nattacker can use for reconnaissance or for some unknown but \nsuspicious purpose \n\nWhen the security IP option is received, the security device \nflags this as an network reconnaissance attack and records \nthe event for the ingress interface. \n\nThis attribute records the detection of IP security option \npackets.")
jnxJsScreenMonIpOptLSR = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptLSR.setDescription("Attackers can use IP source route options to hide their true \naddress and access restricted areas of a network by specifying \na different path.  The security device should be able to either \nblock any packets with loose or strict source route options \nset or detect such packets and then record the event for the \ningress interface. \n\nThis attribute records the detection of loose source route\npackets.")
jnxJsScreenMonIpOptSSR = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptSSR.setDescription("Attackers can use IP source route options to hide their true \naddress and access restricted areas of a network by specifying \na different path.  The security device should be able to either \nblock any packets with loose or strict source route options \nset or detect such packets and then record the event for the \ningress interface. \n\nThis attribute records the detection of strict source route\npackets.")
jnxJsScreenMonIpOptStream = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpOptStream.setDescription("The IP standard RFC 791 specifies a set of options to provide \nspecial routing controls, diagnostic tools, and security. \nThese options appear after the destination address in an IP packet \nheader.  When they do appear, they are frequently being put to \nsome nefarious use.  Stream is one of these options that an \nattacker can use for reconnaissance or for some unknown but \nsuspicious purpose \n\nWhen the security IP option is received, the security device \nflags this as an network reconnaissance attack and records \nthe event for the ingress interface. \n\nThis attribute records the detect of IP stream option \npackets.")
jnxJsScreenMonIcmpFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpFrag.setDescription("ICMP provides error reporting and network probe capabilities. \nICMP packets contain very short messages, there is no legitimate \nreason for ICMP packets to be fragmented. If an ICMP packet is \nso large that it must be fragmented, something has gone amiss. \nWith the ICMP Fragment Protection SCREEN option enabled, the device \nshould be able to block any ICMP packet with the More Fragments \nflag set, or with an offset value indicated in the offset field. \n\nThis attribute counts the ICMP fragment packets.")
jnxJsScreenMonIcmpLarge = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIcmpLarge.setDescription("ICMP packets contain very short messages, there is no legitimate \nreason for ICMP packets to be fragmented. \n\nIf an ICMP packet is unusually large, something is wrong. For example, \nthe Loki program uses ICMP as a channel for transmitting covert \nmessages. The presence of large ICMP packets might expose a \ncompromised machine acting as a Loki agent. It might also indicate \nsome other kind of shifty activity. \n\nWhen the the Large Size ICMP Packet Protection SCREEN option is enabled, \nthe device drops ICMP packets with a length greater than 1024 bytes. \n\nThis attribute records the detection of large ICMP packets.")
jnxJsScreenMonTcpSynFin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpSynFin.setDescription("Both the SYN and FIN control flags are not normally set in the \nsame TCP segment header. The SYN flag synchronizes sequence \nnumbers to initiate a TCP connection. The FIN flag indicates \nthe end of data transmission to finish a TCP connection. Their \npurposes are mutually exclusive. A TCP header with the SYN and \nFIN flags set is anomalous TCP behavior, causing various \nresponses from the recipient, depending on the OS. \n\nWhen block both syn and fin option is enable, the device \ndrops the packet when it discovers such a header \n\nThis attribute records the TCP syn fin both set packet \ndropped.")
jnxJsScreenMonTcpFinNoAck = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonTcpFinNoAck.setDescription("A FIN scan sends TCP segments with the FIN flag set in an \nattempt to provoke a response and thereby discover an active \nhost or an active port on a host. The use of TCP segments \nwith the FIN flag set might evade detection and thereby help \nthe attacker succeed in his or her reconnaissance efforts. \n\nThis attributes records the detection of the TCP fin set \nwithout ack bit set packets.")
jnxJsScreenMonLimitSessSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 28), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonLimitSessSrc.setDescription("All the virus-generated traffic originates from the same IP \naddress (generally from a infected server), a source-based \nsession limit ensures that the firewall can curb such \nexcessive amounts of traffic.  Based on a threshold value,\nif the number of concurrent sessions required to fill up \nthe session table of the particular firewall. \n\nThe default maximum for source-based session limit is 128 \nconcurrent sessions, which can be adjusted to accordingly.\n\nThis attribute records the number of the session connection \nbased on the source IP that exceeds the specified limit.")
jnxJsScreenMonLimitSessDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 29), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonLimitSessDest.setDescription("The user can limit the number of concurrent sessions \nto the same destination IP address.  A wily attacker can \nlaunch a distributed denial-of-service (DDoS) attack using\n'zombie agents'.  Setting a destination-based session limit \ncan ensure that device allows only an acceptable number of \nconcurrent connection requests, no matter what the source, \nto reach any one host. \n\nThe default maximum for destination-based session limit is \n128 concurrent sessions.\n\nThis attribute records the number of session connection based \non the destination source IP address that exceeds the specified \nlimit.")
jnxJsScreenMonSynAckAck = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 30), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynAckAck.setDescription("When an authentication user initiates a Telnet or FTP connection, \nthe user sends a SYN segment to the Telnet or FTP server. The \ndevice intercepts the SYN segment, creates an entry in its \nsession table, and proxies a SYN-ACK segment to the user. The \nuser then replies with an ACK segment. At that point, the initial \n3-way handshake is complete. The device sends a login prompt to \nthe user. When a malicisou user does not log in, but instead \ncontinue initiating SYN-ACK-ACK sessions, the firewall session \ntable can fill up to the point where the device begins rejecting \nlegitimate connection requests. \n\nWhen the SYN-ACK-ACK proxy protection option is enabled, after \nthe number of connections from the same IP address reaches the \nSYN-ACK-ACK proxy threshold, the device rejects further \nconnection requests from that IP address.  By default, the \nthreshold is 512 connections from any single IP address. \n\nThe attribute records the detection of SYN ACK ACK attack.")
jnxJsScreenMonIpFrag = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 31), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonIpFrag.setDescription("As packets travels, it is sometimes necessary to break a packet \ninto smaller fragments based upon the maximum transmission unit \n(MTU) of each network. IP fragments might contain an attacker's \nattempt to exploit the vulnerabilities in the packet reassembly \ncode of specific IP stack implementations. When the victim \nreceives these packets, the results can range from processing \nthe packets incorrectly to crashing the entire system. \n\nWhen the block IP framentation flag is enabled, the device blocks \nall IP packet fragments that it receives at interfaces bound to \nthat zone. \n\nThis attribute counts the number of block IP fragment packets.")
jnxJsScreenSynAttackThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackThresh.setDescription("The number of SYN segments to the same destination address \nand port number per second required to activate the SYN proxying \nmechanism. In order to set the appropriate threshold value, it \nrequires a through knowledge of the normal traffic patterns at site \n\nFor example, if the security device normally gets 2000 SYN \nsegments per second,  the threshold value should be set at \n3000/second. \n\nThis attribute displays the configured SYN attack threshold value.")
jnxJsScreenSynAttackTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackTimeout.setDescription("The maximum length of time before a half-completed connection is \ndropped from the queue. The default is 20 seconds.\n\nThis attributes display the SYN attack timeout value.")
jnxJsScreenSynAttackAlmTh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackAlmTh.setDescription("The syn attack alarm threshold causes an alarm to be generated when \nthe number of proxied, half-complete TCP connection requests per \nsecond requests to the same destination address and port number \nexceeds its value. \n\nThis attribute display the SYN attack alarm threshold value.")
jnxJsScreenSynAttackQueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackQueSize.setDescription("The number of proxied connection requests held in the proxied \nconnection queue before the device starts rejecting new connection\nrequests. \n\nThis attribute displays the SYN attack queue size.\n\nThis object has been deprecated.")
jnxJsScreenSynAttackAgeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAttackAgeTime.setDescription("SYN flood age time.\n\nThis object has been deprecated.")
jnxJsScreenIcmpFloodThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenIcmpFloodThresh.setDescription("ICMP flooding occurs when an attacker sends IP packets containing \nICMP datagrams with the purpose of slowing down the victim to the \npoint that it can no longer handle valid connections. \n\nThis attributes display the ICMP attack alarm threshold value.")
jnxJsScreenUdpFloodThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenUdpFloodThresh.setDescription("UDP flooding occurs when an attacker sends IP packets containing \nUDP datagrams with the purpose of slowing down the victim to the \npoint that it can no longer handle valid connections. \n\nThe default threshold value is 1000 packets per second.\n\nThis attribute displays the UDP attack alarm threshold value.")
jnxJsScreenPortScanThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenPortScanThresh.setDescription("The port scan threshold interval is in microseconds.  The default \nthreshold value is 5000.  The valid threshold range is 1000-1000000. \n\nBy using the default settings, if a remote host scans 10 ports in \n0.005 seconds (5000 microseconds), the device flags this as a \nport scan attack, and rejects all further packets from the remote \nsource for the remainder of the specified timeout period. The \ndevice detects and drops the tenth packet that meets the port scan \nattack criterion.\n\nThis attribute displays the port scan threshold value.")
jnxJsScreenIpSweepThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenIpSweepThresh.setDescription("The IP sweep threshold interval is in microseconds.  The default \nthreshold value is 5000.  The valid threshold range is 1000-1000000. \n\nBy using the default settings, if a remote host sends ICMP traffic \nto 10 addresses in 0.005 seconds (5000 microseconds), the \nsecurity device flags this as an address sweep attack, and \nrejects all further ICMP echo requests from that host for \nthe remainder of the specified threshold time period. The \ndevice detects and drops the tenth packet that meets the address \nsweep attack criterion.\n\nThis attribute holds the UDP attack alarm threshold.")
jnxJsScreenSynAckAckThres = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynAckAckThres.setDescription("SYN ack ack alarm threshold value.")
jnxJsScreenMonThreshTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2))
if mibBuilder.loadTexts: jnxJsScreenMonThreshTable.setDescription("This table is a read-only table that augments the\njnxJsScreenMonTable.  The purpose of this table is\nto keep threshold and counter information about\nSyn Flood and Session Limit.")
jnxJsScreenMonThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1))
if mibBuilder.loadTexts: jnxJsScreenMonThreshEntry.setDescription("Syn Flood and Session Limit thresholds and counts.")
jnxJsScreenSynFloodSrcThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynFloodSrcThresh.setDescription("The number of SYN segments received per second from a single\nsource IP - regardless of the destination IP address and\nport number - before the security device begins dropping \nconnection requests from that source.")
jnxJsScreenSynFloodDstThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSynFloodDstThresh.setDescription("The number of SYN segments received per second from a single\ndestination IP address before the security device begins dropping\nconnection requests to that destination. If a protected host runs\nmultiple services, you might want to set a threshold based on\ndestination IP address only - regardless of the destination\nport number.")
jnxJsScreenSessLimitSrcThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSessLimitSrcThresh.setDescription("The security device can impose a limit on the number of SYN segments\npermitted from a single source IP address.")
jnxJsScreenSessLimitDstThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenSessLimitDstThresh.setDescription("The security device can impose a limit on the number of SYN segments\npermitted to a single destination IP address.")
jnxJsScreenMonSynFloodSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynFloodSrc.setDescription("The number of concurrent sessions from the same source IP address.")
jnxJsScreenMonSynFloodDst = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 1, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxJsScreenMonSynFloodDst.setDescription("The number of concurrent sessions to the same destination IP address.")
jnxJsScreenTrapVars = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2))
jnxJsScreenAttackType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(27,30,6,11,21,9,8,12,19,31,1,17,2,24,20,26,23,18,16,14,3,4,13,10,28,15,7,25,22,5,29,)).subtype(namedValues=NamedValues(("icmpFlood", 1), ("synAttack", 10), ("winNuke", 11), ("tearDrop", 12), ("ipAddressSpoof", 13), ("pingDeath", 14), ("sourceRoute", 15), ("landAttack", 16), ("synFragmentation", 17), ("tcpNoFlag", 18), ("ipUnknownProtocol", 19), ("udpFlood", 2), ("ipOptionBad", 20), ("ipOptionRecRt", 21), ("ipOptionTimeStamp", 22), ("ipOptionSecurity", 23), ("ipOptionLSR", 24), ("ipOptionSRR", 25), ("ipOptionStream", 26), ("icmpFragmentation", 27), ("icmpLarge", 28), ("tcpSynFin", 29), ("portScanning", 3), ("tcpFinNoAck", 30), ("ipFragmentation", 31), ("ipSweeping", 4), ("synfloodSrcIP", 5), ("synfloodDstIP", 6), ("sessLimitSrcBased", 7), ("sessLimitDestBased", 8), ("synAckAck", 9), ))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: jnxJsScreenAttackType.setDescription("The type of attacks that the device support.")
jnxJsScreenAttackCounter = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 2), Integer32()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: jnxJsScreenAttackCounter.setDescription("The threshold value that triggers the trap to be generated.")
jnxJsScreenAttackDescr = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: jnxJsScreenAttackDescr.setDescription("The description pertinent to the attack trap.")
jnxJsScreenCfgStatus = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 2, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: jnxJsScreenCfgStatus.setDescription("The screening option configuration status: enabled or disabled.")

# Augmentions
jnxJsScreenMonEntry.registerAugmentions(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenMonThreshEntry"))
jnxJsScreenMonThreshEntry.setIndexNames(*jnxJsScreenMonEntry.getIndexNames())

# Notifications

jnxJsScreenAttack = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 0, 1)).setObjects(*(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackDescr"), ("IF-MIB", "ifName"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackType"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenZoneName"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackCounter"), ) )
if mibBuilder.loadTexts: jnxJsScreenAttack.setDescription("A per min bytes exceed trap signifies that the number of\nbytes per minutes has exceeds the specified threshold.\n\njnxJsScreenZoneName: the zone name under which the attack \nis occuring.\nifName the interface at which the attack is occuring.\njnxJsScreenAttackType: type of attack.\njnxJsScreenAttackCounter: the number of attacks recorded\nbased on the particular screening options enabled. The\nvalue of this counter is the aggregated statistic of all\nthe interfaces bound to the mentioned zone. \njnxJsScreenAttackDescr: a general text description of the\nthis attack or the trap.")
jnxJsScreenCfgChange = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 39, 1, 8, 1, 0, 2)).setObjects(*(("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenAttackType"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenZoneName"), ("JUNIPER-JS-SCREENING-MIB", "jnxJsScreenCfgStatus"), ) )
if mibBuilder.loadTexts: jnxJsScreenCfgChange.setDescription("The screening configuration change trap signifies that \nan screening option has been changed(enabled or disabled).  \n\nA disable feature may implies a security hole.\n\njnxJsScreenZoneName is the zone at which the changed option\nis applicable to.\njnxJsScreenAttackType the screen feature.\njnxJsScreenCfgStatus: either enabled or disabled")

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-JS-SCREENING-MIB", PYSNMP_MODULE_ID=jnxJsScreenMIB)

# Objects
mibBuilder.exportSymbols("JUNIPER-JS-SCREENING-MIB", jnxJsScreenMIB=jnxJsScreenMIB, jnxJsScreenNotifications=jnxJsScreenNotifications, jnxJsScreenObjects=jnxJsScreenObjects, jnxJsScreenMonTable=jnxJsScreenMonTable, jnxJsScreenMonEntry=jnxJsScreenMonEntry, jnxJsScreenZoneName=jnxJsScreenZoneName, jnxJsScreenNumOfIf=jnxJsScreenNumOfIf, jnxJsScreenMonSynAttk=jnxJsScreenMonSynAttk, jnxJsScreenMonTearDrop=jnxJsScreenMonTearDrop, jnxJsScreenMonSrcRoute=jnxJsScreenMonSrcRoute, jnxJsScreenMonPingDeath=jnxJsScreenMonPingDeath, jnxJsScreenMonAddrSpoof=jnxJsScreenMonAddrSpoof, jnxJsScreenMonLand=jnxJsScreenMonLand, jnxJsScreenMonIcmpFlood=jnxJsScreenMonIcmpFlood, jnxJsScreenMonUdpFlood=jnxJsScreenMonUdpFlood, jnxJsScreenMonWinnuke=jnxJsScreenMonWinnuke, jnxJsScreenMonPortScan=jnxJsScreenMonPortScan, jnxJsScreenMonIpSweep=jnxJsScreenMonIpSweep, jnxJsScreenMonSynFrag=jnxJsScreenMonSynFrag, jnxJsScreenMonTcpNoFlag=jnxJsScreenMonTcpNoFlag, jnxJsScreenMonIpUnknownProt=jnxJsScreenMonIpUnknownProt, jnxJsScreenMonIpOptBad=jnxJsScreenMonIpOptBad, jnxJsScreenMonIpOptRecRt=jnxJsScreenMonIpOptRecRt, jnxJsScreenMonIpOptTimestamp=jnxJsScreenMonIpOptTimestamp, jnxJsScreenMonIpOptSecurity=jnxJsScreenMonIpOptSecurity, jnxJsScreenMonIpOptLSR=jnxJsScreenMonIpOptLSR, jnxJsScreenMonIpOptSSR=jnxJsScreenMonIpOptSSR, jnxJsScreenMonIpOptStream=jnxJsScreenMonIpOptStream, jnxJsScreenMonIcmpFrag=jnxJsScreenMonIcmpFrag, jnxJsScreenMonIcmpLarge=jnxJsScreenMonIcmpLarge, jnxJsScreenMonTcpSynFin=jnxJsScreenMonTcpSynFin, jnxJsScreenMonTcpFinNoAck=jnxJsScreenMonTcpFinNoAck, jnxJsScreenMonLimitSessSrc=jnxJsScreenMonLimitSessSrc, jnxJsScreenMonLimitSessDest=jnxJsScreenMonLimitSessDest, jnxJsScreenMonSynAckAck=jnxJsScreenMonSynAckAck, jnxJsScreenMonIpFrag=jnxJsScreenMonIpFrag, jnxJsScreenSynAttackThresh=jnxJsScreenSynAttackThresh, jnxJsScreenSynAttackTimeout=jnxJsScreenSynAttackTimeout, jnxJsScreenSynAttackAlmTh=jnxJsScreenSynAttackAlmTh, jnxJsScreenSynAttackQueSize=jnxJsScreenSynAttackQueSize, jnxJsScreenSynAttackAgeTime=jnxJsScreenSynAttackAgeTime, jnxJsScreenIcmpFloodThresh=jnxJsScreenIcmpFloodThresh, jnxJsScreenUdpFloodThresh=jnxJsScreenUdpFloodThresh, jnxJsScreenPortScanThresh=jnxJsScreenPortScanThresh, jnxJsScreenIpSweepThresh=jnxJsScreenIpSweepThresh, jnxJsScreenSynAckAckThres=jnxJsScreenSynAckAckThres, jnxJsScreenMonThreshTable=jnxJsScreenMonThreshTable, jnxJsScreenMonThreshEntry=jnxJsScreenMonThreshEntry, jnxJsScreenSynFloodSrcThresh=jnxJsScreenSynFloodSrcThresh, jnxJsScreenSynFloodDstThresh=jnxJsScreenSynFloodDstThresh, jnxJsScreenSessLimitSrcThresh=jnxJsScreenSessLimitSrcThresh, jnxJsScreenSessLimitDstThresh=jnxJsScreenSessLimitDstThresh, jnxJsScreenMonSynFloodSrc=jnxJsScreenMonSynFloodSrc, jnxJsScreenMonSynFloodDst=jnxJsScreenMonSynFloodDst, jnxJsScreenTrapVars=jnxJsScreenTrapVars, jnxJsScreenAttackType=jnxJsScreenAttackType, jnxJsScreenAttackCounter=jnxJsScreenAttackCounter, jnxJsScreenAttackDescr=jnxJsScreenAttackDescr, jnxJsScreenCfgStatus=jnxJsScreenCfgStatus)

# Notifications
mibBuilder.exportSymbols("JUNIPER-JS-SCREENING-MIB", jnxJsScreenAttack=jnxJsScreenAttack, jnxJsScreenCfgChange=jnxJsScreenCfgChange)

