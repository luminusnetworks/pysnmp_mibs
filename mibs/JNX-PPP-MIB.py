# PySNMP SMI module. Autogenerated from smidump -f python JNX-PPP-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:55 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InterfaceIndex, InterfaceIndexOrZero, ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero", "ifIndex")
( Ipv6AddressIfIdentifier, ) = mibBuilder.importSymbols("IPV6-TC", "Ipv6AddressIfIdentifier")
( jnxPppMibRoot, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxPppMibRoot")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32")
( RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue")

# Types

class JnxNibbleConfig(Integer32):
    pass

class JnxPppAuthentication(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,0,4,2,3,)
    namedValues = NamedValues(("none", 0), ("pap", 1), ("chap", 2), ("papChap", 3), ("chapPap", 4), )
    
class JnxPppAuthentication2(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,0,2,3,)
    namedValues = NamedValues(("none", 0), ("pap", 1), ("chap", 2), ("eap", 3), )
    
class JnxPppMlPppBundleName(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(1,60)
    

# Objects

jnxPppMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1)).setRevisions(("2013-09-19 09:42","2013-09-19 00:00","2013-06-13 00:00","2012-06-08 00:00","2011-11-29 00:00","2010-07-22 09:42",))
if mibBuilder.loadTexts: jnxPppMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxPppMIB.setContactInfo("       Juniper Networks, Inc.\nPostal: 10 Technology Park Drive\n        Westford, MA  01886-3146\n        USA\nTel:    +1 978 589 5800\nEmail:  mib@Juniper.net")
if mibBuilder.loadTexts: jnxPppMIB.setDescription("The Point-to-Point Protocol (PPP) MIB for the Juniper enterprise.")
jnxPPPObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1))
jnxPppLcp = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1))
jnxPppLinkStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1))
if mibBuilder.loadTexts: jnxPppLinkStatusTable.setDescription("This table contains entries for PPP interfaces present in the system.")
jnxPppLinkStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppLinkStatusEntry.setDescription("Each entry describes the characteristics of a PPP interface.")
jnxPppLinkStatusTerminateReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(10,0,16,3,17,13,7,15,5,6,12,1,9,14,11,4,8,2,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("keepaliveFailure", 10), ("sessionTimeout", 11), ("inactivityTimeout", 12), ("addressLeaseExpired", 13), ("adminLogout", 14), ("tunnelFailed", 15), ("tunnelDisconnected", 16), ("loopback", 17), ("adminDisable", 2), ("lowerLayerDown", 3), ("noUpperInterface", 4), ("authenticationFailure", 5), ("peerTerminated", 6), ("peerRenegotiated", 7), ("maxRetriesExceeded", 8), ("negotiationFailure", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusTerminateReason.setDescription("Reason the PPP link was terminated:\nnone                    None.\nother                   Not specified.\nadminDisable            Interface administratively disabled.\nlowerLayerDown          Underlying interface is down.\nnoUpperInterface        No interface above PPP.\nauthenticationFailure   Authentication failed.\npeerTerminated          Peer initiated termination.\npeerRenegotiated        Peer initiated renegotiation.\nmaxRetriesExceeded      Maximum number of config retries exceeded.\nnegotiationFailure      Failed to negotiate LCP option.                    \nkeepaliveFailure        Keepalive failed.\nsessionTimeout          Maximum session period expired.\ninactivityTimeout       Maximum inactivity period expired.\naddressLeaseExpired     Lease for network address expired.\nadminLogout             Session administratively terminated.\ntunnelFailed            Associated tunnel failed.\ntunnelDisconnected      Associated tunnel disconnected.\nloopback                Loopback detected.")
jnxPppLinkStatusTerminateNegFailOption = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(8,5,0,1,3,6,4,2,7,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("localMru", 2), ("remoteMru", 3), ("localMagicNumber", 4), ("remoteMagicNumber", 5), ("localAuthentication", 6), ("localToRemoteProtocolCompression", 7), ("localToRemoteACCompression", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusTerminateNegFailOption.setDescription("Reports the PPP LCP option for which negotiation failed, \nwhen jnxPppLinkStatusTerminateReason has the value negotiationFailure.")
jnxPppLinkStatusInKeepaliveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusInKeepaliveRequests.setDescription("Number of keepalive requests received.")
jnxPppLinkStatusOutKeepaliveRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusOutKeepaliveRequests.setDescription("Number of keepalive requests transmitted.")
jnxPppLinkStatusInKeepaliveReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusInKeepaliveReplies.setDescription("Number of keepalive replies received.")
jnxPppLinkStatusOutKeepaliveReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusOutKeepaliveReplies.setDescription("Number of keepalive replies transmitted.")
jnxPppLinkStatusKeepaliveFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusKeepaliveFailures.setDescription("Number of keepalive failures detected.")
jnxPppLinkStatusLocalMagicNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusLocalMagicNumber.setDescription("Magic number negotiated for the local side.\nThis has been deprecated and replaced by \njnxPppLinkStatusLocalMagicNumber1")
jnxPppLinkStatusRemoteMagicNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusRemoteMagicNumber.setDescription("Magic number negotiated for the remote side.\nThis has been deprecated and replaced by\njnxPppLinkStatusRemoteMagicNumber1")
jnxPppLinkStatusLocalAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 10), JnxPppAuthentication2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusLocalAuthentication.setDescription("Authentication protocol negotiated for the local side.")
jnxPppLinkStatusTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusTunnelIfIndex.setDescription("The ifIndex of an associated interface pertaining to a tunneling \nprotocol, or zero if no such interface exists.The type of tunneling\ninterface can be identified from information in the entries in \nifTable and jnxIfTable for this tunnel interface.")
jnxPppLinkStatuslcpRenegoTerminates = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatuslcpRenegoTerminates.setDescription("Number of times lcp terminated due to peer exceeding max renegotiation \nattempts.")
jnxPppLinkStatusLocalMagicNumber1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusLocalMagicNumber1.setDescription("Magic number negotiated for the local side.")
jnxPppLinkStatusRemoteMagicNumber1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 1, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkStatusRemoteMagicNumber1.setDescription("Magic number negotiated for the remote side.")
jnxPppLinkConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2))
if mibBuilder.loadTexts: jnxPppLinkConfigTable.setDescription("This table contains entries for PPP interfaces present in the system.")
jnxPppLinkConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1)).setIndexNames((0, "JNX-PPP-MIB", "jnxPppLinkConfigIfIndex"))
if mibBuilder.loadTexts: jnxPppLinkConfigEntry.setDescription("Each entry describes the characteristics of a PPP interface.\nCreating or deleting entries in this table causes corresponding entries \nfor be created or deleted in ifTable,ifXTable,jnxIfTable.")
jnxPppLinkConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppLinkConfigIfIndex.setDescription("The ifIndex of the PPP interface.  When creating entries in this\ntable, suitable values for this object are determined by reading \njnxPppNextIfIndex.")
jnxPppLinkConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigRowStatus.setDescription("Controls creation or deletion of entries in this table with READ-CREATE\nmaximum access according to the RowStatus textual convention,\nconstrained to support the following values only:\n    createAndGo\n    destroy\nTo create an entry in this table, the following entry objects MUST be\n explicitly configured:\n    jnxPppLinkConfigRowStatus\n    jnxPppLinkConfigLowerIfIndex\n\nIn addition, when creating an entry the following conditions must hold:\n    A value for jnxPppLinkConfigIndex must have been determined \n    previously, by reading jnxPppNextIfIndex.The interface identified \n    by jnxPppLinkConfigLowerIfIndex must exist. A corresponding entry  \n   in Table or ifXTable or jnxIfTable is created or destroyed as a \n     result of creating or destroying an entry in this table.\n\n The following values can be read from this object:\n     active(1)")
jnxPppLinkConfigLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigLowerIfIndex.setDescription("The ifIndex of an interface over which this PPP interface is to be \nlayered.A value of zero indicates no layering.  An implementation may\nchoose to require that a non-zero value be configured at entry creation.")
jnxPppLinkConfigKeepalive = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64800)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigKeepalive.setDescription("Keepalive interval in seconds.  A value of zero disables keepalive. \nKeepalive is performed using LCP Echo.")
jnxPppLinkConfigAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 5), JnxPppAuthentication().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigAuthentication.setDescription("Specifies the type(s) of authentication, if any, to be negotiated\nwith the peer:\n none      No authentication is negotiated.\n pap       PAP negotiation only.\n chap      CHAP negotiation only.\n papChap   PAP negotiation is attempted first; if fails, attempt CHAP.\n chapPap   CHAP negotiation is attempted first; if fails, attempt PAP.\n\nIf authentication negotiation is not supported for this PPP interface, \nthen any attempt to explicitely set this object if READ-CREATE maximum\naccess is supported will result in a notWritable error and it will be\nimplicitily set to the DEFVAL on row creation. Setting this object to\nnone(0) will set jnxPppLinkConfigAuthenticatorRouting Instance object\nto an empty string.\nThis object returns a null(0) value on the get operation. New object \njnxPppLinkConfigAuthentication2 will reflect the configured values. Setting\nthis object along with the jnxPppLinkConfigAuthentication2 object will return  \nan inconsistentValue error.")
jnxPppLinkConfigMaxAuthenRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigMaxAuthenRetries.setDescription("The number of authentication retries permitted, in addition to a\nfailed initial attempt.  If all retries fail, the link is reset. \nIf authentication negotiation is not supported for this PPP interface,\nthen any attempt to explicitely set this object  if READ-CREATE \nmaximum access is supported will result in a notWritable error and\nit will be implicitily set to the DEFVAL on row creation.")
jnxPppLinkConfigStandardIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 7), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigStandardIfIndex.setDescription("The ifIndex value for this interface in the standard PPP MIBs. \nThe ifIndex value for PPP interfaces is not the same for both \nproprietary and standard MIB tables pertaining to PPP interface.\nTherefore this value is provide to simply cross referencing \nstandard PPP and proprietary PPP MIB information.")
jnxPppLinkConfigChapMinChallengeLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 63)).clone(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigChapMinChallengeLength.setDescription("Minimum value of the CHAP authenticator challenge length value.\nThis value is never greater than\njnxPppLinkConfigChapMaxChallengeLength.")
jnxPppLinkConfigChapMaxChallengeLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 63)).clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigChapMaxChallengeLength.setDescription("Maximum value of the CHAP authenticator challenge length value. \nThis value is never less than  jnxPppLinkConfigChapMinChallengeLength.")
jnxPppLinkConfigPassiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 10), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigPassiveMode.setDescription("When enabled, LCP state machine is forced into passive mode on lower layer\nUP message.  It adds compatibility with slow and buggy clients.")
jnxPppLinkConfigAuthenticatorLogicalSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigAuthenticatorLogicalSystem.setDescription("The name of the logical system to  be used for authentication on the\nPPP interface.With READ-CREATE maximum access , setting this object \nstatically binds the authenticating logical system with the PPP\ninterface.  If this object is not explicitly set or it is set to null\nstring, then this object is ignored and the virtual router used for\nauthentication is determined by other means. \nOn a Set operation, if the value of this object is not null and does \nnot correspond to an existing virtual router, then an\ninconsistentValue error is returned. Setting this object to a non-null\nstring returns inconsistentValue error if jnxPppLinkConfigAuthentication\nobject is none(0) or not configured.")
jnxPppLinkConfigAuthenticatorRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigAuthenticatorRoutingInstance.setDescription("The name of the routing instancebe used for authentication on the \nPPP interface. With READ-CREATE maximum access, setting this object \nstatically binds the authenticating routing instance with the PPP \ninterface.If this object is not explicitly set or it is set to null\nstring, then this object is ignored and the virtual router used for\nauthentication is determined by other means.  On a Set operation,\nif the value of this object is not null and does not correspond to\nan existing virtual router, then an inconsistentValue error is returned.\nSetting this object to a non-null string returns inconsistentValue error\nif jnxPppLinkConfigAuthentication object is\n  none(0) or not configured.")
jnxPppLinkConfigAaaProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigAaaProfile.setDescription("The name of the AAA profile to be used for authentication on the\nPPP interface. With READ-CREATE maximum access, setting this \nobject statically binds the AAA profile with the PPP interface.\nIf this object is not explicitly set or it is set to null string, \nthen this object is ignored.  On a Set operation, if the value of \nthis object is not null and does not correspond to an existing\nAAA profile, then an inconsistentValue error is returned.")
jnxPppLinkConfigAuthentication2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 14), JnxNibbleConfig().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigAuthentication2.setDescription("A configuration variable comprised of nibbles i.e. 4 bits, such\nthat a client can supply a list of 0 to 8 selections.  The least\n significant nibble is the first value of the list, and the most\n significant nibble is the last value.  The value in each field \n ranges from 0 to 15, however the first nibble with value 0 \n indicates the end of the list.  Repetition of values is not allowed.\n Segregation\n  of values is not allowed.\n\nValid Values are:\nnone - 0\npap  - 1\nchap - 2\neap  - 3\n\nExample valid encoding:\n0x00000321\n0x00000012\n\nNot a valid encoding:\n0x00000121\n0x01002001\n\nIf authentication negotiation is not supported for this PPP interface\nand with READ-CREATE maximum access ,any attempt to explicitly set this\nobject will result in a notWritable error and it will be implicitly \nset to the DEFVAL on row creation. Setting this object to null will set\njnxPppLinkConfigAuthenticatorRoutingInstance object to an empty string.\nSetting this object along with the jnxPppLinkConfigAuthentication object\nwill return an inconsistentValue error.")
jnxPppLinkConfigIgnoreMagicNumberMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigIgnoreMagicNumberMismatch.setDescription("The ignore magic number mismatch option of the PPP interface determines\nthe action to be taken, when the peer has not negotiated any value yet \nsent null or invalid magic number in the LCP echo packets.\nThe two actions\nthat can be configured are:\n   1)	Ignore the mismatch and retain connection\n   2)	Disallow the mismatch and terminate connection")
jnxPppLinkConfigMaxLcpRenegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppLinkConfigMaxLcpRenegotiation.setDescription("Maximum number of allowed lcp renegotiation attempts from peer.")
jnxPppNextIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppNextIfIndex.setDescription("Coordinate ifIndex value allocation for entries in the \njnxPppLinkConfigTable. A GET of this object returns the next available\nifIndex value to be used to create an entry in the associated interface\ntable; or zero, if no valid ifIndex value is available.This object\nalso returns a value of zero when it is the lexicographic successor\nof a varbind presented in an SNMP GETNEXT or GETBULK request, for which\ncircumstance it is assumed that ifIndex allocation is unintended.\nSuccessive GETs will typically return different values, thus avoiding\ncollisions among cooperating management clients seeking to create table\nentries simultaneously.")
jnxPppSec = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 2))
jnxPppIp = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3))
jnxPppIpTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1))
if mibBuilder.loadTexts: jnxPppIpTable.setDescription("Table containing the IP parameters for the local PPP entity.")
jnxPppIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppIpEntry.setDescription("IPCP status information for a particular PPP link.")
jnxPppIpServiceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpServiceStatus.setDescription("Indicates whether IP protocol service is operating over this PPP link.\nService is established on this link through means outside this MIB.")
jnxPppIpTerminateReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(5,0,1,8,3,6,4,7,2,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("noService", 2), ("admin", 3), ("linkDown", 4), ("peerTerminated", 5), ("peerRenegotiated", 6), ("maxRetriesExceeded", 7), ("negotiationFailure", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpTerminateReason.setDescription("Reason the IPCP link was terminated:\nnone                    None.\nother                   Not specified.\nnoService               No IP service configured on this PPP link.\nadmin                   Administratively disabled.\nlinkDown                Underlying link is down.\npeerTerminated          Peer initiated termination.\npeerRenegotiated        Peer initiated renegotiation.\nmaxRetriesExceeded      Maximum number of config retries exceeded.\nnegotiationFailure      Failed to negotiate IPCP option.  See                                \n jnxPppIpTerminateNegFailOption.")
jnxPppIpTerminateNegFailOption = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(8,4,6,3,9,0,2,1,7,5,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("localIpAddress", 2), ("remoteIpAddress", 3), ("remotePrimaryDnsAddress", 4), ("remoteSecondaryDnsAddress", 5), ("remotePrimaryWinsAddress", 6), ("remoteSecondaryWinsAddress", 7), ("localIpAddressMask", 8), ("remoteIpAddressMask", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpTerminateNegFailOption.setDescription("Reports the PPP IPCP option for which negotiation failed, when \njnxPppIpTerminateReason has the value 'negotiationFailure'.")
jnxPppIpLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpLocalIpAddress.setDescription("IP Address used by the local side.")
jnxPppIpRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpRemoteIpAddress.setDescription("IP Address used by the remote side.")
jnxPppIpRemotePrimaryDnsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpRemotePrimaryDnsAddress.setDescription("Primary DNS server used by the remote side.")
jnxPppIpRemoteSecondaryDnsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpRemoteSecondaryDnsAddress.setDescription("Secondary DNS server used by the remote side.")
jnxPppIpRemotePrimaryWinsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpRemotePrimaryWinsAddress.setDescription("Primary WINS server used by the remote side.")
jnxPppIpRemoteSecondaryWinsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpRemoteSecondaryWinsAddress.setDescription("Secondary WINS server used by the remote side.")
jnxPppIpNetworkStatusIpcpRenegoTerminates = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpNetworkStatusIpcpRenegoTerminates.setDescription("Number of times ipcp terminated due to peer exceeding max \nrenegotiation attempts.")
jnxPppIpConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2))
if mibBuilder.loadTexts: jnxPppIpConfigTable.setDescription("Table containing the IP parameters for the local PPP entity.")
jnxPppIpConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppIpConfigEntry.setDescription("IPCP configuration information for a particular PPP link.")
jnxPppIpConfigPeerDnsPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigPeerDnsPriority.setDescription("When enabled, allows peer's DNS address to prevail in the event of a \nnegotiation conflict; when disabled, the local PPP interface's DNS \naddress prevails.")
jnxPppIpConfigPeerWinsPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigPeerWinsPriority.setDescription("When enabled, allows peer's WINS address to prevail in the event of a \nnegotiation conflict; when disabled, the local PPP interface's WINS\n address prevails.")
jnxPppIpConfigIpcpNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigIpcpNetmask.setDescription("Enables the negotiation of the IPCP option netmask (0x90) during \nIPCP negotiation.")
jnxPppIpConfigInitiateIp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigInitiateIp.setDescription("Enables the initiation of negotiation of the IPCP.")
jnxPppIpConfigMaxIpcpRenegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigMaxIpcpRenegotiation.setDescription("Maximum number of allowed ipcp renegotiation attempts from peer.")
jnxPppIpConfigPromptIpcpDnsOption = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigPromptIpcpDnsOption.setDescription("Control prompting of IPCP DNS option to remote peer.")
jnxPppIpConfigIpcpLockout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 3, 2, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpConfigIpcpLockout.setDescription("Enables IPCP lockout. It determines whether this NCP can be negotiated\nwhen the interface is already running a different NCP. On enabling \nthis option, the IPCP negotiation will be blocked after a different \nNCP service is up and waited for 10 seconds for IPCP initiation \nfrom peer.")
jnxPppOsi = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4))
jnxPppOsiTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1))
if mibBuilder.loadTexts: jnxPppOsiTable.setDescription("Table containing the OSI parameters for the local PPP entity.")
jnxPppOsiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppOsiEntry.setDescription("OSICP status information for a particular PPP link.")
jnxPppOsiServiceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiServiceStatus.setDescription("Indicates whether OSI protocol service is operating over this PPP link.\nService is established on this link through means outside this MIB.")
jnxPppOsiOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("opened", 1), ("notOpened", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiOperStatus.setDescription("The operational status of the OSI network protocol.  If the value of\nthis object is up then the finite state machine for the OSI network\n protocol has reached the Opened state.")
jnxPppOsiTerminateReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(5,0,1,8,3,6,4,7,2,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("noService", 2), ("admin", 3), ("linkDown", 4), ("peerTerminated", 5), ("peerRenegotiated", 6), ("maxRetriesExceeded", 7), ("negotiationFailure", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiTerminateReason.setDescription("Reason the OSICP link was terminated:\nnone                    None.\nother                   Not specified.\nnoService               No OSI service configured on this PPP link.\nadmin                   Administratively disabled.\nlinkDown                Underlying link is down.\npeerTerminated          Peer initiated termination.\npeerRenegotiated        Peer initiated renegotiation.\nmaxRetriesExceeded      Maximum number of config retries exceeded.\nnegotiationFailure      Failed to negotiate IPCP option.  See\n                        jnxPppOsiTerminateNegFailOption.")
jnxPppOsiTerminateNegFailOption = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,3,2,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("localAlignNpdu", 2), ("remoteAlignNpdu", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiTerminateNegFailOption.setDescription("Reports the PPP OSICP option for which negotiation failed, when \njnxPppOsiTerminateReason has the value 'negotiationFailure'.")
jnxPppOsiLocalAlignNpdu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(254,0,1,3,2,255,4,)).subtype(namedValues=NamedValues(("none", 0), ("oneModulo4", 1), ("twoModulo4", 2), ("even", 254), ("odd", 255), ("threeModulo4", 3), ("fourModulo4", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiLocalAlignNpdu.setDescription("Local alignment of network PDU:\nnone            No alignment specified.\noneModulo4      Alignment on first octet (out of four).\ntwoModulo4      Alignment on second octet (out of four).\nthreeModulo4    Alignment on third octet (out of four).\nfourModulo4     Alignment on fourth octet (out of four).\neven            Alignment on even-octet boundary.\nodd             Alignment on odd-octet boundary.")
jnxPppOsiRemoteAlignNpdu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 1, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(254,0,1,3,2,255,4,)).subtype(namedValues=NamedValues(("none", 0), ("oneModulo4", 1), ("twoModulo4", 2), ("even", 254), ("odd", 255), ("threeModulo4", 3), ("fourModulo4", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiRemoteAlignNpdu.setDescription("Remote alignment of network PDU.\nnone            No alignment specified.\noneModulo4      Alignment on first octet (out of four).\ntwoModulo4      Alignment on second octet (out of four).\nthreeModulo4    Alignment on third octet (out of four).\nfourModulo4     Alignment on fourth octet (out of four).\neven            Alignment on even-octet boundary.\nodd             Alignment on odd-octet boundary.")
jnxPppOsiConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 2))
if mibBuilder.loadTexts: jnxPppOsiConfigTable.setDescription("Table containing configuration variables for the OSICP for the \nlocal PPP entity.")
jnxPppOsiConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppOsiConfigEntry.setDescription("OSICP information for a particular PPP link.")
jnxPppOsiConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 4, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("open", 1), ("close", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppOsiConfigAdminStatus.setDescription("The immediate desired status of the OSI network protocol. \nSetting this object to open will inject an administrative open event\n into the OSI network protocol's finite state machine.  Setting this\n  object to close will inject an administrative close event into the\n   OSI network protocol's finite state machine.")
jnxPppSession = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5))
jnxPppSessionTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1))
if mibBuilder.loadTexts: jnxPppSessionTable.setDescription("This table contains entries for PPP interfaces present in the system.")
jnxPppSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppSessionEntry.setDescription("Each entry describes the characteristics of a PPP interface.")
jnxPppSessionGrant = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionGrant.setDescription("Indicates whether a session has been granted via the authentication\nmechanism.")
jnxPppSessionTerminateReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,11,7,16,1,14,10,9,13,12,5,4,18,17,6,8,15,2,)).subtype(namedValues=NamedValues(("none", 0), ("unknown", 1), ("noHardware", 10), ("noResources", 11), ("noInterface", 12), ("challengeTimeout", 13), ("requestTimeout", 14), ("authenticatorTimeout", 15), ("addressLeaseExpired", 16), ("adminLogout", 17), ("tunnelFailed", 18), ("userRequest", 2), ("keepaliveFailure", 3), ("sessionTimeout", 4), ("inactivityTimeout", 5), ("adminDisable", 6), ("lowerLayerDown", 7), ("noUpperInterface", 8), ("deny", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionTerminateReason.setDescription("The reason the session was terminated.")
jnxPppSessionStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionStartTime.setDescription("The value of sysUpTime when this session last became active.")
jnxPppSessionInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInOctets.setDescription("Number of octets received since this session last became active, as \ndenoted by jnxPppSessionStartTime. This has been deprecated and \nreplaced by jnxPppSessionInOctets64")
jnxPppSessionOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionOutOctets.setDescription("Number of octets sent since this session last became active, as \ndenoted by jnxPppSessionStartTime. This has been deprecated and\nreplaced by jnxPppSessionOutOctets64")
jnxPppSessionInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInPackets.setDescription("Number of packets received since this session last became active, as\ndenoted by jnxPppSessionStartTime. This has been deprecated and\nreplaced by jnxPppSessionInPackets64")
jnxPppSessionOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionOutPackets.setDescription("Number of packets sent since this session last became active, as \ndenoted by jnxPppSessionStartTime. This has been deprecated and\nreplaced by jnxPppSessionOutPackets64")
jnxPppSessionSessionTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionSessionTimeout.setDescription("Maximum duration for the session, after which the session terminates\nautomatically.")
jnxPppSessionInactivityTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInactivityTimeout.setDescription("Maximum inactivity duration for the session, after which the session\nterminates automatically.")
jnxPppSessionAccountingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionAccountingInterval.setDescription("Interval that must elapse between generation of accounting records\nfor this session.")
jnxPppSessionRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionRemoteIpAddress.setDescription("Remote IP address, obtained from the authentication service, to be \nused during IPCP negotiation with the remote side.")
jnxPppSessionRemotePrimaryDnsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionRemotePrimaryDnsAddress.setDescription("Remote primary DNS IP address, obtained from the authentication \nservice, to be used during IPCP negotiation with the remote side.")
jnxPppSessionRemoteSecondaryDnsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionRemoteSecondaryDnsAddress.setDescription("Remote secondary DNS IP address, obtained from the authentication \nservice, to be used during IPCP negotiation with the remote side.")
jnxPppSessionRemotePrimaryWinsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionRemotePrimaryWinsAddress.setDescription("Remote primary WINS IP address, obtained from the authentication\nservice, to be used during IPCP negotiation with the remote side.")
jnxPppSessionRemoteSecondaryWinsAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionRemoteSecondaryWinsAddress.setDescription("Remote secondary WINS IP address, obtained from the authentication\nservice, to be used during IPCP negotiation with the remote side.")
jnxPppSessionRemoteIpv6AddressIfIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 16), Ipv6AddressIfIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionRemoteIpv6AddressIfIdentifier.setDescription("IPV6 Address Interface Identifier obtained from the authentication\nservice, to be used during IPCP negotiation with the remote side.")
jnxPppSessionInhibitIp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 17), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInhibitIp.setDescription("Indicates whether a session has had its IP service inhibited by the\nauthentication mechanism.")
jnxPppSessionInhibitIpv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 18), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInhibitIpv6.setDescription("Indicates whether a session has had its IPv6 service inhibited by the\nauthentication mechanism.")
jnxPppSessionInOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInOctets64.setDescription("Number of octets received since this session last became active, as \ndenoted by jnxPppSessionStartTime.")
jnxPppSessionOutOctets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionOutOctets64.setDescription("Number of octets sent since this session last became active, as \ndenoted by jnxPppSessionStartTime.")
jnxPppSessionInPackets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionInPackets64.setDescription("Number of packets received since this session last became active, as\ndenoted by jnxPppSessionStartTime.")
jnxPppSessionOutPackets64 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 5, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSessionOutPackets64.setDescription("Number of packets sent since this session last became active, as \ndenoted by jnxPppSessionStartTime.")
jnxPppMlPpp = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6))
jnxPppMlPppBundleTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 1))
if mibBuilder.loadTexts: jnxPppMlPppBundleTable.setDescription("This table contains entries for MLPPP bundles present in the system.")
jnxPppMlPppBundleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 1, 1)).setIndexNames((0, "JNX-PPP-MIB", "jnxPppMlPppBundleName"))
if mibBuilder.loadTexts: jnxPppMlPppBundleEntry.setDescription("Each entry describes the characteristics of a MLPPP bundle.")
jnxPppMlPppBundleName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 1, 1, 1), JnxPppMlPppBundleName()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppMlPppBundleName.setDescription("The administrative name of the MLPPP bundle associated with this\nMLPPP network interface.")
jnxPppMlPppBundleRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 1, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppBundleRowStatus.setDescription("The rowStatus for this entry.  The following sets are supported \nwith read-create maximum access:\n     createAndGo(4),\n     destroy(6)\n\n The following values can be read from this object:\n     active(1) ")
jnxPppMlPppBundleNetworkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 1, 1, 3), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppBundleNetworkIfIndex.setDescription("The ifIndex of this MLPPP network interface.  It is a valid ifIndex\neven if there is no corresponding network interface instance in \nthe jnxPppMlPppLinkConfigTable.")
jnxPppMlPppNextLinkIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppNextLinkIfIndex.setDescription("Coordinate ifIndex value allocation for entries in \njnxPppMlPppLinkConfigTable. A GET of this object returns the next \navailable ifIndex value to be used to create an entry in the \nassociated interface table; or zero, if no valid ifIndex value is\navailable.  This object also returns a value of zero when it is the\nlexicographic successor of a varbind presented in an SNMP GETNEXT \nor GETBULK request, for which circumstance it is assumed that ifIndex\nallocation is unintended. Successive GETs will typically return \ndifferent values, thus avoiding collisions among cooperating management\nclients seeking to create table entries simultaneously.")
jnxPppMlPppLinkConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3))
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigTable.setDescription("This table contains entries for MLPPP interfaces present in the system.")
jnxPppMlPppLinkConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1)).setIndexNames((0, "JNX-PPP-MIB", "jnxPppMlPppLinkConfigIfIndex"))
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigEntry.setDescription("Each entry describes the characteristics of MLPPP interface. \nWith read-create maximum access,creating/deleting entries in this\ntable causes corresponding entries for be created/deleted in\nifTable/ifXTable/jnxIfTable.")
jnxPppMlPppLinkConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigIfIndex.setDescription("The ifIndex of the MLPPP interface.  When creating entries in this \ntable, suitable values for this object are determined by reading \njnxPppMlPppNextLinkIfIndex.")
jnxPppMlPppLinkConfigLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigLowerIfIndex.setDescription("The ifIndex of an interface over which this PPP interface is to be \nlayered.  A value of zero indicates no layering.  An implementation \nmay choose to require that a non-zero value be configured at entry\n creation.")
jnxPppMlPppLinkConfigKeepalive = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(10,64800),)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigKeepalive.setDescription("Keepalive interval in seconds.  A value of zero disables keepalive.\nKeepalive is performed using LCP Echo.")
jnxPppMlPppLinkConfigAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 5), JnxPppAuthentication().clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigAuthentication.setDescription("Specifies the type(s) of authentication, if any, to be \nnegotiated with the peer:\n  none      No authentication is negotiated.\n  pap       PAP negotiation only.\n  chap      CHAP negotiation only.\n  papChap   PAP negotiation is attempted first; if fails, attempt CHAP.\n  chapPap   CHAP negotiation is attempted first; if fails, attempt PAP.\n\nIf authentication negotiation is not supported for this MLPPP interface,\nthen any attempt to explicitely set this object will result in a \nnotWritable error and it will be implicitily set to the DEFVAL on\nrow creation. \nThis object returns a none (0) value on the get operation.\nNew object jnxPppMlPppLinkConfigAuthentication2 will reflect the configured \nvalues. Setting this object along with the jnxPppMlPppLinkConfigAuthentication2\nobject will return an inconsistentValue error.")
jnxPppMlPppLinkConfigMaxAuthenRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigMaxAuthenRetries.setDescription("The number of authentication retries permitted, in addition to a\nfailed initial attempt.  If all retries fail, the link is reset.")
jnxPppMlPppLinkConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 7), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigRowStatus.setDescription("Controls creation/deletion of entries in this table with read-carete \nmaximum access,according to the RowStatus textual convention, \nconstrained to support the following values only:\n    createAndGo\n    destroy\n\nTo create an entry in this table, the following entry objects MUST be \nexplicitly configured:\n    jnxPppMlPppLinkConfigRowStatus\n    jnxPppMlPppLinkConfigLowerIfIndex\nIn addition, when creating an entry the following conditions must hold:\n    A value for jnxPppMlPppLinkConfigIndex must have been\n     determined previously, by reading jnxPppMlPppNextIfIndex. \n     The interface identified by jnxPppMlPppLinkConfigLowerIfIndex\n     must exist.\n    A corresponding entry in ifTable/ifXTable/jnxIfTable is \n    created/destroyed as a result of creating/destroying an entry in \n    this table.\n\nThe following values can be read from this object:\n     active(1) ")
jnxPppMlPppLinkConfigAaaProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigAaaProfile.setDescription("The name of the AAA profile to be used for authentication on the \nPPP interface.Setting this object statically binds the AAA profile\nwith the PPP interface. If this object is not explicitly set or it\nis set to null string, then this object is ignored. On a Set operation,\nif the value of this object is not null and does not correspond to an\n existin AAA profile, then an inconsistentValue error is returned.")
jnxPppMlPppLinkConfigChapMinChallengeLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 63)).clone(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigChapMinChallengeLength.setDescription("Minimum value of the CHAP authenticator challenge length value.\nThis value is never allowed to be set to a value greater than \njnxPppMlPppLinkConfigChapMaxChallengeLength.")
jnxPppMlPppLinkConfigChapMaxChallengeLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8, 63)).clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigChapMaxChallengeLength.setDescription("Maximum value of the CHAP authenticator challenge length value.")
jnxPppMlPppLinkConfigPassiveMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigPassiveMode.setDescription("When enabled, LCP state machine is forced into passive mode on lower \nlayer UP message.  It adds compatibility with slow and buggy clients.")
jnxPppMlPppLinkConfigAuthenticatorLogicalSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigAuthenticatorLogicalSystem.setDescription("The name of the Logical System (Jnxper-ROUTER-MIB.jnxRouterName) to \nbe used for authentication on the PPP interface.  Setting this object\n statically binds the authenticating virtual router with the link interface.\n With read-create maximum access, if this object is not explicitly set or \n it is set to null string, then this object is ignored and the\n  virtual router used for     authentication is determined by other means.\n    On a Set operation, if the value of this object is not null and does not\n     correspond to an existing virtual router, then an inconsistentValue\n      error is returned.")
jnxPppMlPppLinkConfigAuthenticatorRoutingInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigAuthenticatorRoutingInstance.setDescription("The name of the Routing Instance (Jnxper-ROUTER-MIB.jnxRouterName) \nto be used for authentication on the PPP interface.  Setting this \nobject statically binds the authenticating virtual router with the \nlink interface. With read-create maximum access, if this object is\n not explicitly set or it is set to null string, then this object is\n  ignored and the virtual router used for     authentication is\n   determined by other means.  On a Set operation, if the value of\n    this object is not null and does not correspond to an existing\n     virtual router, then an inconsistentValue error is returned.")
jnxPppMlPppLinkConfigFragmentation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigFragmentation.setDescription("Enables MLPPP fragmentation.With read-create maximum access,\nchanging this object has an effect when the link is next restarted.")
jnxPppMlPppLinkConfigReassembly = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigReassembly.setDescription("Enables MLPPP reassembly. With read-create maximum access,\nchanging this object has an effect when the link is next restarted.")
jnxPppMlPppLinkConfigMaxReceiveReconstructedUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1,1),ValueRangeConstraint(64,65535),)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigMaxReceiveReconstructedUnit.setDescription("The Maximum Receive Reconstructed Unit (MRRU) that the local \nPPP entity will advertise to the remote entity.  If the value of\nthis variable is 1, then the MRRU is set to the local MRU value. \nWith read-create maximum access, changing this object has an effect\nwhen the link is next restarted.")
jnxPppMlPppLinkConfigFragmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1,1),ValueRangeConstraint(128,65535),)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigFragmentSize.setDescription("The size of fragments transmitted by the local PPP entity.\nIf the value of this variable is 1, then the fragment size is set to \nthe link's MTU value. With read-create maximum access, \nchanging this object has an effect when the link is next restarted.")
jnxPppMlPppLinkConfigHashLinkSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 18), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigHashLinkSelection.setDescription("Enables MLPPP hash-based link selection for non-best-effort traffic.\nWith read-create maximum access,changing this object has an effect\n when the link is next restarted.")
jnxPppMlPppLinkConfigAuthentication2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 19), JnxNibbleConfig().clone('0')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigAuthentication2.setDescription("A configuration variable comprised of nibbles i.e. 4 bits, such \nthat a client can supply a list of 0 to 8 selections.  The least\n significant nibble is the first value of the list, and the most \n significant nibble is the last value.  The value in each field\n ranges from 0 to 15, however the first nibble with value 0 indicates\n  the end of the list.  Repetition of values is not allowed. \n  Segregation of values is not allowed.\n\n Valid Values are:\n none - 0\n pap  - 1\n chap - 2\n eap  - 3\n\n Example valid encoding:\n 0x00000321\n 0x00000012\n\n Not a valid encoding:\n 0x00000121\n 0x01002001\n\n If authentication negotiation is not supported for this PPP interface\n and With read-create maximum access, then any attempt to explicitly \n set this object will result in a notWritable error and it will be \n implicitly set to the DEFVAL on row creation. Setting this object to \n null will set jnxPppMlPppLinkConfigAuthenticatorVirtualRouter object \n to an empty string.Setting this object along with the \n jnxPppMlPppLinkConfigAuthentication object will return an i\n nconsistentValue error.")
jnxPppMlPppLinkConfigIgnoreMagicNumberMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 20), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigIgnoreMagicNumberMismatch.setDescription("The ignore magic number mismatch option of the PPP interface determines\nthe action to be taken, when the peer has not negotiated any value yet\n sent null or invalid magic number in the LCP echo packets. The two \n actions that can be configured are:\n   1)	Ignore the mismatch and retain connection\n   2)	Disallow the mismatch and terminate connection")
jnxPppMlPppLinkConfigMultilinkMulticlass = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigMultilinkMulticlass.setDescription("Enables Multiclass Multilink PPP (MCML). With read-create maximum\naccess,changing this object has an effect when the link is next\n restarted.")
jnxPppMlPppLinkConfigMultilinkMaxMultiClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppLinkConfigMultilinkMaxMultiClasses.setDescription("Maximum number of MCML classes to be negotiated.With read-create\nmaximum access,changing this object has an effect when the link\n is next restarted.")
jnxPppMlPppNextNetworkIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppNextNetworkIfIndex.setDescription("Coordinate ifIndex value allocation for entries in\njnxPppMlPppNetworkConfigTable. A GET of this object returns the next\navailable ifIndex value to be used to create an entry in the associated\ninterface table; or zero, if no        valid ifIndex value is available.\nThis object also returns a value of zero when it is the lexicographic\nsuccessor of a varbind presented in an SNMP GETNEXT or GETBULK request,\nfor which circumstance it is assumed that ifIndex allocation \nis unintended. Successive GETs will typically return different values,\n thus avoiding collisions among cooperating management clients seeking \n to create table entries simultaneously.")
jnxPppMlPppNetworkConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 5))
if mibBuilder.loadTexts: jnxPppMlPppNetworkConfigTable.setDescription("This table contains entries for MLPPP network interfaces \npresent in the system.")
jnxPppMlPppNetworkConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 5, 1)).setIndexNames((0, "JNX-PPP-MIB", "jnxPppMlPppNetworkConfigIfIndex"))
if mibBuilder.loadTexts: jnxPppMlPppNetworkConfigEntry.setDescription("Each entry describes the characteristics of MLPPP interface.\nWith read-create maximum access,creating/deleting entries in \nthis table causes corresponding entries for be created/deleted \nin ifTable/ifXTable/jnxIfTable.")
jnxPppMlPppNetworkConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 5, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppMlPppNetworkConfigIfIndex.setDescription("The ifIndex of the MLPPP network interface.  When creating entries\nin this table, suitable values for this object are determined by \nreading jnxPppMlPppNextNetworkIfIndex.")
jnxPppMlPppNetworkConfigLowerIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 5, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppNetworkConfigLowerIfIndex.setDescription("The ifIndex of a PPP link interface over which this PPP network \ninterface is to be layered.  On sets, the value of this object must \nequal on of the previously created PPP link interfaces created in \nthe jnxPppMlPppLinkConfigTable.  On gets, the value of this object \nis the lexicographically least PPP link interface in a potential\n bundle of PPP link interfaces.")
jnxPppMlPppNetworkBundleName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 5, 1, 3), JnxPppMlPppBundleName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppNetworkBundleName.setDescription("The MLPPP bundle name administratively assigned.")
jnxPppMlPppNetworkRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 5, 1, 4), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppNetworkRowStatus.setDescription("Controls creation/deletion of entries in this table with read-create\nmaximum access , according to the RowStatus textual convention,\n constrained to support the following values only:\n   createAndGo\n   destroy\nTo create an entry in this table, the following entry objects MUST be \nexplicitly configured:\n\n   jnxPppMlPppNetworkConfigLowerIfIndex\n   jnxPppMlPppNetworkBundleName\n   jnxPppMlPppNetworkConfigRowStatus\n\nIn addition, when creating an entry the following conditions must hold:\n  A value for jnxPppMlPppNetworkConfigIndex must have been determined\n   previously, by reading jnxPppMlPppNextNetworkIfIndex. The \n   interface identified by jnxPppMlPppNetworkConfigLowerIfInde must \n   exist by a creation request to the jnxPppMlPppLinkConfigTable.\n  The bundleName specified in jnxPppMlPppNetworkBundleName must have\n   been created first in the jnxPppMlPppBundleTable. A corresponding\n    entry in ifTable/ifXTable/jnxIfTable is created/destroyed as a \n    result of creating/destroying an entry in this table.\n\nThe following values can be read from this object:\n    active(1) ")
jnxPppMlPppLinkBindTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 6))
if mibBuilder.loadTexts: jnxPppMlPppLinkBindTable.setDescription("This table contains entries for MLPPP Link interface to MLPPP \nnetwork interfaces bindings.")
jnxPppMlPppLinkBindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 6, 1)).setIndexNames((0, "JNX-PPP-MIB", "jnxPppMlPppBindNetworkIfIndex"), (0, "JNX-PPP-MIB", "jnxPppMlPppBindLinkIfIndex"))
if mibBuilder.loadTexts: jnxPppMlPppLinkBindEntry.setDescription("Each entry describes the MLPPP link interface to MLPPP network \ninterface bindings.")
jnxPppMlPppBindNetworkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 6, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppMlPppBindNetworkIfIndex.setDescription("The ifIndex of the MLPPP network interface.")
jnxPppMlPppBindLinkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 6, 1, 2), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxPppMlPppBindLinkIfIndex.setDescription("The ifIndex of a MLPPP link interface bound by the MLPPP network\ninterface defined by jnxPppMlPppBindNetworkIfIndex.")
jnxPppMlPppBindRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 6, 6, 1, 3), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppMlPppBindRowStatus.setDescription("Controls creation/deletion of entries in this table with read-create\nmaximum access, according to the RowStatus textual convention, \nconstrained to support the following values only:\n   createAndGo\n   destroy\n\nTo create an entry in this table, the following entry objects MUST\nbe explicitly configured:\n   jnxPppMlPppBindRowStatus\n\nIn addition, when creating an entry the following conditions must hold:\nThe interfaces identified by jnxPppMlPppBindNetworkIfIndex and \njnxPppMlPppBindLinkIfIndex must be created in the \njnxPppMlPppNetworkConfigTable and jnxPppMlPppLinkConfigTable \nrespectively. A MLPPP bundle must be associated with the \njnxPppMlPppNetworkIfIndex and exist in the jnxPppMibPppBundleTable. \nA corresponding entry in ifStackTable is created/destroyed as a result\nof creating/destroying an entry in this table.\n\nThe following values can be read from this object:\n    active(1) ")
jnxPppSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7))
jnxPppSummaryPppInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppInterfaceCount.setDescription("The total number of PPP interfaces configured in the system.")
jnxPppSummaryPppIpNCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpNCPs.setDescription("The total number IP NCPs configured in the system.")
jnxPppSummaryPppOsiNCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiNCPs.setDescription("The total number of OSI NCPs configured in the system.")
jnxPppSummaryPppIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfAdminUp.setDescription("The total number of PPP interfaces in the system that are\nadministratively configured to up(1).")
jnxPppSummaryPppIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfAdminDown.setDescription("The total number of PPP interfaces in the system that are\nadministrateively configued to down(2).")
jnxPppSummaryPppIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfOperUp.setDescription("The total number of PPP interfaces in the system with an \noperational state of up(1).")
jnxPppSummaryPppIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfOperDown.setDescription("The total number of PPP interfaces in the system with an \noperational state of down(2).")
jnxPppSummaryPppIfOperDormant = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfOperDormant.setDescription("The total number of PPP interfaces in the system with an\noperational state of dormant(5).")
jnxPppSummaryPppIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfNotPresent.setDescription("The total number of PPP interfaces in the system with an \noperational state of notPresent(6).")
jnxPppSummaryPppIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfLowerLayerDown.setDescription("The total number of PPP interfaces in the system with an \noperational state of lowerLayerDown(7).")
jnxPppSummaryPppIpNcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpNcpOpened.setDescription("The total number of PPP IP NCPs in the system with an\noperational state of opened(1).")
jnxPppSummaryPppIpNcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpNcpClosed.setDescription("The total number of PPP IP NCPs in the system with an \noperational state of not-opened(2).")
jnxPppSummaryPppOsiNcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiNcpOpened.setDescription("The total number of PPP OSI NCPs in the system with an \noperational state of opened.")
jnxPppSummaryPppOsiNcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiNcpClosed.setDescription("The total number of PPP OSI NCPs in the system with an \noperational state of closed.")
jnxPppSummaryPppIfLastChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIfLastChangeTime.setDescription("The value of the sysUpTime at the time of the last PPP interface\ncreation or deletion in the system.  If the number of PPP interfaces has been unchanged since the last re-initialization of the system, then this object contains a zero value. ")
jnxPppSummaryPppLinkInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkInterfaceCount.setDescription("The total number of PPP Link interfaces configured in the system.")
jnxPppSummaryPppLinkIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfAdminUp.setDescription("The total number of PPP Link interfaces in the system that are\nadministratively configured to up(1).")
jnxPppSummaryPppLinkIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfAdminDown.setDescription("The total number of PPP Link interfaces in the system that are\nadministrateively configued to down(2).")
jnxPppSummaryPppLinkIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfOperUp.setDescription("The total number of PPP Link interfaces in the system with an \noperational state of up(1).")
jnxPppSummaryPppLinkIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfOperDown.setDescription("The total number of PPP Link interfaces in the system with an\noperational state of down(2).")
jnxPppSummaryPppLinkIfOperDormant = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfOperDormant.setDescription("The total number of PPP Link interfaces in the system with an \noperational state of dormant(5).")
jnxPppSummaryPppLinkIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfNotPresent.setDescription("The total number of PPP link interfaces in the system with an\noperational state of notPresent(6).")
jnxPppSummaryPppLinkIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfLowerLayerDown.setDescription("The total number of PPP Link interfaces in the system with an \noperational state of lowerLayerDown(7).")
jnxPppSummaryPppLinkIfLastChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 25), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkIfLastChangeTime.setDescription("The value of the sysUpTime at the time of the last PPP Link interface\ncreation or deletion in the system.  If the number of PPP interfaces has been unchanged since the last re-initialization of the system, then this object contains a zero value. ")
jnxPppSummaryPppNetworkInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkInterfaceCount.setDescription("The total number of PPP network interfaces configured in the system.")
jnxPppSummaryPppNetworkIpNCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpNCPs.setDescription("The total number IP NCPs in the system configured on \nPPP network interfaces.")
jnxPppSummaryPppNetworkOsiNCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiNCPs.setDescription("The total number of OSI NCPs in the system configured on \nPPP network interfaces.")
jnxPppSummaryPppNetworkIfAdminUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfAdminUp.setDescription("The total number of PPP network interfaces in the system that are\nadministratively configured to up(1).")
jnxPppSummaryPppNetworkIfAdminDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfAdminDown.setDescription("The total number of PPP network interfaces in the system that are \nadministrateively configued to down(2).")
jnxPppSummaryPppNetworkIfOperUp = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfOperUp.setDescription("The total number of PPP network interfaces in the system with an\noperational state of up(1).")
jnxPppSummaryPppNetworkIfOperDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfOperDown.setDescription("The total number of PPP network interfaces in the system with an \noperational state of down(2).")
jnxPppSummaryPppNetworkIfOperDormant = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfOperDormant.setDescription("The total number of PPP network interfaces in the system with an\noperational state of dormant(5).")
jnxPppSummaryPppNetworkIfNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfNotPresent.setDescription("The total number of PPP network interfaces in the system with an\noperational state of notPresent(6).")
jnxPppSummaryPppNetworkIfLowerLayerDown = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfLowerLayerDown.setDescription("The total number of PPP network interfaces in the system with an\noperational state of lowerLayerDown(7).")
jnxPppSummaryPppNetworkIpNcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpNcpOpened.setDescription("The total number of PPP IP NCPs in the system with an operational \nstate of opened(1).")
jnxPppSummaryPppNetworkIpNcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpNcpClosed.setDescription("The total number of PPP IP NCPs in the system with an operational \nstate of not-opened(2).")
jnxPppSummaryPppNetworkOsiNcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiNcpOpened.setDescription("The total number of PPP OSI NCPs in the system with an operational \nstate of opened.")
jnxPppSummaryPppNetworkOsiNcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiNcpClosed.setDescription("The total number of PPP OSI NCPs in the system with an operational\nstate of closed.")
jnxPppSummaryPppNetworkIfLastChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 40), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIfLastChangeTime.setDescription("The value of the sysUpTime at the time of the last PPP network\ninterface creation or deletion in the system.  If the number of PPP\nnetwork interfaces has been unchanged since the last re-initialization\nof the system, then this object contains a zero value. ")
jnxPppSummaryPppIpv6NCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6NCPs.setDescription("The total number IPv6 NCPs configured in the system.")
jnxPppSummaryPppIpv6NcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6NcpOpened.setDescription("The total number of PPP IPv6 NCPs in the system with an operational\nstate of opened(1).")
jnxPppSummaryPppIpv6NcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6NcpClosed.setDescription("The total number of PPP IPv6 NCPs in the system with an operational\nstate of not-opened(2).")
jnxPppSummaryPppNetworkIpv6NCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6NCPs.setDescription("The total number IPv6 NCPs configured in the system.")
jnxPppSummaryPppNetworkIpv6NcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6NcpOpened.setDescription("The total number of PPP IPv6 NCPs in the system with an operational\nstate of opened(1).")
jnxPppSummaryPppNetworkIpv6NcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6NcpClosed.setDescription("The total number of PPP IPv6 NCPs in the system with an operational\nstate of not-opened(2).")
jnxPppSummaryPppStaticInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppStaticInterfaceCount.setDescription("The total number of static PPP interfaces configured in the system.")
jnxPppSummaryPppMplsNCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsNCPs.setDescription("The total number MPLS NCPs configured in the system.")
jnxPppSummaryPppIpAdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpAdminOpen.setDescription("The total number of IP NCPs in the system that are\nadministratively configured to open(1).")
jnxPppSummaryPppIpAdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpAdminClose.setDescription("The total number of IP NCPs in the system that are\nadministratively configured to close(2).")
jnxPppSummaryPppIpv6AdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6AdminOpen.setDescription("The total number of IPV6 NCPs in the system that are\nadministratively configured to open(1).")
jnxPppSummaryPppIpv6AdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6AdminClose.setDescription("The total number of IPV6 NCPs in the system that are\nadministratively configured to close(2).")
jnxPppSummaryPppOsiAdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiAdminOpen.setDescription("The total number of OSI NCPs in the system that are\nadministratively configured to open(1).")
jnxPppSummaryPppOsiAdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiAdminClose.setDescription("The total number of OSI NCPs in the system that are\nadministratively configured to close(2).")
jnxPppSummaryPppMplsAdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 55), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsAdminOpen.setDescription("The total number of MPLS NCPs in the system that are\nadministratively configured to open(1).")
jnxPppSummaryPppMplsAdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsAdminClose.setDescription("The total number of MPLS NCPs in the system that are\nadministratively configured to close(2).")
jnxPppSummaryPppIpNcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpNcpNotPresent.setDescription("The total number of PPP IP NCPs in the system with an operational state\nof notPresent(3).")
jnxPppSummaryPppIpNcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 58), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpNcpNoResources.setDescription("The total number of PPP IP NCPs in the system with an operational\nstate of noResources(4).")
jnxPppSummaryPppIpv6NcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 59), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6NcpNotPresent.setDescription("The total number of PPP IPV6 NCPs in the system with an operational state\nof notPresent(3).")
jnxPppSummaryPppIpv6NcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppIpv6NcpNoResources.setDescription("The total number of PPP IPV6 NCPs in the system with an operational\nstate of noResources(4).")
jnxPppSummaryPppOsiNcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiNcpNotPresent.setDescription("The total number of PPP OSI NCPs in the system with an operational state\nof notPresent(3).")
jnxPppSummaryPppOsiNcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppOsiNcpNoResources.setDescription("The total number of PPP OSI NCPs in the system with an operational\nstate of noResources(4).")
jnxPppSummaryPppMplsNcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 63), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsNcpOpened.setDescription("The total number of PPP MPLS NCPs in the system with an operational state\nof opened(1).")
jnxPppSummaryPppMplsNcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 64), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsNcpClosed.setDescription("The total number of PPP MPLS NCPs in the system with an operational\nstate of not-opened(2).")
jnxPppSummaryPppMplsNcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsNcpNotPresent.setDescription("The total number of PPP MPLS NCPs in the system with an operational state\nof notPresent(3).")
jnxPppSummaryPppMplsNcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 66), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppMplsNcpNoResources.setDescription("The total number of PPP MPLS NCPs in the system with an operational\nstate of noResources(4).")
jnxPppSummaryPppLinkStaticInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 67), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppLinkStaticInterfaceCount.setDescription("The total number of static PPP Link interfaces configured in the system.")
jnxPppSummaryPppNetworkStaticInterfaceCount = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 68), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkStaticInterfaceCount.setDescription("The total number of static PPP network interfaces configured in the system.")
jnxPppSummaryPppNetworkMplsNCPs = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 69), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsNCPs.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces.")
jnxPppSummaryPppNetworkIpAdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 70), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpAdminOpen.setDescription("The total number of IP NCPs in the system configured on PPP network\ninterfaces that are administratively configured to open(1).")
jnxPppSummaryPppNetworkIpAdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 71), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpAdminClose.setDescription("The total number of IP NCPs in the system configured on PPP network\ninterfaces that are administratively configured to close(2).")
jnxPppSummaryPppNetworkIpv6AdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 72), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6AdminOpen.setDescription("The total number of IPV6 NCPs in the system configured on PPP network\ninterfaces that are administratively configured to open(1).")
jnxPppSummaryPppNetworkIpv6AdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 73), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6AdminClose.setDescription("The total number of IPV6 NCPs in the system configured on PPP network\ninterfaces that are administratively configured to close(2).")
jnxPppSummaryPppNetworkOsiAdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 74), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiAdminOpen.setDescription("The total number of OSI NCPs in the system configured on PPP network\ninterfaces that are administratively configured to open(1).")
jnxPppSummaryPppNetworkOsiAdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 75), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiAdminClose.setDescription("The total number of OSI NCPs in the system configured on PPP network\ninterfaces that are administratively configured to close(2).")
jnxPppSummaryPppNetworkMplsAdminOpen = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 76), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsAdminOpen.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces that are administratively configured to open(1).")
jnxPppSummaryPppNetworkMplsAdminClose = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 77), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsAdminClose.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces that are administratively configured to close(2).")
jnxPppSummaryPppNetworkIpNcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 78), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpNcpNotPresent.setDescription("The total number of IP NCPs in the system configured on PPP network\ninterfaces with an operational state of notPresent(3).")
jnxPppSummaryPppNetworkIpNcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 79), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpNcpNoResources.setDescription("The total number of IP NCPs in the system configured on PPP network\ninterfaces with an operational state of noResources(4).")
jnxPppSummaryPppNetworkIpv6NcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 80), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6NcpNotPresent.setDescription("The total number of IPV6 NCPs in the system configured on PPP network\ninterfaces with an operational state of notPresent(3).")
jnxPppSummaryPppNetworkIpv6NcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 81), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkIpv6NcpNoResources.setDescription("The total number of IPV6 NCPs in the system configured on PPP network\ninterfaces with an operational state of noResources(4).")
jnxPppSummaryPppNetworkOsiNcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 82), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiNcpNotPresent.setDescription("The total number of OSI NCPs in the system configured on PPP network\ninterfaces with an operational state of notPresent(3).")
jnxPppSummaryPppNetworkOsiNcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 83), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkOsiNcpNoResources.setDescription("The total number of OSI NCPs in the system configured on PPP network\ninterfaces with an operational state of noResources(4).")
jnxPppSummaryPppNetworkMplsNcpOpened = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 84), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsNcpOpened.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces with an operational state of opened(1).")
jnxPppSummaryPppNetworkMplsNcpClosed = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 85), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsNcpClosed.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces with an operational state of not-opened(2).")
jnxPppSummaryPppNetworkMplsNcpNotPresent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 86), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsNcpNotPresent.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces with an operational state of notPresent(3).")
jnxPppSummaryPppNetworkMplsNcpNoResources = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 7, 87), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppSummaryPppNetworkMplsNcpNoResources.setDescription("The total number of MPLS NCPs in the system configured on PPP network\ninterfaces with an operational state of noResources(4).")
jnxPppIpv6 = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8))
jnxPppIpv6Table = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1))
if mibBuilder.loadTexts: jnxPppIpv6Table.setDescription("Table containing the IPv6 parameters for the local PPP entity.")
jnxPppIpv6Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppIpv6Entry.setDescription("IPV6CP status information for a particular PPP link.")
jnxPppIpv6ServiceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6ServiceStatus.setDescription("Indicates whether IPv6 protocol service is operating over this PPP\nlink.  Service is established on this link through means outside this\nMIB.")
jnxPppIpv6OperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("opened", 1), ("notOpened", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6OperStatus.setDescription("The operational status of the IPv6 network protocol.  If the value of\nthis object is up then the finite state machine for the IPv6 network\nprotocol has reached the Opened state.")
jnxPppIpv6TerminateReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(5,0,1,8,3,6,4,7,2,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("noService", 2), ("admin", 3), ("linkDown", 4), ("peerTerminated", 5), ("peerRenegotiated", 6), ("maxRetriesExceeded", 7), ("negotiationFailure", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6TerminateReason.setDescription("Reason the IPV6CP link was terminated:\nnone                    None.\nother                   Not specified.\nnoService              No IPv6 service configured on this PPP link.\nadmin                   Administratively disabled.\nlinkDown                Underlying link is down.\npeerTerminated          Peer initiated termination.\npeerRenegotiated        Peer initiated renegotiation.\nmaxRetriesExceeded      Maximum number of config retries exceeded.\nnegotiationFailure      Failed to negotiate IPV6CP option.  See\n                        jnxPppIpv6TerminateNegFailOption.")
jnxPppIpv6TerminateNegFailOption = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,3,2,)).subtype(namedValues=NamedValues(("none", 0), ("other", 1), ("localIpv6AddressIfIdentifier", 2), ("remoteIpv6AddressIfIdentifier", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6TerminateNegFailOption.setDescription("Reports the PPP IPV6CP option for which negotiation failed, when\njnxPppIpv6TerminateReason has the value 'negotiationFailure'.")
jnxPppIpv6LocalIpv6AddressIfIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 5), Ipv6AddressIfIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6LocalIpv6AddressIfIdentifier.setDescription("IPv6 Address Interface Identifier used by the local side.")
jnxPppIpv6RemoteIpv6AddressIfIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 6), Ipv6AddressIfIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6RemoteIpv6AddressIfIdentifier.setDescription("IPv6 Address Interface Identifier used by the remote side.")
jnxPppIpv6NetworkStatusIpv6cpRenegoTerminates = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6NetworkStatusIpv6cpRenegoTerminates.setDescription("Number of times ipv6cp terminated due to peer exceeding max\nrenegotiation attempts.")
jnxPppIpv6ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 2))
if mibBuilder.loadTexts: jnxPppIpv6ConfigTable.setDescription("Table containing the IPv6 parameters for the local PPP entity.")
jnxPppIpv6ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxPppIpv6ConfigEntry.setDescription("IPV6CP configuration information for a particular PPP link.")
jnxPppIpv6ConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("open", 1), ("close", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6ConfigAdminStatus.setDescription("The immediate desired status of the IPv6 network protocol.  Setting\nthis object to open will inject an administrative open event into the\nIPv6 network protocol's finite state machine.  Setting this object to\nclose will inject an administrative close event into the IPv6 network\nprotocol's finite state machine.")
jnxPppIpv6ConfigInitiateIpv6 = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 2, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6ConfigInitiateIpv6.setDescription("Enables the initiation of negotiation of the IPv6CP.")
jnxPppIpv6ConfigMaxIpv6cpRenegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppIpv6ConfigMaxIpv6cpRenegotiation.setDescription("Maximum number of allowed ipv6cp renegotiation attempts from peer.")
jnxPppGlobalConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 9))
jnxPppPeerIpAddressOptional = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 68, 1, 1, 9, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxPppPeerIpAddressOptional.setDescription("This option is used to ignore the conflicts between ppp client's  \nrequested IP address and radius/local pool returned address in server \nduring IPNCP  negotiation. Enabling this will ensure the IPNCP  \nnegotiation to succeed even though the client does not include \nIP address option in the  IPNCP configure request.")

# Augmentions

# Exports

# Module identity
mibBuilder.exportSymbols("JNX-PPP-MIB", PYSNMP_MODULE_ID=jnxPppMIB)

# Types
mibBuilder.exportSymbols("JNX-PPP-MIB", JnxNibbleConfig=JnxNibbleConfig, JnxPppAuthentication=JnxPppAuthentication, JnxPppAuthentication2=JnxPppAuthentication2, JnxPppMlPppBundleName=JnxPppMlPppBundleName)

# Objects
mibBuilder.exportSymbols("JNX-PPP-MIB", jnxPppMIB=jnxPppMIB, jnxPPPObjects=jnxPPPObjects, jnxPppLcp=jnxPppLcp, jnxPppLinkStatusTable=jnxPppLinkStatusTable, jnxPppLinkStatusEntry=jnxPppLinkStatusEntry, jnxPppLinkStatusTerminateReason=jnxPppLinkStatusTerminateReason, jnxPppLinkStatusTerminateNegFailOption=jnxPppLinkStatusTerminateNegFailOption, jnxPppLinkStatusInKeepaliveRequests=jnxPppLinkStatusInKeepaliveRequests, jnxPppLinkStatusOutKeepaliveRequests=jnxPppLinkStatusOutKeepaliveRequests, jnxPppLinkStatusInKeepaliveReplies=jnxPppLinkStatusInKeepaliveReplies, jnxPppLinkStatusOutKeepaliveReplies=jnxPppLinkStatusOutKeepaliveReplies, jnxPppLinkStatusKeepaliveFailures=jnxPppLinkStatusKeepaliveFailures, jnxPppLinkStatusLocalMagicNumber=jnxPppLinkStatusLocalMagicNumber, jnxPppLinkStatusRemoteMagicNumber=jnxPppLinkStatusRemoteMagicNumber, jnxPppLinkStatusLocalAuthentication=jnxPppLinkStatusLocalAuthentication, jnxPppLinkStatusTunnelIfIndex=jnxPppLinkStatusTunnelIfIndex, jnxPppLinkStatuslcpRenegoTerminates=jnxPppLinkStatuslcpRenegoTerminates, jnxPppLinkStatusLocalMagicNumber1=jnxPppLinkStatusLocalMagicNumber1, jnxPppLinkStatusRemoteMagicNumber1=jnxPppLinkStatusRemoteMagicNumber1, jnxPppLinkConfigTable=jnxPppLinkConfigTable, jnxPppLinkConfigEntry=jnxPppLinkConfigEntry, jnxPppLinkConfigIfIndex=jnxPppLinkConfigIfIndex, jnxPppLinkConfigRowStatus=jnxPppLinkConfigRowStatus, jnxPppLinkConfigLowerIfIndex=jnxPppLinkConfigLowerIfIndex, jnxPppLinkConfigKeepalive=jnxPppLinkConfigKeepalive, jnxPppLinkConfigAuthentication=jnxPppLinkConfigAuthentication, jnxPppLinkConfigMaxAuthenRetries=jnxPppLinkConfigMaxAuthenRetries, jnxPppLinkConfigStandardIfIndex=jnxPppLinkConfigStandardIfIndex, jnxPppLinkConfigChapMinChallengeLength=jnxPppLinkConfigChapMinChallengeLength, jnxPppLinkConfigChapMaxChallengeLength=jnxPppLinkConfigChapMaxChallengeLength, jnxPppLinkConfigPassiveMode=jnxPppLinkConfigPassiveMode, jnxPppLinkConfigAuthenticatorLogicalSystem=jnxPppLinkConfigAuthenticatorLogicalSystem, jnxPppLinkConfigAuthenticatorRoutingInstance=jnxPppLinkConfigAuthenticatorRoutingInstance, jnxPppLinkConfigAaaProfile=jnxPppLinkConfigAaaProfile, jnxPppLinkConfigAuthentication2=jnxPppLinkConfigAuthentication2, jnxPppLinkConfigIgnoreMagicNumberMismatch=jnxPppLinkConfigIgnoreMagicNumberMismatch, jnxPppLinkConfigMaxLcpRenegotiation=jnxPppLinkConfigMaxLcpRenegotiation, jnxPppNextIfIndex=jnxPppNextIfIndex, jnxPppSec=jnxPppSec, jnxPppIp=jnxPppIp, jnxPppIpTable=jnxPppIpTable, jnxPppIpEntry=jnxPppIpEntry, jnxPppIpServiceStatus=jnxPppIpServiceStatus, jnxPppIpTerminateReason=jnxPppIpTerminateReason, jnxPppIpTerminateNegFailOption=jnxPppIpTerminateNegFailOption, jnxPppIpLocalIpAddress=jnxPppIpLocalIpAddress, jnxPppIpRemoteIpAddress=jnxPppIpRemoteIpAddress, jnxPppIpRemotePrimaryDnsAddress=jnxPppIpRemotePrimaryDnsAddress, jnxPppIpRemoteSecondaryDnsAddress=jnxPppIpRemoteSecondaryDnsAddress, jnxPppIpRemotePrimaryWinsAddress=jnxPppIpRemotePrimaryWinsAddress, jnxPppIpRemoteSecondaryWinsAddress=jnxPppIpRemoteSecondaryWinsAddress, jnxPppIpNetworkStatusIpcpRenegoTerminates=jnxPppIpNetworkStatusIpcpRenegoTerminates, jnxPppIpConfigTable=jnxPppIpConfigTable, jnxPppIpConfigEntry=jnxPppIpConfigEntry, jnxPppIpConfigPeerDnsPriority=jnxPppIpConfigPeerDnsPriority, jnxPppIpConfigPeerWinsPriority=jnxPppIpConfigPeerWinsPriority, jnxPppIpConfigIpcpNetmask=jnxPppIpConfigIpcpNetmask, jnxPppIpConfigInitiateIp=jnxPppIpConfigInitiateIp, jnxPppIpConfigMaxIpcpRenegotiation=jnxPppIpConfigMaxIpcpRenegotiation, jnxPppIpConfigPromptIpcpDnsOption=jnxPppIpConfigPromptIpcpDnsOption, jnxPppIpConfigIpcpLockout=jnxPppIpConfigIpcpLockout, jnxPppOsi=jnxPppOsi, jnxPppOsiTable=jnxPppOsiTable, jnxPppOsiEntry=jnxPppOsiEntry, jnxPppOsiServiceStatus=jnxPppOsiServiceStatus, jnxPppOsiOperStatus=jnxPppOsiOperStatus, jnxPppOsiTerminateReason=jnxPppOsiTerminateReason, jnxPppOsiTerminateNegFailOption=jnxPppOsiTerminateNegFailOption, jnxPppOsiLocalAlignNpdu=jnxPppOsiLocalAlignNpdu, jnxPppOsiRemoteAlignNpdu=jnxPppOsiRemoteAlignNpdu, jnxPppOsiConfigTable=jnxPppOsiConfigTable, jnxPppOsiConfigEntry=jnxPppOsiConfigEntry, jnxPppOsiConfigAdminStatus=jnxPppOsiConfigAdminStatus, jnxPppSession=jnxPppSession, jnxPppSessionTable=jnxPppSessionTable, jnxPppSessionEntry=jnxPppSessionEntry, jnxPppSessionGrant=jnxPppSessionGrant, jnxPppSessionTerminateReason=jnxPppSessionTerminateReason, jnxPppSessionStartTime=jnxPppSessionStartTime, jnxPppSessionInOctets=jnxPppSessionInOctets, jnxPppSessionOutOctets=jnxPppSessionOutOctets, jnxPppSessionInPackets=jnxPppSessionInPackets, jnxPppSessionOutPackets=jnxPppSessionOutPackets, jnxPppSessionSessionTimeout=jnxPppSessionSessionTimeout, jnxPppSessionInactivityTimeout=jnxPppSessionInactivityTimeout, jnxPppSessionAccountingInterval=jnxPppSessionAccountingInterval, jnxPppSessionRemoteIpAddress=jnxPppSessionRemoteIpAddress, jnxPppSessionRemotePrimaryDnsAddress=jnxPppSessionRemotePrimaryDnsAddress, jnxPppSessionRemoteSecondaryDnsAddress=jnxPppSessionRemoteSecondaryDnsAddress, jnxPppSessionRemotePrimaryWinsAddress=jnxPppSessionRemotePrimaryWinsAddress, jnxPppSessionRemoteSecondaryWinsAddress=jnxPppSessionRemoteSecondaryWinsAddress, jnxPppSessionRemoteIpv6AddressIfIdentifier=jnxPppSessionRemoteIpv6AddressIfIdentifier, jnxPppSessionInhibitIp=jnxPppSessionInhibitIp, jnxPppSessionInhibitIpv6=jnxPppSessionInhibitIpv6, jnxPppSessionInOctets64=jnxPppSessionInOctets64, jnxPppSessionOutOctets64=jnxPppSessionOutOctets64, jnxPppSessionInPackets64=jnxPppSessionInPackets64, jnxPppSessionOutPackets64=jnxPppSessionOutPackets64, jnxPppMlPpp=jnxPppMlPpp, jnxPppMlPppBundleTable=jnxPppMlPppBundleTable, jnxPppMlPppBundleEntry=jnxPppMlPppBundleEntry, jnxPppMlPppBundleName=jnxPppMlPppBundleName, jnxPppMlPppBundleRowStatus=jnxPppMlPppBundleRowStatus, jnxPppMlPppBundleNetworkIfIndex=jnxPppMlPppBundleNetworkIfIndex, jnxPppMlPppNextLinkIfIndex=jnxPppMlPppNextLinkIfIndex, jnxPppMlPppLinkConfigTable=jnxPppMlPppLinkConfigTable, jnxPppMlPppLinkConfigEntry=jnxPppMlPppLinkConfigEntry, jnxPppMlPppLinkConfigIfIndex=jnxPppMlPppLinkConfigIfIndex, jnxPppMlPppLinkConfigLowerIfIndex=jnxPppMlPppLinkConfigLowerIfIndex, jnxPppMlPppLinkConfigKeepalive=jnxPppMlPppLinkConfigKeepalive, jnxPppMlPppLinkConfigAuthentication=jnxPppMlPppLinkConfigAuthentication, jnxPppMlPppLinkConfigMaxAuthenRetries=jnxPppMlPppLinkConfigMaxAuthenRetries, jnxPppMlPppLinkConfigRowStatus=jnxPppMlPppLinkConfigRowStatus, jnxPppMlPppLinkConfigAaaProfile=jnxPppMlPppLinkConfigAaaProfile, jnxPppMlPppLinkConfigChapMinChallengeLength=jnxPppMlPppLinkConfigChapMinChallengeLength, jnxPppMlPppLinkConfigChapMaxChallengeLength=jnxPppMlPppLinkConfigChapMaxChallengeLength, jnxPppMlPppLinkConfigPassiveMode=jnxPppMlPppLinkConfigPassiveMode, jnxPppMlPppLinkConfigAuthenticatorLogicalSystem=jnxPppMlPppLinkConfigAuthenticatorLogicalSystem, jnxPppMlPppLinkConfigAuthenticatorRoutingInstance=jnxPppMlPppLinkConfigAuthenticatorRoutingInstance, jnxPppMlPppLinkConfigFragmentation=jnxPppMlPppLinkConfigFragmentation, jnxPppMlPppLinkConfigReassembly=jnxPppMlPppLinkConfigReassembly, jnxPppMlPppLinkConfigMaxReceiveReconstructedUnit=jnxPppMlPppLinkConfigMaxReceiveReconstructedUnit, jnxPppMlPppLinkConfigFragmentSize=jnxPppMlPppLinkConfigFragmentSize, jnxPppMlPppLinkConfigHashLinkSelection=jnxPppMlPppLinkConfigHashLinkSelection, jnxPppMlPppLinkConfigAuthentication2=jnxPppMlPppLinkConfigAuthentication2, jnxPppMlPppLinkConfigIgnoreMagicNumberMismatch=jnxPppMlPppLinkConfigIgnoreMagicNumberMismatch)
mibBuilder.exportSymbols("JNX-PPP-MIB", jnxPppMlPppLinkConfigMultilinkMulticlass=jnxPppMlPppLinkConfigMultilinkMulticlass, jnxPppMlPppLinkConfigMultilinkMaxMultiClasses=jnxPppMlPppLinkConfigMultilinkMaxMultiClasses, jnxPppMlPppNextNetworkIfIndex=jnxPppMlPppNextNetworkIfIndex, jnxPppMlPppNetworkConfigTable=jnxPppMlPppNetworkConfigTable, jnxPppMlPppNetworkConfigEntry=jnxPppMlPppNetworkConfigEntry, jnxPppMlPppNetworkConfigIfIndex=jnxPppMlPppNetworkConfigIfIndex, jnxPppMlPppNetworkConfigLowerIfIndex=jnxPppMlPppNetworkConfigLowerIfIndex, jnxPppMlPppNetworkBundleName=jnxPppMlPppNetworkBundleName, jnxPppMlPppNetworkRowStatus=jnxPppMlPppNetworkRowStatus, jnxPppMlPppLinkBindTable=jnxPppMlPppLinkBindTable, jnxPppMlPppLinkBindEntry=jnxPppMlPppLinkBindEntry, jnxPppMlPppBindNetworkIfIndex=jnxPppMlPppBindNetworkIfIndex, jnxPppMlPppBindLinkIfIndex=jnxPppMlPppBindLinkIfIndex, jnxPppMlPppBindRowStatus=jnxPppMlPppBindRowStatus, jnxPppSummary=jnxPppSummary, jnxPppSummaryPppInterfaceCount=jnxPppSummaryPppInterfaceCount, jnxPppSummaryPppIpNCPs=jnxPppSummaryPppIpNCPs, jnxPppSummaryPppOsiNCPs=jnxPppSummaryPppOsiNCPs, jnxPppSummaryPppIfAdminUp=jnxPppSummaryPppIfAdminUp, jnxPppSummaryPppIfAdminDown=jnxPppSummaryPppIfAdminDown, jnxPppSummaryPppIfOperUp=jnxPppSummaryPppIfOperUp, jnxPppSummaryPppIfOperDown=jnxPppSummaryPppIfOperDown, jnxPppSummaryPppIfOperDormant=jnxPppSummaryPppIfOperDormant, jnxPppSummaryPppIfNotPresent=jnxPppSummaryPppIfNotPresent, jnxPppSummaryPppIfLowerLayerDown=jnxPppSummaryPppIfLowerLayerDown, jnxPppSummaryPppIpNcpOpened=jnxPppSummaryPppIpNcpOpened, jnxPppSummaryPppIpNcpClosed=jnxPppSummaryPppIpNcpClosed, jnxPppSummaryPppOsiNcpOpened=jnxPppSummaryPppOsiNcpOpened, jnxPppSummaryPppOsiNcpClosed=jnxPppSummaryPppOsiNcpClosed, jnxPppSummaryPppIfLastChangeTime=jnxPppSummaryPppIfLastChangeTime, jnxPppSummaryPppLinkInterfaceCount=jnxPppSummaryPppLinkInterfaceCount, jnxPppSummaryPppLinkIfAdminUp=jnxPppSummaryPppLinkIfAdminUp, jnxPppSummaryPppLinkIfAdminDown=jnxPppSummaryPppLinkIfAdminDown, jnxPppSummaryPppLinkIfOperUp=jnxPppSummaryPppLinkIfOperUp, jnxPppSummaryPppLinkIfOperDown=jnxPppSummaryPppLinkIfOperDown, jnxPppSummaryPppLinkIfOperDormant=jnxPppSummaryPppLinkIfOperDormant, jnxPppSummaryPppLinkIfNotPresent=jnxPppSummaryPppLinkIfNotPresent, jnxPppSummaryPppLinkIfLowerLayerDown=jnxPppSummaryPppLinkIfLowerLayerDown, jnxPppSummaryPppLinkIfLastChangeTime=jnxPppSummaryPppLinkIfLastChangeTime, jnxPppSummaryPppNetworkInterfaceCount=jnxPppSummaryPppNetworkInterfaceCount, jnxPppSummaryPppNetworkIpNCPs=jnxPppSummaryPppNetworkIpNCPs, jnxPppSummaryPppNetworkOsiNCPs=jnxPppSummaryPppNetworkOsiNCPs, jnxPppSummaryPppNetworkIfAdminUp=jnxPppSummaryPppNetworkIfAdminUp, jnxPppSummaryPppNetworkIfAdminDown=jnxPppSummaryPppNetworkIfAdminDown, jnxPppSummaryPppNetworkIfOperUp=jnxPppSummaryPppNetworkIfOperUp, jnxPppSummaryPppNetworkIfOperDown=jnxPppSummaryPppNetworkIfOperDown, jnxPppSummaryPppNetworkIfOperDormant=jnxPppSummaryPppNetworkIfOperDormant, jnxPppSummaryPppNetworkIfNotPresent=jnxPppSummaryPppNetworkIfNotPresent, jnxPppSummaryPppNetworkIfLowerLayerDown=jnxPppSummaryPppNetworkIfLowerLayerDown, jnxPppSummaryPppNetworkIpNcpOpened=jnxPppSummaryPppNetworkIpNcpOpened, jnxPppSummaryPppNetworkIpNcpClosed=jnxPppSummaryPppNetworkIpNcpClosed, jnxPppSummaryPppNetworkOsiNcpOpened=jnxPppSummaryPppNetworkOsiNcpOpened, jnxPppSummaryPppNetworkOsiNcpClosed=jnxPppSummaryPppNetworkOsiNcpClosed, jnxPppSummaryPppNetworkIfLastChangeTime=jnxPppSummaryPppNetworkIfLastChangeTime, jnxPppSummaryPppIpv6NCPs=jnxPppSummaryPppIpv6NCPs, jnxPppSummaryPppIpv6NcpOpened=jnxPppSummaryPppIpv6NcpOpened, jnxPppSummaryPppIpv6NcpClosed=jnxPppSummaryPppIpv6NcpClosed, jnxPppSummaryPppNetworkIpv6NCPs=jnxPppSummaryPppNetworkIpv6NCPs, jnxPppSummaryPppNetworkIpv6NcpOpened=jnxPppSummaryPppNetworkIpv6NcpOpened, jnxPppSummaryPppNetworkIpv6NcpClosed=jnxPppSummaryPppNetworkIpv6NcpClosed, jnxPppSummaryPppStaticInterfaceCount=jnxPppSummaryPppStaticInterfaceCount, jnxPppSummaryPppMplsNCPs=jnxPppSummaryPppMplsNCPs, jnxPppSummaryPppIpAdminOpen=jnxPppSummaryPppIpAdminOpen, jnxPppSummaryPppIpAdminClose=jnxPppSummaryPppIpAdminClose, jnxPppSummaryPppIpv6AdminOpen=jnxPppSummaryPppIpv6AdminOpen, jnxPppSummaryPppIpv6AdminClose=jnxPppSummaryPppIpv6AdminClose, jnxPppSummaryPppOsiAdminOpen=jnxPppSummaryPppOsiAdminOpen, jnxPppSummaryPppOsiAdminClose=jnxPppSummaryPppOsiAdminClose, jnxPppSummaryPppMplsAdminOpen=jnxPppSummaryPppMplsAdminOpen, jnxPppSummaryPppMplsAdminClose=jnxPppSummaryPppMplsAdminClose, jnxPppSummaryPppIpNcpNotPresent=jnxPppSummaryPppIpNcpNotPresent, jnxPppSummaryPppIpNcpNoResources=jnxPppSummaryPppIpNcpNoResources, jnxPppSummaryPppIpv6NcpNotPresent=jnxPppSummaryPppIpv6NcpNotPresent, jnxPppSummaryPppIpv6NcpNoResources=jnxPppSummaryPppIpv6NcpNoResources, jnxPppSummaryPppOsiNcpNotPresent=jnxPppSummaryPppOsiNcpNotPresent, jnxPppSummaryPppOsiNcpNoResources=jnxPppSummaryPppOsiNcpNoResources, jnxPppSummaryPppMplsNcpOpened=jnxPppSummaryPppMplsNcpOpened, jnxPppSummaryPppMplsNcpClosed=jnxPppSummaryPppMplsNcpClosed, jnxPppSummaryPppMplsNcpNotPresent=jnxPppSummaryPppMplsNcpNotPresent, jnxPppSummaryPppMplsNcpNoResources=jnxPppSummaryPppMplsNcpNoResources, jnxPppSummaryPppLinkStaticInterfaceCount=jnxPppSummaryPppLinkStaticInterfaceCount, jnxPppSummaryPppNetworkStaticInterfaceCount=jnxPppSummaryPppNetworkStaticInterfaceCount, jnxPppSummaryPppNetworkMplsNCPs=jnxPppSummaryPppNetworkMplsNCPs, jnxPppSummaryPppNetworkIpAdminOpen=jnxPppSummaryPppNetworkIpAdminOpen, jnxPppSummaryPppNetworkIpAdminClose=jnxPppSummaryPppNetworkIpAdminClose, jnxPppSummaryPppNetworkIpv6AdminOpen=jnxPppSummaryPppNetworkIpv6AdminOpen, jnxPppSummaryPppNetworkIpv6AdminClose=jnxPppSummaryPppNetworkIpv6AdminClose, jnxPppSummaryPppNetworkOsiAdminOpen=jnxPppSummaryPppNetworkOsiAdminOpen, jnxPppSummaryPppNetworkOsiAdminClose=jnxPppSummaryPppNetworkOsiAdminClose, jnxPppSummaryPppNetworkMplsAdminOpen=jnxPppSummaryPppNetworkMplsAdminOpen, jnxPppSummaryPppNetworkMplsAdminClose=jnxPppSummaryPppNetworkMplsAdminClose, jnxPppSummaryPppNetworkIpNcpNotPresent=jnxPppSummaryPppNetworkIpNcpNotPresent, jnxPppSummaryPppNetworkIpNcpNoResources=jnxPppSummaryPppNetworkIpNcpNoResources, jnxPppSummaryPppNetworkIpv6NcpNotPresent=jnxPppSummaryPppNetworkIpv6NcpNotPresent, jnxPppSummaryPppNetworkIpv6NcpNoResources=jnxPppSummaryPppNetworkIpv6NcpNoResources, jnxPppSummaryPppNetworkOsiNcpNotPresent=jnxPppSummaryPppNetworkOsiNcpNotPresent, jnxPppSummaryPppNetworkOsiNcpNoResources=jnxPppSummaryPppNetworkOsiNcpNoResources, jnxPppSummaryPppNetworkMplsNcpOpened=jnxPppSummaryPppNetworkMplsNcpOpened, jnxPppSummaryPppNetworkMplsNcpClosed=jnxPppSummaryPppNetworkMplsNcpClosed, jnxPppSummaryPppNetworkMplsNcpNotPresent=jnxPppSummaryPppNetworkMplsNcpNotPresent, jnxPppSummaryPppNetworkMplsNcpNoResources=jnxPppSummaryPppNetworkMplsNcpNoResources, jnxPppIpv6=jnxPppIpv6, jnxPppIpv6Table=jnxPppIpv6Table, jnxPppIpv6Entry=jnxPppIpv6Entry, jnxPppIpv6ServiceStatus=jnxPppIpv6ServiceStatus, jnxPppIpv6OperStatus=jnxPppIpv6OperStatus, jnxPppIpv6TerminateReason=jnxPppIpv6TerminateReason, jnxPppIpv6TerminateNegFailOption=jnxPppIpv6TerminateNegFailOption, jnxPppIpv6LocalIpv6AddressIfIdentifier=jnxPppIpv6LocalIpv6AddressIfIdentifier, jnxPppIpv6RemoteIpv6AddressIfIdentifier=jnxPppIpv6RemoteIpv6AddressIfIdentifier, jnxPppIpv6NetworkStatusIpv6cpRenegoTerminates=jnxPppIpv6NetworkStatusIpv6cpRenegoTerminates, jnxPppIpv6ConfigTable=jnxPppIpv6ConfigTable, jnxPppIpv6ConfigEntry=jnxPppIpv6ConfigEntry, jnxPppIpv6ConfigAdminStatus=jnxPppIpv6ConfigAdminStatus, jnxPppIpv6ConfigInitiateIpv6=jnxPppIpv6ConfigInitiateIpv6, jnxPppIpv6ConfigMaxIpv6cpRenegotiation=jnxPppIpv6ConfigMaxIpv6cpRenegotiation, jnxPppGlobalConfig=jnxPppGlobalConfig, jnxPppPeerIpAddressOptional=jnxPppPeerIpAddressOptional)

