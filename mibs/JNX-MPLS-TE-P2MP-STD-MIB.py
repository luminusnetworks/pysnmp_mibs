# PySNMP SMI module. Autogenerated from smidump -f python JNX-MPLS-TE-P2MP-STD-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:55 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( IndexInteger, IndexIntegerNextFree, ) = mibBuilder.importSymbols("DIFFSERV-MIB", "IndexInteger", "IndexIntegerNextFree")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( jnxP2mpExperiment, ) = mibBuilder.importSymbols("JUNIPER-EXPERIMENT-MIB", "jnxP2mpExperiment")
( MplsIndexType, ) = mibBuilder.importSymbols("MPLS-LSR-STD-MIB", "MplsIndexType")
( MplsPathIndexOrZero, mplsStdMIB, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsPathIndexOrZero", "mplsStdMIB")
( mplsTunnelEgressLSRId, mplsTunnelIndex, mplsTunnelIngressLSRId, mplsTunnelInstance, ) = mibBuilder.importSymbols("MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId", "mplsTunnelIndex", "mplsTunnelIngressLSRId", "mplsTunnelInstance")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32")
( RowStatus, StorageType, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TimeStamp", "TruthValue")

# Objects

jnxMplsTeP2mpStdMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1)).setRevisions(("2009-04-17 00:00",))
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setOrganization("Multiprotocol Label Switching (MPLS) Working Group")
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setContactInfo("        Adrian Farrel\nOld Dog Consulting\nEmail:  adrian@olddog.co.uk\n\nSeisho Yasukawa\nNTT Corporation\nEmail:  s.yasukawa@hco.ntt.co.jp\n\nThomas D. Nadeau\nBritish Telecom\nEmail:  tom.nadeau@bt.com\n\nComments about this document should be emailed\ndirectly to the MPLS working group mailing list at\nmpls@lists.ietf.org")
if mibBuilder.loadTexts: jnxMplsTeP2mpStdMIB.setDescription("Copyright (c) 2009 IETF Trust and the persons identified as\nthe document authors. All rights reserved.\n\nThis document is subject to BCP 78 and the IETF Trust's\nLegal Provisions Relating to IETF Documents in effect on the\ndate of publication of this document\n(http://trustee.ietf.org/license-info). Please review these\ndocuments carefully, as they describe your rights and\nrestrictions with respect to this document.\n\nThe initial version of this MIB module was published in\nRFC XXXX. For full legal notices see the RFC itself or see:\nhttp://www.ietf.org/copyrights/ianamib.html\n-- RFC Editor. Please replace XXXX with the RFC number for this\n-- document and remove this note.\n\nThis MIB module contains managed object definitions\nfor Point-to-Multipoint (P2MP) MPLS Traffic Engineering (TE)\ndefined in:\n1. Signaling Requirements for Point-to-Multipoint\n   Traffic-Engineered MPLS Label Switched Paths (LSPs),\n   S. Yasukawa, RFC 4461, April 2006.\n2. Extensions to Resource Reservation Protocol - Traffic\n   Engineering (RSVP-TE) for Point-to-Multipoint TE Label\n   Switched Paths (LSPs), Aggarwal, R., Papadimitriou, D.,\n   and Yasukawa, S., RFC 4875, May 2007.")
jnxMplsTeP2mpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 0))
jnxMplsTeP2mpScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1))
jnxMplsTeP2mpTunnelConfigured = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelConfigured.setDescription("The number of P2MP tunnels configured on this device. A\ntunnel is considered configured if the mplsTunnelRowStatus\nin MPLS-TE-STD-MIB is active(1).")
jnxMplsTeP2mpTunnelActive = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelActive.setDescription("The number of P2MP tunnels active on this device. A\ntunnel is considered active if the mplsTunnelOperStatus\nin MPLS-TE-STD-MIB is up(1).")
jnxMplsTeP2mpTunnelTotalMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTotalMaxHops.setDescription("The maximum number of hops that can be specified for an\nentire P2MP tunnel on this device. This object should be\nused in conjunction with mplsTunnelMaxHops in\n\n\nMPLS-TE-STD-MIB that is used in the context of P2MP tunnels\nto express the maximum number of hops to any individual\ndestination of a P2MP tunnel that can be configured on this\ndevice. mplsTeP2mpTunnelTotalMaxHops would normally be set\nlarger than or equal to mplsTunnelMaxHops.")
jnxMplsTeP2mpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2))
jnxMplsTeP2mpTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelTable.setDescription("The mplsTeP2mpTunnelTable allows new P2MP MPLS tunnels to be\ncreated between an LSR and one or more remote end-points,\nand existing P2MP tunnels to be reconfigured or removed.\n\nThis table sparse augments mplsTunnelTable in\nMPLS-TE-STD-MIB such that entries in that table can be\nflagged as point-to-multipoint, and can be configured and\nmonitored appropriately.")
jnxMplsTeP2mpTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelEntry.setDescription("An entry in this table represents a P2MP MPLS tunnel.\nAn entry can be created by a network administrator or by an\nSNMP agent as instructed by an MPLS signaling protocol.\n\nAn entry in this table MUST correspond to an entry in the\nmplsTunnelTable in MPLS-TE-STD-MIB. This table shares index\nobjects with that table and sparse augments that table.\n\nThus, an entry in this table can only be created at the same\n\n\ntime as or after a corresponding entry in mplsTunnelTable,\nand an entry in mplsTunnelTable cannot be deleted while a\ncorresponding entry exists in this table.\n\nThis table entry includes a row status object, but\nadministrative and operational statuses should be taken from\nmplsTunnelAdminStatus and mplsTunnelOperStatus in the\ncorresponding entry in mplsTunnelTable.")
jnxMplsTeP2mpTunnelP2mpIntegrity = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpIntegrity.setDescription("Denotes whether or not P2MP Integrity is required for this\ntunnel.\n\nIf P2MP integrity is operational on a P2MP tunnel then the\nfailure of the path to any of the tunnel destinations should\ncause the teardown of the entire P2MP tunnel.")
jnxMplsTeP2mpTunnelBranchRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("notBranch", 1), ("branch", 2), ("bud", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchRole.setDescription("This value supplements the value in the object\nmplsTunnelRole in MPLS-TE-STD-MIB that indicates the role\nof this LSR in the tunnel represented by this entry in\nmplsTeP2mpTunnelTable.\n\nmplsTunnelRole may take any of the values:\n   head(1),\n   transit(2),\n   tail(3),\n   headTail(4)\n\nIf this LSR is an ingress and there is exactly one\nout-segment, mplsTunnelRole should contain the value\nhead(1), and mplsTeP2mpTunnelBranchRole should have the\nvalue notBranch(1).\n\nIf this LSR is an ingress with more than one out segment,\nmplsTunnelRole should contain the value head(1), and\nmplsTeP2mpTunnelBranchRole should have the value branch(2).\n\nIf this LSR is an ingress, an egress, and there is one or\nmore out-segments, mplsTunnelRole should contain the value\nheadTail(4), and mplsTeP2mpTunnelBranchRole should have the\nvalue bud(3).\n\nIf this LSR is a transit with exactly one out-segment,\nmplsTunnelRole should contain the value transit(2), and\nmplsTeP2mpTunnelBranchRole should have the value\nnotBranch(1).\n\nIf this LSR is a transit with more than one out-segment,\nmplsTunnelRole should contain the value transit(2), and\nmplsTeP2mpTunnelBranchRole should have the value branch(2).\n\nIf this LSR is a transit with one or more out-segments and\nis also an egress, mplsTunnelRole should contain the value\ntransit(2), and mplsTeP2mpTunnelBranchRole should have the\nvalue bud(3).\n\nIf this LSR is an egress with no out-segment and is not the\ningress, mplsTunnelRole should contain the value tail(3),\n\n\nand mplsTeP2mpTunnelBranchRole should have the value\nnotBranch(1).\n\nIf this LSR is an egress and has one or more out-segments,\nmplsTunnelRole should contain the value transit(1), and\nmplsTeP2mpTunnelBranchRole should have the value bud(3).")
jnxMplsTeP2mpTunnelP2mpXcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 4), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelP2mpXcIndex.setDescription("This object contains the value of mplsXCIndex, the primary\nindex of the mplsXCTable for all cross-connect entries for\nthis P2MP LSP.\n\nIf no XC entries have been created yet, this object must\nreturn zero.\n\nThe set of entries in the mplsXCTable for this P2MP LSP can\nbe walked by reading Get-or-GetNext starting with the three\nindexes to mplsXCTable set as:\n  mplsXCIndex            = the value of this object\n  mplsXCInSegmentIndex   = 0x0\n  mplsXCOutSegmentIndex  = 0x0")
jnxMplsTeP2mpTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelRowStatus.setDescription("This variable is used to create, modify, and/or delete a row\nin this table.  When a row in this table is in active(1)\nstate, no objects in that row can be modified by the agent\nexcept mplsTeP2mpTunnelRowStatus and\nmplsTeP2mpTunnelStorageType.\n\n\n\nThis object and mplsTunnelRowStatus in the corresponding\nentry in mplsTunnelTable in MPLS-TE-STD-MIB should be\nmanaged together. No objects in a row in this table can be\nmodified when the mplsTunnelRowStatus object in the\ncorresponding row in mplsTunnelTable has value active(1).\n\nNote that no admin or oper status objects are provided in\nthis table. The administrative and operational status of\nP2MP tunnels is taken from the values of\nmplsTunnelAdminStatus and mplsTunnelOperStatus in the\ncorresponding row mplsTunnelTable.")
jnxMplsTeP2mpTunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 1, 1, 6), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelStorageType.setDescription("The storage type for this tunnel entry.\nConceptual rows having the value 'permanent' need not allow\nwrite-access to any columnar objects in the row.")
jnxMplsTeP2mpTunnelSubGroupIDNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 2), IndexIntegerNextFree().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelSubGroupIDNext.setDescription("This object contains an unused value for\nmplsTeP2mpTunnelDestSubGroupID, or a zero to indicate that\nnone exists. Negative values are not allowed, as they do not\ncorrespond to valid values of\nmplsTeP2mpTunnelDestSubGroupID.\n\nNote that this object offers an unused value for an\nmplsTeP2mpTunnelDestSubGroupID value at the local LSR when\nit is a sub-group originator. In other cases, the value of\nmplsTeP2mpTunnelDestSubGroupID SHOULD be taken from the\nreceived value signaled by the signaling protocol and\n\n\ncorresponds to the value in\nmplsTeP2mpTunnelDestSrcSubGroupID.")
jnxMplsTeP2mpTunnelDestTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTable.setDescription("The mplsTeP2mpTunnelDestTable allows new destinations of\nP2MP MPLS tunnels to be added to and removed from P2MP\ntunnels.")
jnxMplsTeP2mpTunnelDestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSrcSubGroupID"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSubGroupOriginType"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSubGroupOrigin"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestSubGroupID"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDestinationType"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDestination"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestEntry.setDescription("An entry in this table represents a destination of a P2MP\nMPLS tunnel. An entry can be created by a network\nadministrator or by an SNMP agent as instructed by an MPLS\nsignaling protocol.\n\nEntries in this table share some index fields with the\nmplsTeP2mpTunnelTable and the mplsTunnelTable in\nMPLS-TE-STD-MIB. Entries in this table have no meaning\nunless there is a corresponding entry in\nmplsTeP2mpTunnelTable (which, itself, depends on a\ncorresponding entry in mplsTunnelTable).\n\nNote that the same destination may be present more than once\nif it is in more than one sub-group as reflected by the\nmplsTeP2mpTunnelDestSrcSubGroupOriginType,\nmplsTeP2mpTunnelDestSrcSubGroupOrigin,\nmplsTeP2mpTunnelDestSrcSubGroupID,\nmplsTeP2mpTunnelDestSubGroupOriginType,\nmplsTeP2mpTunnelDestSubGroupOrigin, and\nmplsTeP2mpTunnelDestSubGroupID, index objects.\n\nEntries in this table may be created at any time. If created\nbefore an entry in the mplsTeP2mpTunnelTable the entries\nhave no meaning, but may be kept ready for the creation of\nthe P2MP tunnel. If created after the entry in\n\n\nmplsTeP2mpTunnelTable, entries in this table may reflect the\naddition of destinations to active P2MP tunnels. For this\nreason, entries in this table are equipped with row, admin,\nand oper status objects. ")
jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType.setDescription("This object identifies the type of address carried in\nmplsTeP2mpTunnelDestSrcSubGroupOrigin.\n\nSince the object mplsTeP2mpTunnelDestSrcSubGroupOrigin must\nconform to the protocol specification, this object must\nreturn either ipv4(1) or ipv6(2) at a transit or egress LSR.\n\nAt an ingress LSR, there is no source sub-group and this\nobject should return the value unknown(0).")
jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(4,4),ValueSizeConstraint(16,16),))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin.setDescription("The TE Router ID (reachable and stable IP address) of the\noriginator of the P2MP sub-group as received on a Path\nmessage by a transit or egress LSR.\n\nThis object is interpreted in the context of\nmplsTeP2mpTunnelDestSrcSubGroupOriginType.\n\nThe value of the sub-group originator used on outgoing Path\nmessages is found in mplsTeP2mpTunnelDestSubGroupOrigin and\nis copied from this object unless this LSR is responsible\nfor changing the sub-group ID.\n\nAt an ingress LSR there is no received Path message.\nmplsTeP2mpTunnelDestSrcSubGroupOriginType should return\nunknown(0), and this object should return a zero-length\nstring.")
jnxMplsTeP2mpTunnelDestSrcSubGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 3), IndexInteger().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSrcSubGroupID.setDescription("The unique identifier assigned by the sub-group originator\nfor this sub-group of this P2MP tunnel as received on a Path\nmessage by a transit or egress LSR.\n\nThe value of the sub-group identifier used on outgoing Path\nmessages is found in mplsTeP2mpTunnelDestSubGroupID and is\ncopied from this object unless this LSR is responsible for\nchanging the sub-group ID.\n\nAt an ingress LSR there is no received Path message, and\nthis object should return zero.")
jnxMplsTeP2mpTunnelDestSubGroupOriginType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 4), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOriginType.setDescription("This object identifies the type of address carried in\nmplsTeP2mpTunnelDestSubGroupOrigin.\n\nThis object must return either ipv4(1) or ipv6(2) in keeping\nwith the protocol specification.")
jnxMplsTeP2mpTunnelDestSubGroupOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 5), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4,4),ValueSizeConstraint(16,16),))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupOrigin.setDescription("The TE Router ID (reachable and stable IP address) of the\noriginator of the P2MP sub-group. In many cases, this will\nbe the ingress LSR of the P2MP tunnel and will be the\nreceived signaled value as available in\nmplsTeP2mpTunnelDestSrcSubGroupOrigin.\n\nWhen a signaling protocol is used, this object corresponds\nto the Sub-Group Originator field in the SENDER_TEMPLATE\n\n\nobject.\n\nThis object is interpreted in the context of\nmplsTeP2mpTunnelDestSubGroupOriginType.")
jnxMplsTeP2mpTunnelDestSubGroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 6), IndexInteger().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestSubGroupID.setDescription("The unique identifier assigned by the sub-group originator\nfor this sub-group of this P2MP tunnel.\n\nAn appropriate value for this object during row creation\nwhen the sub-group origin in\nmplsTeP2mpTunnelDestSubGroupOrigin is the local LSR can\nbe obtained by reading mplsTeP2mpTunnelSubGroupIDNext.\n\nAt an egress, there is no downstream sub-group ID. This\nobject should return the value received from upstream and\nreported in mplsTeP2mpTunnelDestSrcSubGroupID.")
jnxMplsTeP2mpTunnelDestDestinationType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 7), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestinationType.setDescription("This object identifies the type of address carried in\nmplsTeP2mpTunnelDestDestination.\n\nThis object forms part of the index of this table and can,\ntherefore, not return the value unknown(0). Similarly, since\nthe object mplsTeP2mpTunnelDestDestination must conform to\nthe protocol specification, this object must return either\nipv4(1) or ipv6(2).")
jnxMplsTeP2mpTunnelDestDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 8), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4,4),ValueSizeConstraint(16,16),))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDestination.setDescription("A single destination of this P2MP tunnel. That is, a\nroutable TE address of a leaf. This will often be the TE\nRouter ID of the leaf, but can be any interface address.\n\nWhen a signaling protocol is used, this object corresponds\nto the S2L Sub-LSP destination address field in the\nS2L_SUB_LSP object.\n\nThis object is interpreted in the context of\nmplsTeP2mpTunnelDestDestinationType.")
jnxMplsTeP2mpTunnelDestBranchOutSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 9), MplsIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestBranchOutSegment.setDescription("This object identifies the outgoing branch from this LSR\ntowards the destination represented by this table entry. It\nmust be a unique identifier within the scope of this tunnel.\n\nIf MPLS-LSR-STD-MIB is implemented, this object should\ncontain an index into mplsOutSegmentTable.\n\nIf MPLS-LSR-STD-MIB is not implemented, the LSR should\nassign a unique value to each branch of the tunnel.\n\nThe value of this object is also used as an index into\nmplsTeP2mpTunnelBranchPerfTable.")
jnxMplsTeP2mpTunnelDestHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 10), MplsPathIndexOrZero().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestHopTableIndex.setDescription("Index into the mplsTunnelHopTable entry that specifies the\nexplicit route hops for this destination of the P2MP tunnel.\n\n\nThis object represents the configured route for the branch\nof the P2MP tree to this destination and is meaningful only\nat the head-end (ingress or root) of the P2MP tunnel. Note\nthat many such paths may be configured within the\nmplsTunnelHopTable for each destination, and that the object\nmplsTeP2mpTunnelDestPathInUse identifies which path has been\nselected for use.")
jnxMplsTeP2mpTunnelDestPathInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 11), MplsPathIndexOrZero().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestPathInUse.setDescription("This value denotes the configured path that was chosen as\nthe explicit path to this destination of this P2MP tunnel.\nThis value reflects the secondary index into\nmplsTunnelHopTable where the primary index comes from\nmplsTeP2mpTunnelDestHopTableIndex.\n\nThe path indicated by this object might not exactly match\nthe one signaled and recorded in mplsTunnelCHopTable as\nspecific details of the path might be computed locally.\n\nSimilarly, the path might not match the actual path in use\nas recorded in mplsTunnelARHopTable due to the fact that\nsome details of the path may have been resolved within the\nnetwork.\n\nA value of zero denotes that no path is currently in use or\navailable.")
jnxMplsTeP2mpTunnelDestCHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 12), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCHopTableIndex.setDescription("Index into the mplsTunnelCHopTable that identifies the\nexplicit path for this destination of the P2MP tunnel.\n\nThis path is based on the chosen configured path identified\nby mplsTeP2mpTunnelDestHopTableIndex and\nmplsTeP2mpTunnelDestPathInUse, but may have been modified\nand automatically updated by the agent when computed hops\nbecome available or when computed hops get modified.\n\n\nIf this destination is the destination of the 'first S2L\nsub-LSP' then this path will be signaled in the Explicit\nRoute Object. If this destination is the destination of a\n'subsequent S2L sub-LSP' then this path will be signaled in\na Secondary Explicit Route Object.")
jnxMplsTeP2mpTunnelDestARHopTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 13), MplsPathIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestARHopTableIndex.setDescription("Index into the mplsTunnelARHopTable that identifies the\nactual hops traversed to this destination of the P2MP\ntunnel. This is automatically updated by the agent when the\nactual hops becomes available.\n\nIf this destination is the destination of the 'first S2L\nsub-LSP' then this path will be signaled in the Recorded\nRoute Object. If this destination is the destination of a\n'subsequent S2L sub-LSP' then this path will be signaled in\na Secondary Recorded Route Object.")
jnxMplsTeP2mpTunnelDestTotalUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestTotalUpTime.setDescription("This value represents the aggregate up time for all\ninstances of this tunnel to this destination, if this\ninformation is available.\n\nIf this information is not available, this object MUST\nreturn a value of 0.")
jnxMplsTeP2mpTunnelDestInstanceUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestInstanceUpTime.setDescription("This value identifies the total time that the currently\nactive tunnel instance to this destination has had its\noperational status (mplsTeP2mpTunnelDestOperStatus) set to\nup(1) since it was last previously not up(1).")
jnxMplsTeP2mpTunnelDestPathChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestPathChanges.setDescription("This object counts the number of times the actual path for\nthis destination of this P2MP tunnel instance has changed.\nThis object should be read in conjunction with\nmplsTeP2mpTunnelDestDiscontinuityTime.")
jnxMplsTeP2mpTunnelDestLastPathChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestLastPathChange.setDescription("Specifies the time since the last change to the actual path\nfor this destination of this P2MP tunnel instance.")
jnxMplsTeP2mpTunnelDestCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestCreationTime.setDescription("Specifies the value of sysUpTime when the first instance of\nthis tunnel came into existence for this destination. That\nis, when the value of mplsTeP2mpTunnelDestOperStatus was\nfirst set to up(1).")
jnxMplsTeP2mpTunnelDestStateTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestStateTransitions.setDescription("This object counts the number of times the status\n\n\n(mplsTeP2mpTunnelDestOperStatus) of this tunnel instance to\nthis destination has changed.\nThis object should be read in conjunction with\nmplsTeP2mpTunnelDestDiscontinuityTime.")
jnxMplsTeP2mpTunnelDestDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which\nany one or more of this row's Counter32 objects experienced\na discontinuity. If no such discontinuity has occurred since\nthe last re-initialization of the local management\nsubsystem, then this object contains a zero value.")
jnxMplsTeP2mpTunnelDestAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestAdminStatus.setDescription("Indicates the desired operational status of this\ndestination of this P2MP tunnel.")
jnxMplsTeP2mpTunnelDestOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 22), Integer().subtype(subtypeSpec=SingleValueConstraint(7,4,3,1,2,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("lowerLayerDown", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestOperStatus.setDescription("Indicates the actual operational status of this destination\nof this P2MP tunnel. This object may be compared to\nmplsTunnelOperStatus that includes two other values:\n  dormant(5)    -- some component is missing\n\n\n  notPresent(6) -- down due to the state of\n                -- lower layer interfaces.\nThese states do not apply to an individual destination of a\nP2MP MPLS-TE LSP and so are not included in this object.")
jnxMplsTeP2mpTunnelDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 23), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestRowStatus.setDescription("This object is used to create, modify, and/or delete a row\nin this table. When a row in this table is in active(1)\nstate, no objects in that row can be modified by SET\noperations except mplsTeP2mpTunnelDestAdminStatus and\nmplsTeP2mpTunnelDestStorageType.")
jnxMplsTeP2mpTunnelDestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 3, 1, 24), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestStorageType.setDescription("The storage type for this table entry.\n\nConceptual rows having the value 'permanent' need\nnot allow write-access to any columnar objects in\nthe row.")
jnxMplsTeP2mpTunnelBranchPerfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfTable.setDescription("This table provides per-tunnel branch MPLS performance\ninformation.\n\nThis table is not valid for switching types other than\npacket.")
jnxMplsTeP2mpTunnelBranchPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1)).setIndexNames((0, "MPLS-TE-STD-MIB", "mplsTunnelIndex"), (0, "MPLS-TE-STD-MIB", "mplsTunnelInstance"), (0, "MPLS-TE-STD-MIB", "mplsTunnelIngressLSRId"), (0, "MPLS-TE-STD-MIB", "mplsTunnelEgressLSRId"), (0, "JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfBranch"))
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfEntry.setDescription("An entry in this table is created by the LSR for each\ndownstream branch (out-segment) from this LSR for this P2MP\ntunnel.\n\nMore than one destination as represented by an entry in the\nmplsTeP2mpTunnelDestTable may be reached through a single\nout-segment. More than one out-segment may belong to a\nsingle P2MP tunnel represented by an entry in\nmplsTeP2mpTunnelTable.\n\nEach entry in the table is indexed by the four identifiers\nof the P2MP tunnel, and the out-segment that identifies the\noutgoing branch.")
jnxMplsTeP2mpTunnelBranchPerfBranch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 1), MplsIndexType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfBranch.setDescription("This object identifies an outgoing branch from this LSR\nfor this tunnel. Its value is unique within the context of\nthe tunnel.\n\nIf MPLS-LSR-STD-MIB is implemented, this object should\n\n\ncontain an index into mplsOutSegmentTable.\n\nUnder all circumstances, this object should contain\nthe same value as mplsTeP2mpTunnelDestBranchOutSegment for\ndestinations reached on this branch.")
jnxMplsTeP2mpTunnelBranchPerfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfPackets.setDescription("Number of packets forwarded by the tunnel onto this branch.\nThis object should represents the 32-bit value of the least\nsignificant part of the 64-bit value if both\nmplsTeP2mpTunnelBranchPerfHCPackets is returned.\nThis object should be read in conjunction with\nmplsTeP2mpTunnelBranchDiscontinuityTime.")
jnxMplsTeP2mpTunnelBranchPerfHCPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfHCPackets.setDescription("High capacity counter for number of packets forwarded by the\ntunnel onto this branch.\nThis object should be read in conjunction with\nmplsTeP2mpTunnelBranchDiscontinuityTime.")
jnxMplsTeP2mpTunnelBranchPerfErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfErrors.setDescription("Number of packets dropped because of errors or for other\nreasons, that were supposed to be forwarded onto this\nbranch for this tunnel. This object should be read in\nconjunction with mplsTeP2mpTunnelBranchDiscontinuityTime.")
jnxMplsTeP2mpTunnelBranchPerfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfBytes.setDescription("Number of bytes forwarded by the tunnel onto this branch.\n\n\nThis object should represents the 32-bit value of the least\nsignificant part of the 64-bit value if both\nmplsTeP2mpTunnelBranchPerfHCBytes is returned.\nThis object should be read in conjunction with\nmplsTeP2mpTunnelBranchDiscontinuityTime.")
jnxMplsTeP2mpTunnelBranchPerfHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchPerfHCBytes.setDescription("High capacity counter for number of bytes forwarded\nby the tunnel onto this branch.\nThis object should be read in conjunction with\nmplsTeP2mpTunnelBranchDiscontinuityTime.")
jnxMplsTeP2mpTunnelBranchDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 4, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelBranchDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which\nany one or more of this row's Counter32 or Counter64 objects\nexperienced a discontinuity. If no such discontinuity has\noccurred since the last re-initialization of the local\nmanagement subsystem, then this object contains a zero\nvalue.")
jnxMplsTeP2mpTunnelNotificationEnable = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 2, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelNotificationEnable.setDescription("If this object is true(1), then it enables the generation of\nmplsTeP2mpTunnelDestUp and mplsTeP2mpTunnelDestDown\nnotifications. Otherwise these notifications are not\nemitted.\n\nNote that when tunnels have large numbers of destinations,\nsetting this object to true(1) may result in the generation\nof large numbers of notifications.")
jnxMplsTeP2mpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3))
jnxMplsTeP2mpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1))
jnxMplsTeP2mpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 2))

# Augmentions

# Notifications

jnxMplsTeP2mpTunnelDestUp = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 0, 1)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestOperStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestAdminStatus"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestUp.setDescription("This notification is generated when a\nmplsTeP2mpTunnelDestOperStatus object for one of the\ndestinations of one of the configured tunnels is about to\nleave the down(2) state and transition into some other\nstate.  This other state is indicated by the included value\nof mplsTeP2mpTunnelDestOperStatus.\n\nThis reporting of state transitions mirrors mplsTunnelUp.")
jnxMplsTeP2mpTunnelDestDown = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 0, 2)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestOperStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestAdminStatus"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpTunnelDestDown.setDescription("This notification is generated when a\nmplsTeP2mpTunnelDestOperStatus object for one of the\ndestinations of one of the configured tunnels is about to\nenter the down(2) state from some other state. This other\nstate is indicated by the included value of\nmplsTeP2mpTunnelDestOperStatus.\n\nThis reporting of state transitions mirrors mplsTunnelDown.")

# Groups

jnxMplsTeP2mpGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1, 1)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchDiscontinuityTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestInstanceUpTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestCHopTableIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelConfigured"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfBytes"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestRowStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelNotificationEnable"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelP2mpXcIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchRole"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestStateTransitions"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestCreationTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestPathChanges"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestBranchOutSegment"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestAdminStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestStorageType"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfHCBytes"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelActive"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDiscontinuityTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelSubGroupIDNext"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfHCPackets"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestLastPathChange"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelRowStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfPackets"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestPathInUse"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelStorageType"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestTotalUpTime"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelTotalMaxHops"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestHopTableIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelP2mpIntegrity"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestOperStatus"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestARHopTableIndex"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelBranchPerfErrors"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpGeneralGroup.setDescription("Collection of objects needed for MPLS P2MP.")
jnxMplsTeP2mpNotifGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1, 2)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestUp"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelDestDown"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpNotifGroup.setDescription("Notifications implemented in this module.")
jnxMplsTeP2mpScalarGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 1, 3)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelTotalMaxHops"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelActive"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpTunnelConfigured"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpScalarGroup.setDescription("Scalar objects needed to implement P2MP MPLS tunnels.")

# Compliances

jnxMplsTeP2mpModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 2, 1)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpNotifGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpGeneralGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpScalarGroup"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpModuleFullCompliance.setDescription("Compliance statement for agents that provide full support\nfor MPLS-TE-P2MP-STD-MIB. Such devices can be monitored and\nalso be configured using this MIB module.\nThe Module is implemented with support for read-create and\nread-write. In other words, both monitoring and\nconfiguration are available when using this\nMODULE-COMPLIANCE.")
jnxMplsTeP2mpModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 5, 7, 1, 3, 2, 2)).setObjects(*(("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpScalarGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpNotifGroup"), ("JNX-MPLS-TE-P2MP-STD-MIB", "jnxMplsTeP2mpGeneralGroup"), ) )
if mibBuilder.loadTexts: jnxMplsTeP2mpModuleReadOnlyCompliance.setDescription("Compliance statement for agents that provide read-only\nsupport for MPLS-TE-P2MP-STD-MIB. Such devices can only be\nmonitored using this MIB module.\nThe Module is implemented with support for read-only. In\nother words, only monitoring is available by implementing\nthis MODULE-COMPLIANCE.")

# Exports

# Module identity
mibBuilder.exportSymbols("JNX-MPLS-TE-P2MP-STD-MIB", PYSNMP_MODULE_ID=jnxMplsTeP2mpStdMIB)

# Objects
mibBuilder.exportSymbols("JNX-MPLS-TE-P2MP-STD-MIB", jnxMplsTeP2mpStdMIB=jnxMplsTeP2mpStdMIB, jnxMplsTeP2mpNotifications=jnxMplsTeP2mpNotifications, jnxMplsTeP2mpScalars=jnxMplsTeP2mpScalars, jnxMplsTeP2mpTunnelConfigured=jnxMplsTeP2mpTunnelConfigured, jnxMplsTeP2mpTunnelActive=jnxMplsTeP2mpTunnelActive, jnxMplsTeP2mpTunnelTotalMaxHops=jnxMplsTeP2mpTunnelTotalMaxHops, jnxMplsTeP2mpObjects=jnxMplsTeP2mpObjects, jnxMplsTeP2mpTunnelTable=jnxMplsTeP2mpTunnelTable, jnxMplsTeP2mpTunnelEntry=jnxMplsTeP2mpTunnelEntry, jnxMplsTeP2mpTunnelP2mpIntegrity=jnxMplsTeP2mpTunnelP2mpIntegrity, jnxMplsTeP2mpTunnelBranchRole=jnxMplsTeP2mpTunnelBranchRole, jnxMplsTeP2mpTunnelP2mpXcIndex=jnxMplsTeP2mpTunnelP2mpXcIndex, jnxMplsTeP2mpTunnelRowStatus=jnxMplsTeP2mpTunnelRowStatus, jnxMplsTeP2mpTunnelStorageType=jnxMplsTeP2mpTunnelStorageType, jnxMplsTeP2mpTunnelSubGroupIDNext=jnxMplsTeP2mpTunnelSubGroupIDNext, jnxMplsTeP2mpTunnelDestTable=jnxMplsTeP2mpTunnelDestTable, jnxMplsTeP2mpTunnelDestEntry=jnxMplsTeP2mpTunnelDestEntry, jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType=jnxMplsTeP2mpTunnelDestSrcSubGroupOriginType, jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin=jnxMplsTeP2mpTunnelDestSrcSubGroupOrigin, jnxMplsTeP2mpTunnelDestSrcSubGroupID=jnxMplsTeP2mpTunnelDestSrcSubGroupID, jnxMplsTeP2mpTunnelDestSubGroupOriginType=jnxMplsTeP2mpTunnelDestSubGroupOriginType, jnxMplsTeP2mpTunnelDestSubGroupOrigin=jnxMplsTeP2mpTunnelDestSubGroupOrigin, jnxMplsTeP2mpTunnelDestSubGroupID=jnxMplsTeP2mpTunnelDestSubGroupID, jnxMplsTeP2mpTunnelDestDestinationType=jnxMplsTeP2mpTunnelDestDestinationType, jnxMplsTeP2mpTunnelDestDestination=jnxMplsTeP2mpTunnelDestDestination, jnxMplsTeP2mpTunnelDestBranchOutSegment=jnxMplsTeP2mpTunnelDestBranchOutSegment, jnxMplsTeP2mpTunnelDestHopTableIndex=jnxMplsTeP2mpTunnelDestHopTableIndex, jnxMplsTeP2mpTunnelDestPathInUse=jnxMplsTeP2mpTunnelDestPathInUse, jnxMplsTeP2mpTunnelDestCHopTableIndex=jnxMplsTeP2mpTunnelDestCHopTableIndex, jnxMplsTeP2mpTunnelDestARHopTableIndex=jnxMplsTeP2mpTunnelDestARHopTableIndex, jnxMplsTeP2mpTunnelDestTotalUpTime=jnxMplsTeP2mpTunnelDestTotalUpTime, jnxMplsTeP2mpTunnelDestInstanceUpTime=jnxMplsTeP2mpTunnelDestInstanceUpTime, jnxMplsTeP2mpTunnelDestPathChanges=jnxMplsTeP2mpTunnelDestPathChanges, jnxMplsTeP2mpTunnelDestLastPathChange=jnxMplsTeP2mpTunnelDestLastPathChange, jnxMplsTeP2mpTunnelDestCreationTime=jnxMplsTeP2mpTunnelDestCreationTime, jnxMplsTeP2mpTunnelDestStateTransitions=jnxMplsTeP2mpTunnelDestStateTransitions, jnxMplsTeP2mpTunnelDestDiscontinuityTime=jnxMplsTeP2mpTunnelDestDiscontinuityTime, jnxMplsTeP2mpTunnelDestAdminStatus=jnxMplsTeP2mpTunnelDestAdminStatus, jnxMplsTeP2mpTunnelDestOperStatus=jnxMplsTeP2mpTunnelDestOperStatus, jnxMplsTeP2mpTunnelDestRowStatus=jnxMplsTeP2mpTunnelDestRowStatus, jnxMplsTeP2mpTunnelDestStorageType=jnxMplsTeP2mpTunnelDestStorageType, jnxMplsTeP2mpTunnelBranchPerfTable=jnxMplsTeP2mpTunnelBranchPerfTable, jnxMplsTeP2mpTunnelBranchPerfEntry=jnxMplsTeP2mpTunnelBranchPerfEntry, jnxMplsTeP2mpTunnelBranchPerfBranch=jnxMplsTeP2mpTunnelBranchPerfBranch, jnxMplsTeP2mpTunnelBranchPerfPackets=jnxMplsTeP2mpTunnelBranchPerfPackets, jnxMplsTeP2mpTunnelBranchPerfHCPackets=jnxMplsTeP2mpTunnelBranchPerfHCPackets, jnxMplsTeP2mpTunnelBranchPerfErrors=jnxMplsTeP2mpTunnelBranchPerfErrors, jnxMplsTeP2mpTunnelBranchPerfBytes=jnxMplsTeP2mpTunnelBranchPerfBytes, jnxMplsTeP2mpTunnelBranchPerfHCBytes=jnxMplsTeP2mpTunnelBranchPerfHCBytes, jnxMplsTeP2mpTunnelBranchDiscontinuityTime=jnxMplsTeP2mpTunnelBranchDiscontinuityTime, jnxMplsTeP2mpTunnelNotificationEnable=jnxMplsTeP2mpTunnelNotificationEnable, jnxMplsTeP2mpConformance=jnxMplsTeP2mpConformance, jnxMplsTeP2mpGroups=jnxMplsTeP2mpGroups, jnxMplsTeP2mpCompliances=jnxMplsTeP2mpCompliances)

# Notifications
mibBuilder.exportSymbols("JNX-MPLS-TE-P2MP-STD-MIB", jnxMplsTeP2mpTunnelDestUp=jnxMplsTeP2mpTunnelDestUp, jnxMplsTeP2mpTunnelDestDown=jnxMplsTeP2mpTunnelDestDown)

# Groups
mibBuilder.exportSymbols("JNX-MPLS-TE-P2MP-STD-MIB", jnxMplsTeP2mpGeneralGroup=jnxMplsTeP2mpGeneralGroup, jnxMplsTeP2mpNotifGroup=jnxMplsTeP2mpNotifGroup, jnxMplsTeP2mpScalarGroup=jnxMplsTeP2mpScalarGroup)

# Compliances
mibBuilder.exportSymbols("JNX-MPLS-TE-P2MP-STD-MIB", jnxMplsTeP2mpModuleFullCompliance=jnxMplsTeP2mpModuleFullCompliance, jnxMplsTeP2mpModuleReadOnlyCompliance=jnxMplsTeP2mpModuleReadOnlyCompliance)
