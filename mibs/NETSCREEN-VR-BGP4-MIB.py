# PySNMP SMI module. Autogenerated from smidump -f python NETSCREEN-VR-BGP4-MIB
# by libsmi2pysnmp-0.1.3 at Fri May 30 14:12:57 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( netscreenVR, ) = mibBuilder.importSymbols("NETSCREEN-SMI", "netscreenVR")
( netscreenTrapDesc, netscreenTrapType, ) = mibBuilder.importSymbols("NETSCREEN-TRAP-MIB", "netscreenTrapDesc", "netscreenTrapType")
( Bits, Counter32, Gauge32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")

# Objects

nsVrBgp = ModuleIdentity((1, 3, 6, 1, 4, 1, 3224, 18, 6)).setRevisions(("2005-06-20 20:22",))
if mibBuilder.loadTexts: nsVrBgp.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: nsVrBgp.setContactInfo("Customer Support\n\n1194 North Mathilda Avenue \nSunnyvale, California 94089-1206\nUSA\n\nTel: 1-800-638-8296\nE-mail: customerservice@juniper.net\nHTTP://www.juniper.net")
if mibBuilder.loadTexts: nsVrBgp.setDescription("The MIB module for NS-BGP-4.")
nsVrBgpInfoTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 6, 1))
if mibBuilder.loadTexts: nsVrBgpInfoTable.setDescription("BGP info table.  This table contains,\none entry per VR, information about\nthe BGP's Version, LocalAs and Identifier.")
nsVrBgpInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 6, 1, 1)).setIndexNames((0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgpInfoVRID"))
if mibBuilder.loadTexts: nsVrBgpInfoEntry.setDescription("Entry containing information about the\nBGP's Version, LocalAs and Identifier")
nsVrBgpInfoVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpInfoVersion.setDescription("Vector of supported BGP protocol version\nnumbers.  Each peer negotiates the version\nfrom this vector.  Versions are identified\nvia the string of bits contained within this\nobject.  The first octet contains bits 0 to\n7, the second octet contains bits 8 to 15,\nand so on, with the most significant bit\nreferring to the lowest bit number in the\noctet (e.g., the MSB of the first octet\nrefers to bit 0).  If a bit, i, is present\nand set, then the version (i+1) of the BGP\nis supported.")
nsVrBgpInfoLocalAs = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpInfoLocalAs.setDescription("The local autonomous system number.")
nsVrBgpInfoIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpInfoIdentifier.setDescription("The BGP Identifier of local system.")
nsVrBgpInfoVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpInfoVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrBgpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3))
if mibBuilder.loadTexts: nsVrBgpPeerTable.setDescription("BGP peer table.  This table contains,\none entry per BGP peer, information about\nthe connections with BGP peers.")
nsVrBgpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1)).setIndexNames((0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgpPeerVRID"), (0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgpPeerRemoteAddr"))
if mibBuilder.loadTexts: nsVrBgpPeerEntry.setDescription("Entry containing information about the\nconnection with a BGP peer.")
nsVrBgpPeerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerIdentifier.setDescription("The BGP Identifier of this entry's BGP\npeer.")
nsVrBgpPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(6,5,4,1,2,3,)).subtype(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerState.setDescription("The BGP peer connection state.")
nsVrBgpPeerAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("stop", 1), ("start", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerAdminStatus.setDescription("The desired state of the BGP connection.\nA transition from 'stop' to 'start' will\ncause the BGP Start Event to be generated.\n\nA transition from 'start' to 'stop' will\ncause the BGP Stop Event to be generated.\nThis parameter can be used to restart BGP\npeer connections.  Care should be used in\nproviding write access to this object\nwithout adequate authentication.")
nsVrBgpPeerNegotiatedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerNegotiatedVersion.setDescription("The negotiated version of BGP running\nbetween the two peers.")
nsVrBgpPeerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerLocalAddr.setDescription("The local IP address of this entry's BGP\nconnection.")
nsVrBgpPeerLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerLocalPort.setDescription("The local port for the TCP connection\nbetween the BGP peers.")
nsVrBgpPeerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerRemoteAddr.setDescription("The remote IP address of this entry's BGP\npeer.")
nsVrBgpPeerRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerRemotePort.setDescription("The remote port for the TCP connection\nbetween the BGP peers.  Note that the\nobjects nsVrBgpPeerLocalAddr,\nnsVrBgpPeerLocalPort, nsVrBgpPeerRemoteAddr and\nnsVrBgpPeerRemotePort provide the appropriate\nreference to the standard MIB TCP\nconnection table.")
nsVrBgpPeerRemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerRemoteAs.setDescription("The remote autonomous system number.")
nsVrBgpPeerInUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerInUpdates.setDescription("The number of BGP UPDATE messages\nreceived on this connection.  This object\nshould be initialized to zero (0) when the\nconnection is established.")
nsVrBgpPeerOutUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerOutUpdates.setDescription("The number of BGP UPDATE messages\ntransmitted on this connection.  This\nobject should be initialized to zero (0)\nwhen the connection is established.")
nsVrBgpPeerInTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerInTotalMessages.setDescription("The total number of messages received\nfrom the remote peer on this connection.\nThis object should be initialized to zero\n\nwhen the connection is established.")
nsVrBgpPeerOutTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerOutTotalMessages.setDescription("The total number of messages transmitted to\nthe remote peer on this connection.  This\nobject should be initialized to zero when\nthe connection is established.")
nsVrBgpPeerLastError = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerLastError.setDescription("The last error code and subcode seen by this\npeer on this connection.  If no error has\noccurred, this field is zero.  Otherwise, the\nfirst byte of this two byte OCTET STRING\ncontains the error code, and the second byte\ncontains the subcode.")
nsVrBgpPeerFsmEstablishedTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerFsmEstablishedTransitions.setDescription("The total number of times the BGP FSM\ntransitioned into the established state.")
nsVrBgpPeerFsmEstablishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerFsmEstablishedTime.setDescription("This timer indicates how long (in\nseconds) this peer has been in the\nEstablished state or how long\nsince this peer was last in the\nEstablished state.  It is set to zero when\na new peer is configured or the router is\nbooted.")
nsVrBgpPeerConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerConnectRetryInterval.setDescription("Time interval in seconds for the\nConnectRetry timer.  The suggested value\nfor this timer is 120 seconds.")
nsVrBgpPeerHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerHoldTime.setDescription("Time interval in seconds for the Hold\nTimer established with the peer.  The\nvalue of this object is calculated by this\nBGP speaker by using the smaller of the\nvalue in nsVrBgpPeerHoldTimeConfigured and the\nHold Time received in the OPEN message.\nThis value must be at lease three seconds\nif it is not zero (0) in which case the\nHold Timer has not been established with\nthe peer, or, the value of\nnsVrBgpPeerHoldTimeConfigured is zero (0).")
nsVrBgpPeerKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerKeepAlive.setDescription("Time interval in seconds for the KeepAlive\ntimer established with the peer.  The value\nof this object is calculated by this BGP\nspeaker such that, when compared with\nnsVrBgpPeerHoldTime, it has the same\nproportion as what\nnsVrBgpPeerKeepAliveConfigured has when\ncompared with nsVrBgpPeerHoldTimeConfigured.\nIf the value of this object is zero (0),\nit indicates that the KeepAlive timer has\nnot been established with the peer, or,\nthe value of nsVrBgpPeerKeepAliveConfigured is\nzero (0).")
nsVrBgpPeerHoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerHoldTimeConfigured.setDescription("Time interval in seconds for the Hold Time\nconfigured for this BGP speaker with this\npeer.  This value is placed in an OPEN\nmessage sent to this peer by this BGP\nspeaker, and is compared with the Hold\nTime field in an OPEN message received\nfrom the peer when determining the Hold\nTime (nsVrBgpPeerHoldTime) with the peer.\nThis value must not be less than three\nseconds if it is not zero (0) in which\ncase the Hold Time is NOT to be\nestablished with the peer.  The suggested\nvalue for this timer is 90 seconds.")
nsVrBgpPeerKeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerKeepAliveConfigured.setDescription("Time interval in seconds for the\nKeepAlive timer configured for this BGP\nspeaker with this peer.  The value of this\nobject will only determine the\nKEEPALIVE messages' frequency relative to\nthe value specified in\nnsVrBgpPeerHoldTimeConfigured; the actual\ntime interval for the KEEPALIVE messages\nis indicated by nsVrBgpPeerKeepAlive.  A\nreasonable maximum value for this timer\nwould be configured to be one\nthird of that of\nnsVrBgpPeerHoldTimeConfigured.\nIf the value of this object is zero (0),\nno periodical KEEPALIVE messages are sent\nto the peer after the BGP connection has\nbeen established.  The suggested value for\nthis timer is 30 seconds.")
nsVrBgpPeerMinASOriginationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerMinASOriginationInterval.setDescription("Time interval in seconds for the\nMinASOriginationInterval timer.\nThe suggested value for this timer is 15\nseconds.")
nsVrBgpPeerMinRouteAdvertisementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerMinRouteAdvertisementInterval.setDescription("Time interval in seconds for the\nMinRouteAdvertisementInterval timer.\nThe suggested value for this timer is 30\nseconds.")
nsVrBgpPeerInUpdateElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerInUpdateElapsedTime.setDescription("Elapsed time in seconds since the last BGP\nUPDATE message was received from the peer.\nEach time nsVrBgpPeerInUpdates is incremented,\nthe value of this object is set to zero\n(0).")
nsVrBgpPeerVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgpPeerVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrBgp4PathAttrTable = MibTable((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6))
if mibBuilder.loadTexts: nsVrBgp4PathAttrTable.setDescription("The BGP-4 Received Path Attribute Table\ncontains information about paths to\ndestination networks received from all\nBGP4 peers.")
nsVrBgp4PathAttrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1)).setIndexNames((0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgp4PathAttrVRID"), (0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgp4PathAttrIpAddrPrefix"), (0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgp4PathAttrIpAddrPrefixLen"), (0, "NETSCREEN-VR-BGP4-MIB", "nsVrBgp4PathAttrPeer"))
if mibBuilder.loadTexts: nsVrBgp4PathAttrEntry.setDescription("Information about a path to a network.")
nsVrBgp4PathAttrPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrPeer.setDescription("The IP address of the peer where the path\ninformation was learned.")
nsVrBgp4PathAttrIpAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrIpAddrPrefixLen.setDescription("Length in bits of the IP address prefix\nin the Network Layer Reachability\nInformation field.")
nsVrBgp4PathAttrIpAddrPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrIpAddrPrefix.setDescription("An IP address prefix in the Network Layer\nReachability Information field.  This object\n\nis an IP address containing the prefix with\nlength specified by\nnsVrBgp4PathAttrIpAddrPrefixLen.\nAny bits beyond the length specified by\nnsVrBgp4PathAttrIpAddrPrefixLen are zeroed.")
nsVrBgp4PathAttrOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrOrigin.setDescription("The ultimate origin of the path\ninformation.")
nsVrBgp4PathAttrASPathSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrASPathSegment.setDescription("The sequence of AS path segments.  Each AS\npath segment is represented by a triple\n<type, length, value>.\n\nThe type is a 1-octet field which has two\npossible values:\n     1      AS_SET: unordered set of ASs a\n                 route in the UPDATE\n                 message has traversed\n     2      AS_SEQUENCE: ordered set of ASs\n                 a route in the UPDATE\n                 message has traversed.\n\nThe length is a 1-octet field containing the\nnumber of ASs in the value field.\n\nThe value field contains one or more AS\nnumbers, each AS is represented in the octet\nstring as a pair of octets according to the\nfollowing algorithm:\n\n    first-byte-of-pair = ASNumber / 256;\n    second-byte-of-pair = ASNumber & 255;")
nsVrBgp4PathAttrNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrNextHop.setDescription("The address of the border router that\nshould be used for the destination\nnetwork.")
nsVrBgp4PathAttrMultiExitDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrMultiExitDisc.setDescription("This metric is used to discriminate\nbetween multiple exit points to an\nadjacent autonomous system.  A value of -1\nindicates the absence of this attribute.")
nsVrBgp4PathAttrLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrLocalPref.setDescription("The originating BGP4 speaker's degree of\npreference for an advertised route.  A\nvalue of -1 indicates the absence of this\nattribute.")
nsVrBgp4PathAttrAtomicAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("lessSpecificRrouteNotSelected", 1), ("lessSpecificRouteSelected", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrAtomicAggregate.setDescription("Whether or not the local system has\nselected a less specific route without\nselecting a more specific route.")
nsVrBgp4PathAttrAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrAggregatorAS.setDescription("The AS number of the last BGP4 speaker that\nperformed route aggregation.  A value of\nzero (0) indicates the absence of this\nattribute.")
nsVrBgp4PathAttrAggregatorAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrAggregatorAddr.setDescription("The IP address of the last BGP4 speaker\nthat performed route aggregation.  A value\nof 0.0.0.0 indicates the absence of this\nattribute.")
nsVrBgp4PathAttrCalcLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrCalcLocalPref.setDescription("The degree of preference calculated by the\nreceiving BGP4 speaker for an advertised\nroute.  A value of -1 indicates the\nabsence of this attribute.")
nsVrBgp4PathAttrBest = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("false", 1), ("true", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrBest.setDescription("An indication of whether or not this route\nwas chosen as the best BGP4 route.")
nsVrBgp4PathAttrUnknown = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrUnknown.setDescription("One or more path attributes not understood\nby this BGP4 speaker.  Size zero (0)\nindicates the absence of such\nattribute(s).  Octets beyond the maximum\nsize, if any, are not recorded by this\nobject.")
nsVrBgp4PathAttrVRID = MibTableColumn((1, 3, 6, 1, 4, 1, 3224, 18, 6, 6, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsVrBgp4PathAttrVRID.setDescription("Virtual Router ID. VRID range for system created \nVRs: [1-1024] and for user created VRs: [1025-2048]")
nsVrBgpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 3224, 18, 6, 7))

# Augmentions

# Notifications

nsVrBgpEstablished = NotificationType((1, 3, 6, 1, 4, 1, 3224, 18, 6, 7, 1)).setObjects(*(("NETSCREEN-VR-BGP4-MIB", "nsVrBgpPeerIdentifier"), ("NETSCREEN-TRAP-MIB", "netscreenTrapType"), ("NETSCREEN-TRAP-MIB", "netscreenTrapDesc"), ("NETSCREEN-VR-BGP4-MIB", "nsVrBgp4PathAttrVRID"), ("NETSCREEN-VR-BGP4-MIB", "nsVrBgpPeerLastError"), ("NETSCREEN-VR-BGP4-MIB", "nsVrBgpPeerState"), ) )
if mibBuilder.loadTexts: nsVrBgpEstablished.setDescription("The BGP Established event is generated when\nthe BGP FSM enters the ESTABLISHED state.")

# Exports

# Module identity
mibBuilder.exportSymbols("NETSCREEN-VR-BGP4-MIB", PYSNMP_MODULE_ID=nsVrBgp)

# Objects
mibBuilder.exportSymbols("NETSCREEN-VR-BGP4-MIB", nsVrBgp=nsVrBgp, nsVrBgpInfoTable=nsVrBgpInfoTable, nsVrBgpInfoEntry=nsVrBgpInfoEntry, nsVrBgpInfoVersion=nsVrBgpInfoVersion, nsVrBgpInfoLocalAs=nsVrBgpInfoLocalAs, nsVrBgpInfoIdentifier=nsVrBgpInfoIdentifier, nsVrBgpInfoVRID=nsVrBgpInfoVRID, nsVrBgpPeerTable=nsVrBgpPeerTable, nsVrBgpPeerEntry=nsVrBgpPeerEntry, nsVrBgpPeerIdentifier=nsVrBgpPeerIdentifier, nsVrBgpPeerState=nsVrBgpPeerState, nsVrBgpPeerAdminStatus=nsVrBgpPeerAdminStatus, nsVrBgpPeerNegotiatedVersion=nsVrBgpPeerNegotiatedVersion, nsVrBgpPeerLocalAddr=nsVrBgpPeerLocalAddr, nsVrBgpPeerLocalPort=nsVrBgpPeerLocalPort, nsVrBgpPeerRemoteAddr=nsVrBgpPeerRemoteAddr, nsVrBgpPeerRemotePort=nsVrBgpPeerRemotePort, nsVrBgpPeerRemoteAs=nsVrBgpPeerRemoteAs, nsVrBgpPeerInUpdates=nsVrBgpPeerInUpdates, nsVrBgpPeerOutUpdates=nsVrBgpPeerOutUpdates, nsVrBgpPeerInTotalMessages=nsVrBgpPeerInTotalMessages, nsVrBgpPeerOutTotalMessages=nsVrBgpPeerOutTotalMessages, nsVrBgpPeerLastError=nsVrBgpPeerLastError, nsVrBgpPeerFsmEstablishedTransitions=nsVrBgpPeerFsmEstablishedTransitions, nsVrBgpPeerFsmEstablishedTime=nsVrBgpPeerFsmEstablishedTime, nsVrBgpPeerConnectRetryInterval=nsVrBgpPeerConnectRetryInterval, nsVrBgpPeerHoldTime=nsVrBgpPeerHoldTime, nsVrBgpPeerKeepAlive=nsVrBgpPeerKeepAlive, nsVrBgpPeerHoldTimeConfigured=nsVrBgpPeerHoldTimeConfigured, nsVrBgpPeerKeepAliveConfigured=nsVrBgpPeerKeepAliveConfigured, nsVrBgpPeerMinASOriginationInterval=nsVrBgpPeerMinASOriginationInterval, nsVrBgpPeerMinRouteAdvertisementInterval=nsVrBgpPeerMinRouteAdvertisementInterval, nsVrBgpPeerInUpdateElapsedTime=nsVrBgpPeerInUpdateElapsedTime, nsVrBgpPeerVRID=nsVrBgpPeerVRID, nsVrBgp4PathAttrTable=nsVrBgp4PathAttrTable, nsVrBgp4PathAttrEntry=nsVrBgp4PathAttrEntry, nsVrBgp4PathAttrPeer=nsVrBgp4PathAttrPeer, nsVrBgp4PathAttrIpAddrPrefixLen=nsVrBgp4PathAttrIpAddrPrefixLen, nsVrBgp4PathAttrIpAddrPrefix=nsVrBgp4PathAttrIpAddrPrefix, nsVrBgp4PathAttrOrigin=nsVrBgp4PathAttrOrigin, nsVrBgp4PathAttrASPathSegment=nsVrBgp4PathAttrASPathSegment, nsVrBgp4PathAttrNextHop=nsVrBgp4PathAttrNextHop, nsVrBgp4PathAttrMultiExitDisc=nsVrBgp4PathAttrMultiExitDisc, nsVrBgp4PathAttrLocalPref=nsVrBgp4PathAttrLocalPref, nsVrBgp4PathAttrAtomicAggregate=nsVrBgp4PathAttrAtomicAggregate, nsVrBgp4PathAttrAggregatorAS=nsVrBgp4PathAttrAggregatorAS, nsVrBgp4PathAttrAggregatorAddr=nsVrBgp4PathAttrAggregatorAddr, nsVrBgp4PathAttrCalcLocalPref=nsVrBgp4PathAttrCalcLocalPref, nsVrBgp4PathAttrBest=nsVrBgp4PathAttrBest, nsVrBgp4PathAttrUnknown=nsVrBgp4PathAttrUnknown, nsVrBgp4PathAttrVRID=nsVrBgp4PathAttrVRID, nsVrBgpTraps=nsVrBgpTraps)

# Notifications
mibBuilder.exportSymbols("NETSCREEN-VR-BGP4-MIB", nsVrBgpEstablished=nsVrBgpEstablished)

