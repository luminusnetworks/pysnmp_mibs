# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-IPSEC-FLOW-MON-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:50 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( jnxIpSecMibRoot, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxIpSecMibRoot")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( DisplayString, TextualConvention, TimeInterval, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeInterval")

# Types

class JnxAuthAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,0,3,1,)
    namedValues = NamedValues(("unknown", 0), ("hmacMd5", 1), ("hmacSha", 2), ("hmacSha256", 3), )
    
class JnxDiffHellmanGrp(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(5,0,1,2,)
    namedValues = NamedValues(("unknown", 0), ("modp768", 1), ("modp1024", 2), ("modp1536", 5), )
    
class JnxEncapMode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,0,2,)
    namedValues = NamedValues(("unknown", 0), ("tunnel", 1), ("transport", 2), )
    
class JnxEncryptAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,3,4,6,5,2,)
    namedValues = NamedValues(("espDes", 1), ("esp3des", 2), ("espNull", 3), ("espAes128", 4), ("espAes192", 5), ("espAes256", 6), )
    
class JnxIkeAuthMethod(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,5,10,8,3,6,4,9,7,2,)
    namedValues = NamedValues(("preSharedKey", 1), ("xauthRevRsaEncryption", 10), ("dssSignature", 2), ("rsaSignature", 3), ("rsaEncryption", 4), ("revRsaEncryption", 5), ("xauthPreSharedKey", 6), ("xauthDssSignature", 7), ("xauthRsaSignature", 8), ("xauthRsaEncryption", 9), )
    
class JnxIkeHashAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,3,1,)
    namedValues = NamedValues(("md5", 1), ("sha", 2), ("sha256", 3), )
    
class JnxIkeNegoMode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("main", 1), ("aggressive", 2), )
    
class JnxIkePeerRole(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("initiator", 1), ("responder", 2), )
    
class JnxIkePeerType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,2,4,0,1,)
    namedValues = NamedValues(("unknown", 0), ("idIpv4Addr", 1), ("idFqdn", 2), ("idDn", 3), ("idUfqdn", 4), )
    
class JnxIkeTunStateType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("up", 1), ("down", 2), )
    
class JnxKeyType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,2,1,)
    namedValues = NamedValues(("unknown", 0), ("keyIke", 1), ("keyManual", 2), )
    
class JnxRemotePeerType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,2,1,)
    namedValues = NamedValues(("unknown", 0), ("static", 1), ("dynamic", 2), )
    
class JnxSAType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,1,2,)
    namedValues = NamedValues(("unknown", 0), ("manual", 1), ("dynamic", 2), )
    
class JnxSpiType(Unsigned32):
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(256,4294967295)
    

# Objects

jnxIpSecFlowMonMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1)).setRevisions(("2007-05-16 00:00","2007-05-11 21:53",))
if mibBuilder.loadTexts: jnxIpSecFlowMonMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxIpSecFlowMonMIB.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxIpSecFlowMonMIB.setDescription("This module defines the object used to monitor the\nentries pertaining to IPSec objects and the management\nof the IPSEC VPN functionalities.  \ntables:\n - IKE tunnel table\n - IPSec tunnel table\n - IPSec security associations table.\n\nThis mib module is based on JNX-IPSEC-MONITOR-MIB. \nBuilding on the existing IKE infrastruature, the  \nsecurity IKE implementation integrates the value-added \nfeatures for the security products")
jnxIpSecFlowMonNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 0))
jnxIpSecFlowMonPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1))
jnxIkeNumOfTunnels = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeNumOfTunnels.setDescription("Number of IKE Tunnels (phase-1) actively negotiating between\npeers.  The SA can be in either the up or down state.  \nThis attribute should detail the number of IKE tunnels \nin jnxIkeTunnelMonTable.")
jnxIkeTunnelMonTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2))
if mibBuilder.loadTexts: jnxIkeTunnelMonTable.setDescription("The IPsec Phase-1 Internet Key Exchange Tunnel Table.\nThere is one entry in this table for each active IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunnelMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1)).setIndexNames((0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIkeTunMonRemoteGwAddrType"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIkeTunMonRemoteGwAddr"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIkeTunMonIndex"))
if mibBuilder.loadTexts: jnxIkeTunnelMonEntry.setDescription("Each entry contains the attributes associated with\nan active IPsec Phase-1 IKE Tunnel.")
jnxIkeTunMonRemoteGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIkeTunMonRemoteGwAddrType.setDescription("The IP address type of the remote gateway (endpoint) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunMonRemoteGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIkeTunMonRemoteGwAddr.setDescription("The IP address of the remote gateway (endpoint) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIkeTunMonIndex.setDescription("The index of the IPsec Phase-1 IKE Tunnel Table.\nThe value of the index is a number which begins\nat one and is incremented with each tunnel that\nis created. The value of this object will\nwrap at 2,147,483,647.")
jnxIkeTunMonLocalGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLocalGwAddr.setDescription("The IP address of the local endpoint (gateway) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunMonLocalGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLocalGwAddrType.setDescription("The IP address type of the local endpoint (gateway) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunMonState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 6), JnxIkeTunStateType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonState.setDescription("The state of the IKE tunnel, It can be: \n1. up - negotiation completed\n2. down- being negotiated")
jnxIkeTunMonInitiatorCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonInitiatorCookie.setDescription("Cookie as generated by the peer that initiated the IKE Phase-1\nnegotiation. This cookie is carried in the ISAKMP header.")
jnxIkeTunMonResponderCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonResponderCookie.setDescription("Cookie as generated by the peer responding to the IKE Phase-1\nnegotiation initiated by the remote peer. This cookie is carried\nin the ISAKMP header.")
jnxIkeTunMonLocalRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 9), JnxIkePeerRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLocalRole.setDescription("The role of local peer identity.  The Role of the local peer can be:\n1. initiator.\n2. or responder.")
jnxIkeTunMonLocalIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 10), JnxIkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLocalIdType.setDescription("The type of local peer identity.  The local\npeer may be identified by:\n 1. an IP address, or\n 2. or a fully qualified domain name string.\n 3. or a distinguished name string.")
jnxIkeTunMonLocalIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLocalIdValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is id_fqdn, then this is\nthe FQDN of the remote peer.\n\nIf the local peer type is a id_dn, then this is\nthe distinguished name string of the local peer.")
jnxIkeTunMonLocalCertName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLocalCertName.setDescription("Name of the certificate used for authentication of the local\ntunnel endpoint. This object will have some valid value only\nif negotiated IKE authentication method is other than pre-saherd\nkey. If the IKE negotiation do not use certificate based\nauthentication method, then the value of this object will be a\nNULL string.")
jnxIkeTunMonRemoteIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 13), JnxIkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonRemoteIdType.setDescription("The type of remote peer identity.\nThe remote peer may be identified by:\n 1. an IP address, or\n 2. or a fully qualified domain name string.\n 3. or a distinguished name string.")
jnxIkeTunMonRemoteIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonRemoteIdValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is id_fqdn, then this is\nthe FQDN of the remote peer.\n\nIf the remote peer type is a id_dn, then this is\nthe distinguished named string of the remote peer.")
jnxIkeTunMonNegoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 15), JnxIkeNegoMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonNegoMode.setDescription("The negotiation mode of the IPsec Phase-1 IKE Tunnel.")
jnxIkeTunMonDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 16), JnxDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonDiffHellmanGrp.setDescription("The Diffie Hellman Group used in IPsec Phase-1 IKE\nnegotiations.")
jnxIkeTunMonEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 17), JnxEncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonEncryptAlgo.setDescription("The encryption algorithm used in IPsec Phase-1 IKE negotiations.")
jnxIkeTunMonHashAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 18), JnxIkeHashAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonHashAlgo.setDescription("The hash algorithm used in IPsec Phase-1 IKE negotiations.")
jnxIkeTunMonAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 19), JnxIkeAuthMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonAuthMethod.setDescription("The authentication method used in IPsec Phase-1 IKE\nnegotiations.")
jnxIkeTunMonLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-1 IKE Tunnel\nin seconds.")
jnxIkeTunMonActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 21), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonActiveTime.setDescription("The length of time the IPsec Phase-1 IKE tunnel has been\nactive in hundredths of seconds.")
jnxIkeTunMonInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonInOctets.setDescription("The total number of octets received by this IPsec Phase-1 \nIKE security association.")
jnxIkeTunMonInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonInPkts.setDescription("The total number of packets received by this IPsec Phase-1 \nIKE security association.")
jnxIkeTunMonOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonOutOctets.setDescription("The total number of octets sent by this IPsec Phase-1\nIKE security association.")
jnxIkeTunMonOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonOutPkts.setDescription("The total number of packets sent by this IPsec Phase-1\nIKE security association.")
jnxIkeTunMonXAuthUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 26), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonXAuthUserId.setDescription("The extended Authentication (XAuth) User Identifier, identifies the \nuser associated with this IPSec Phase negotiation.")
jnxIkeTunMonDPDDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 1, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunMonDPDDownCount.setDescription("The number of times that the remote peer is detected \nin a dead (or down) state. This attribute is obsolete")
jnxIpSecFlowMonPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2))
jnxIpSecNumOfTunnels = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecNumOfTunnels.setDescription("Number of IPSEC VPN Tunnels.   \nThis attribute should detail the number of IPSEC VPN tunnel\nin jnxIpSecTunnelTable.")
jnxIpSecTunnelMonTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2))
if mibBuilder.loadTexts: jnxIpSecTunnelMonTable.setDescription("The IPsec Phase-2 Tunnel Table.\nThere is one entry in this table for each active IPsec Phase-2 \nTunnel.  If the tunnel is terminated, then the entry is no longer \navailable after the table has been refreshed. ")
jnxIpSecTunnelMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1)).setIndexNames((0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecTunMonRemoteGwAddrType"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecTunMonRemoteGwAddr"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecTunMonIndex"))
if mibBuilder.loadTexts: jnxIpSecTunnelMonEntry.setDescription("Each entry contains the attributes\nassociated with an active IPsec Phase-2 Tunnel.")
jnxIpSecTunMonRemoteGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecTunMonRemoteGwAddrType.setDescription("The IP address type of the remote gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunMonRemoteGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecTunMonRemoteGwAddr.setDescription("The IP address of the remote gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecTunMonIndex.setDescription("The index of the IPsec Phase-2 Tunnel Table.\nThe value of the index is a number which begins at one and \n     is incremented with each tunnel that is created. The value of \n     this object will wrap at 2,147,483,647.")
jnxIpSecTunMonLocalGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonLocalGwAddrType.setDescription("The IP address type of the local gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunMonLocalGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonLocalGwAddr.setDescription("The IP address of the local gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunMonLocalProxyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonLocalProxyId.setDescription("Identifier for the local end.")
jnxIpSecTunMonRemoteProxyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonRemoteProxyId.setDescription("Identifier for the remote end.")
jnxIpSecTunMonKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 8), JnxKeyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonKeyType.setDescription("The type of key used by the IPsec Phase-2 Tunnel. It can be\none of the following two types:\n  - IKE negotiated\n  - Manually installed")
jnxIpSecTunMonRemotePeerType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 9), JnxRemotePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonRemotePeerType.setDescription("The type of the remote peer gateway (endpoint). It can be one\nof the following two types:\n  - static (Remote peer whose IP address is known beforehand)\n  - dynamic (Remote peer whose IP address is not known\n             beforehand)")
jnxIpSecTunMonOutEncryptedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonOutEncryptedBytes.setDescription("Number of bytes encrypted by this Phase-2 tunnel.")
jnxIpSecTunMonOutEncryptedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonOutEncryptedPkts.setDescription("Number of packets encrypted by this Phase-2 tunnel.")
jnxIpSecTunMonInDecryptedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonInDecryptedBytes.setDescription("Number of bytes decrypted by this Phase-2 tunnel.")
jnxIpSecTunMonInDecryptedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonInDecryptedPkts.setDescription("Number of packets decrypted by this Phase-2 tunnel.")
jnxIpSecTunMonAHInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonAHInBytes.setDescription("Number of incoming bytes authenticated using AH by this Phase-2\ntunnel.")
jnxIpSecTunMonAHInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonAHInPkts.setDescription("Number of incoming packets authenticated using AH by this Phase-2\ntunnel.")
jnxIpSecTunMonAHOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonAHOutBytes.setDescription("Number of outgoing bytes applied AH by this Phase-2 tunnel.")
jnxIpSecTunMonAHOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonAHOutPkts.setDescription("Number of outgoing packets applied AH by this Phase-2 tunnel.")
jnxIpSecTunMonReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonReplayDropPkts.setDescription("Number of packets dropped by this Phase-2 tunnel due to\nanti replay check failure.")
jnxIpSecTunMonAhAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonAhAuthFails.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed AH authentication.")
jnxIpSecTunMonEspAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonEspAuthFails.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed ESP authentication.")
jnxIpSecTunMonDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonDecryptFails.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed decryption.")
jnxIpSecTunMonBadHeaders = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonBadHeaders.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed due to bad headers.")
jnxIpSecTunMonBadTrailers = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonBadTrailers.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed due to bad ESP trailers.")
jnxIpSecTunMonDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 2, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMonDroppedPkts.setDescription("Total number of dropped packets for this Phase-2 tunnel. \nThis attribute is obsolete.")
jnxIpSecSaMonTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3))
if mibBuilder.loadTexts: jnxIpSecSaMonTable.setDescription("The IPsec Phase-2 Security Association Table.\nThis table identifies the structure (in terms of\ncomponent SAs) of each active Phase-2 IPsec tunnel.\nThis table contains an entry for each active and\nexpiring security association and maps each entry\nin the active Phase-2 tunnel table (ipSecTunTable)\ninto a number of entries in this table. \n\nSA contains the information negotiated by IKE. The SA \nis like a contract laying out the rules of the VPN \nconnection for the duration of the SA. An SA is assigned \na 32-bit number that, when used in conjunction with the \ndestination IP address, uniquely identifies the SA. This \nnumber is called the Security Parameters Index or SPI.\n\nIPSec SAs area unidirectional and they are unique in \neach security protocol. A set of SAs are needed for a \nprotected data pipe, one per direction per protocol.  ")
jnxIpSecSaMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1)).setIndexNames((0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecTunMonRemoteGwAddrType"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecTunMonRemoteGwAddr"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecTunMonIndex"), (0, "JUNIPER-IPSEC-FLOW-MON-MIB", "jnxIpSecSaMonIndex"))
if mibBuilder.loadTexts: jnxIpSecSaMonEntry.setDescription("Each entry contains the attributes associated with\nactive and expiring IPsec Phase-2\nsecurity associations.")
jnxIpSecSaMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecSaMonIndex.setDescription("The index, in the context of the IPsec tunnel ipSecTunIndex,\nof the security association represented by this table entry.\nThe value of this index is a number which begins at one and\nis incremented with each SPI associated with an IPsec Phase-2\nTunnel.  The value of this object will wrap at 65535.")
jnxIpSecSaMonProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("ah", 1), ("esp", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonProtocol.setDescription("The index, represents the security protocol (AH, ESP or\nIPComp) for which this security association was setup.")
jnxIpSecSaMonInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 3), JnxSpiType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonInSpi.setDescription("The value of the incoming SPI.")
jnxIpSecSaMonOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 4), JnxSpiType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonOutSpi.setDescription("The value of the outgoing SPI.")
jnxIpSecSaMonType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 5), JnxSAType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonType.setDescription("This field represents the type of security associations \nwhich can be either manual or dynamic")
jnxIpSecSaMonEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 6), JnxEncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonEncapMode.setDescription("The encapsulation mode used by an IPsec Phase-2 Tunnel. ")
jnxIpSecSaMonLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonLifeSize.setDescription("The negotiated LifeSize of the IPsec Phase-2 Tunnel in kilobytes. ")
jnxIpSecSaMonLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-2 Tunnel in seconds. ")
jnxIpSecSaMonActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 9), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonActiveTime.setDescription("The length of time the IPsec Phase-2 Tunnel has been active in \nhundredths of seconds. ")
jnxIpSecSaMonLifeSizeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonLifeSizeThreshold.setDescription("The security association LifeSize refresh threshold in kilobytes. ")
jnxIpSecSaMonLifeTimeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonLifeTimeThreshold.setDescription("The security association LifeTime refresh threshold in seconds. ")
jnxIpSecSaMonEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 12), JnxEncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonEncryptAlgo.setDescription("The Encryption algorithm used to encrypt \nthe packets which can be either es-cbc or 3des-cbc. ")
jnxIpSecSaMonAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 13), JnxAuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonAuthAlgo.setDescription("The algorithm used for authentication of packets which\ncan be hmac-md5-96 or hmac-sha1-96 or hmac-sha-256-128")
jnxIpSecSaMonState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 52, 1, 2, 3, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,2,)).subtype(namedValues=NamedValues(("unknown", 0), ("active", 1), ("expiring", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaMonState.setDescription("This column represents the status of the security association\nrepresented by this table entry. If the status of the SA is\n'active', the SA is ready for active use. The status\n'expiring' represents any of the various states that the\nsecurity association transitions through before being purged.")

# Augmentions

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-IPSEC-FLOW-MON-MIB", PYSNMP_MODULE_ID=jnxIpSecFlowMonMIB)

# Types
mibBuilder.exportSymbols("JUNIPER-IPSEC-FLOW-MON-MIB", JnxAuthAlgo=JnxAuthAlgo, JnxDiffHellmanGrp=JnxDiffHellmanGrp, JnxEncapMode=JnxEncapMode, JnxEncryptAlgo=JnxEncryptAlgo, JnxIkeAuthMethod=JnxIkeAuthMethod, JnxIkeHashAlgo=JnxIkeHashAlgo, JnxIkeNegoMode=JnxIkeNegoMode, JnxIkePeerRole=JnxIkePeerRole, JnxIkePeerType=JnxIkePeerType, JnxIkeTunStateType=JnxIkeTunStateType, JnxKeyType=JnxKeyType, JnxRemotePeerType=JnxRemotePeerType, JnxSAType=JnxSAType, JnxSpiType=JnxSpiType)

# Objects
mibBuilder.exportSymbols("JUNIPER-IPSEC-FLOW-MON-MIB", jnxIpSecFlowMonMIB=jnxIpSecFlowMonMIB, jnxIpSecFlowMonNotifications=jnxIpSecFlowMonNotifications, jnxIpSecFlowMonPhaseOne=jnxIpSecFlowMonPhaseOne, jnxIkeNumOfTunnels=jnxIkeNumOfTunnels, jnxIkeTunnelMonTable=jnxIkeTunnelMonTable, jnxIkeTunnelMonEntry=jnxIkeTunnelMonEntry, jnxIkeTunMonRemoteGwAddrType=jnxIkeTunMonRemoteGwAddrType, jnxIkeTunMonRemoteGwAddr=jnxIkeTunMonRemoteGwAddr, jnxIkeTunMonIndex=jnxIkeTunMonIndex, jnxIkeTunMonLocalGwAddr=jnxIkeTunMonLocalGwAddr, jnxIkeTunMonLocalGwAddrType=jnxIkeTunMonLocalGwAddrType, jnxIkeTunMonState=jnxIkeTunMonState, jnxIkeTunMonInitiatorCookie=jnxIkeTunMonInitiatorCookie, jnxIkeTunMonResponderCookie=jnxIkeTunMonResponderCookie, jnxIkeTunMonLocalRole=jnxIkeTunMonLocalRole, jnxIkeTunMonLocalIdType=jnxIkeTunMonLocalIdType, jnxIkeTunMonLocalIdValue=jnxIkeTunMonLocalIdValue, jnxIkeTunMonLocalCertName=jnxIkeTunMonLocalCertName, jnxIkeTunMonRemoteIdType=jnxIkeTunMonRemoteIdType, jnxIkeTunMonRemoteIdValue=jnxIkeTunMonRemoteIdValue, jnxIkeTunMonNegoMode=jnxIkeTunMonNegoMode, jnxIkeTunMonDiffHellmanGrp=jnxIkeTunMonDiffHellmanGrp, jnxIkeTunMonEncryptAlgo=jnxIkeTunMonEncryptAlgo, jnxIkeTunMonHashAlgo=jnxIkeTunMonHashAlgo, jnxIkeTunMonAuthMethod=jnxIkeTunMonAuthMethod, jnxIkeTunMonLifeTime=jnxIkeTunMonLifeTime, jnxIkeTunMonActiveTime=jnxIkeTunMonActiveTime, jnxIkeTunMonInOctets=jnxIkeTunMonInOctets, jnxIkeTunMonInPkts=jnxIkeTunMonInPkts, jnxIkeTunMonOutOctets=jnxIkeTunMonOutOctets, jnxIkeTunMonOutPkts=jnxIkeTunMonOutPkts, jnxIkeTunMonXAuthUserId=jnxIkeTunMonXAuthUserId, jnxIkeTunMonDPDDownCount=jnxIkeTunMonDPDDownCount, jnxIpSecFlowMonPhaseTwo=jnxIpSecFlowMonPhaseTwo, jnxIpSecNumOfTunnels=jnxIpSecNumOfTunnels, jnxIpSecTunnelMonTable=jnxIpSecTunnelMonTable, jnxIpSecTunnelMonEntry=jnxIpSecTunnelMonEntry, jnxIpSecTunMonRemoteGwAddrType=jnxIpSecTunMonRemoteGwAddrType, jnxIpSecTunMonRemoteGwAddr=jnxIpSecTunMonRemoteGwAddr, jnxIpSecTunMonIndex=jnxIpSecTunMonIndex, jnxIpSecTunMonLocalGwAddrType=jnxIpSecTunMonLocalGwAddrType, jnxIpSecTunMonLocalGwAddr=jnxIpSecTunMonLocalGwAddr, jnxIpSecTunMonLocalProxyId=jnxIpSecTunMonLocalProxyId, jnxIpSecTunMonRemoteProxyId=jnxIpSecTunMonRemoteProxyId, jnxIpSecTunMonKeyType=jnxIpSecTunMonKeyType, jnxIpSecTunMonRemotePeerType=jnxIpSecTunMonRemotePeerType, jnxIpSecTunMonOutEncryptedBytes=jnxIpSecTunMonOutEncryptedBytes, jnxIpSecTunMonOutEncryptedPkts=jnxIpSecTunMonOutEncryptedPkts, jnxIpSecTunMonInDecryptedBytes=jnxIpSecTunMonInDecryptedBytes, jnxIpSecTunMonInDecryptedPkts=jnxIpSecTunMonInDecryptedPkts, jnxIpSecTunMonAHInBytes=jnxIpSecTunMonAHInBytes, jnxIpSecTunMonAHInPkts=jnxIpSecTunMonAHInPkts, jnxIpSecTunMonAHOutBytes=jnxIpSecTunMonAHOutBytes, jnxIpSecTunMonAHOutPkts=jnxIpSecTunMonAHOutPkts, jnxIpSecTunMonReplayDropPkts=jnxIpSecTunMonReplayDropPkts, jnxIpSecTunMonAhAuthFails=jnxIpSecTunMonAhAuthFails, jnxIpSecTunMonEspAuthFails=jnxIpSecTunMonEspAuthFails, jnxIpSecTunMonDecryptFails=jnxIpSecTunMonDecryptFails, jnxIpSecTunMonBadHeaders=jnxIpSecTunMonBadHeaders, jnxIpSecTunMonBadTrailers=jnxIpSecTunMonBadTrailers, jnxIpSecTunMonDroppedPkts=jnxIpSecTunMonDroppedPkts, jnxIpSecSaMonTable=jnxIpSecSaMonTable, jnxIpSecSaMonEntry=jnxIpSecSaMonEntry, jnxIpSecSaMonIndex=jnxIpSecSaMonIndex, jnxIpSecSaMonProtocol=jnxIpSecSaMonProtocol, jnxIpSecSaMonInSpi=jnxIpSecSaMonInSpi, jnxIpSecSaMonOutSpi=jnxIpSecSaMonOutSpi, jnxIpSecSaMonType=jnxIpSecSaMonType, jnxIpSecSaMonEncapMode=jnxIpSecSaMonEncapMode, jnxIpSecSaMonLifeSize=jnxIpSecSaMonLifeSize, jnxIpSecSaMonLifeTime=jnxIpSecSaMonLifeTime, jnxIpSecSaMonActiveTime=jnxIpSecSaMonActiveTime, jnxIpSecSaMonLifeSizeThreshold=jnxIpSecSaMonLifeSizeThreshold, jnxIpSecSaMonLifeTimeThreshold=jnxIpSecSaMonLifeTimeThreshold, jnxIpSecSaMonEncryptAlgo=jnxIpSecSaMonEncryptAlgo, jnxIpSecSaMonAuthAlgo=jnxIpSecSaMonAuthAlgo, jnxIpSecSaMonState=jnxIpSecSaMonState)

