# PySNMP SMI module. Autogenerated from smidump -f python VPLS-GENERIC-DRAFT-01-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:57 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( jnxExperiment, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxExperiment")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, transmission, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "transmission")
( RowStatus, StorageType, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TextualConvention", "TruthValue")
( VPNIdOrZero, ) = mibBuilder.importSymbols("VPN-TC-STD-MIB", "VPNIdOrZero")

# Types

class JnxVplsBgpRouteDistinguisher(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,256)
    
class JnxVplsBgpRouteTarget(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,256)
    
class JnxVplsBgpRouteTargetType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,2,1,)
    namedValues = NamedValues(("import", 1), ("export", 2), ("both", 3), )
    
class PwIndexType(Unsigned32):
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(1,4294967295)
    

# Objects

jnxVplsGenericDraft01MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 5, 8)).setRevisions(("2011-03-26 12:00","2006-08-30 12:00","2006-06-04 12:00",))
if mibBuilder.loadTexts: jnxVplsGenericDraft01MIB.setOrganization("Layer 2 Virtual Private Networks (L2VPN)\nWorking  Group")
if mibBuilder.loadTexts: jnxVplsGenericDraft01MIB.setContactInfo("\nThomas D. Nadeau\nEmail:  tnadeau@cisco.com\n\nThe L2VPN Working Group (email distribution l2vpn@ietf.org,\nhttp://www.ietf.org/html.charters/l2vpn-charter.html)")
if mibBuilder.loadTexts: jnxVplsGenericDraft01MIB.setDescription("Copyright (C) The IETF Trust (2010). The initial\nversion of this MIB module was published in RFC XXXX.\n-- RFC Editor: Please replace XXXX with RFC number & remove\n--                    this note.\n\nFor full legal notices see the RFC itself or see:\nhttp://www.ietf.org/copyrights/ianamib.html\n\nThis MIB module contains generic managed object definitions\nfor Virtual Private LAN Services as in [RFC4762] and\n[RFC4761]\n\nThis MIB module enables the use of any underlying PseudoWire\nnetwork.")
jnxVplsNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 8, 0))
jnxVplsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1))
jnxVplsConfigIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigIndexNext.setDescription("This object contains an appropriate value to be used\nfor jnxVplsConfigIndex when creating entries in the\njnxVplsConfigTable. The value 0 indicates that no\nunassigned entries are available.  To obtain the\nvalue of jnxVplsConfigIndex for a new entry in the\njnxVplsConfigTable, the manager issues a management\nprotocol retrieval operation to obtain the current\nvalue of jnxVplsConfigIndex.  After each retrieval\noperation, the agent should modify the value to\nreflect the next unassigned index.  After a manager\nretrieves a value the agent will determine through\nits local policy when this index value will be made\navailable for reuse.")
jnxVplsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2))
if mibBuilder.loadTexts: jnxVplsConfigTable.setDescription("This table specifies information for configuring\nand monitoring Virtual Private Lan Services(VPLS).")
jnxVplsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"))
if mibBuilder.loadTexts: jnxVplsConfigEntry.setDescription("A row in this table represents a Virtual Private Lan\nService(VPLS) in a packet network. It is indexed by\njnxVplsConfigIndex, which uniquely identifies a single VPLS.\n\nA row is created by the operator or by the agent if a\nVPLS service is created by non-SNMP application or\ndue to autodiscovery process.\n\nNone of the read-create objects values can be\nchanged when jnxVplsConfigRowStatus is in the active(1)\nstate. Changes are allowed when the jnxVplsConfigRowStatus\nis in notInService(2) or notReady(3) states only.\nIf the operator need to change one of the values\nfor an active row the jnxVplsConfigRowStatus should be\nfirst changed to notInService(2), the objects may\nbe changed now, and later to active(1) in order to\nre-initiate the signaling process with the new\nvalues in effect.")
jnxVplsConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigIndex.setDescription("Unique index for the conceptual row identifying\na VPLS service.")
jnxVplsConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 2), SnmpAdminString().clone('')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigName.setDescription("A textual name of the VPLS.\nIf there is no local name, or this object is\notherwise not applicable, then this object MUST\ncontain a zero-length octet string.")
jnxVplsConfigDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 3), SnmpAdminString().clone('')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigDescr.setDescription("A textual string containing information about the\nVPLS service. If there is no information for this VPLS\nservice, then this object MUST contain a zero-length\noctet string.")
jnxVplsConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigAdminStatus.setDescription("The desired administrative state of the VPLS\nservice. If the administrative status of the\nVpls service is changed to enable then this\nservice is able to utilize the pseudo wire to\nperform the tasks of a VPLS service.\nThe testing(3) state indicates that no operational\npackets can be passed. ")
jnxVplsConfigMacLearning = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 6), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigMacLearning.setDescription("This object specifies if MAC Learning is enabled\nin this service. If this object is true then Mac\nLearning is enabled. If false, then Mac Learning is\ndisabled.")
jnxVplsConfigDiscardUnknownDest = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigDiscardUnknownDest.setDescription("If the value of this object is 'true', then frames\nreceived with an unknown destination MAC are discarded\nin this VPLS. If 'false', then the packets are\nprocessed.")
jnxVplsConfigMacAging = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 8), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigMacAging.setDescription("If the value of this object is 'true'\nthen the MAC ageing process is enabled in\nthis VPLS. If 'false', then the MAC ageing process\nis disabled")
jnxVplsConfigFwdFullHighWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(95)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigFwdFullHighWatermark.setDescription("This object specifies the utilization of the\nforwarding database for this VPLS instance at\nwhich the jnxVplsFwdFullAlarmRaised notification\nwill be sent.")
jnxVplsConfigFwdFullLowWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(90)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigFwdFullLowWatermark.setDescription("This object specifies the utilization of the\nforwarding database for this VPLS instance\nat which the jnxVplsFwdFullAlarmCleared\nnotification will be sent.")
jnxVplsConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 12), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigRowStatus.setDescription("For creating, modifying, and deleting this row.\nNone of the read-create objects in the\nconceptual rows may be changed when this\nobject is in the active(1) state.")
jnxVplsConfigMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 1518)).clone(1518)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigMtu.setDescription("The value of this object specifies the MTU of this\nvpls instance.")
jnxVplsConfigVpnId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 14), VPNIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigVpnId.setDescription("This objects indicates the IEEE 802-1990\nVPN ID of the associated VPLS service.")
jnxVplsConfigServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("vlan", 1), ("ethernet", 2), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigServiceType.setDescription("The value of this object specifies the type of \nservice emulated by this vpls instance.")
jnxVplsConfigStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 2, 1, 16), StorageType().clone('volatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsConfigStorageType.setDescription("This variable indicates the storage type for this row.")
jnxVplsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 3))
if mibBuilder.loadTexts: jnxVplsStatusTable.setDescription("This table provides information for monitoring\nVirtual Private Lan Services(VPLS).")
jnxVplsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 3, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"))
if mibBuilder.loadTexts: jnxVplsStatusEntry.setDescription("A row in this table represents a Virtual Private Lan\nService(VPLS) in a packet network. It is indexed by\njnxVplsConfigIndex, which uniquely identifies a single VPLS.\n\nA row in this table is automatically created by the agent\nwhen a VPLS service is configured.")
jnxVplsStatusOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 3, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,0,1,)).subtype(namedValues=NamedValues(("other", 0), ("up", 1), ("down", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsStatusOperStatus.setDescription("The current operational state of this VPLS Service.")
jnxVplsStatusPeerCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsStatusPeerCount.setDescription("This objects specifies the number of peers\npresent in this vpls instance.")
jnxVplsPwBindTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4))
if mibBuilder.loadTexts: jnxVplsPwBindTable.setDescription("This table provides an association between a\nVPLS service and the corresponding Pseudo\nWires. A service can have more than one Pseudo\nWire association. Pseudo Wires are defined in\nthe pwTable")
jnxVplsPwBindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"), (0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsPwBindIndex"))
if mibBuilder.loadTexts: jnxVplsPwBindEntry.setDescription("Each row represents an association between a\nVPLS instance and one or more Pseudo Wires\ndefined in the pwTable. Each index is unique\nin describing an entry in this table. However\nboth indexes are required to define the one\nto many association of service to\npseudowire.")
jnxVplsPwBindConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("manual", 1), ("autodiscovery", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsPwBindConfigType.setDescription("The value of this object indicates\nwhether the Pseudo Wire binding was created\nmanually or via autodiscovery.\n\nThe value of this object must be\nspecifed when the row is created and cannot\nbe changed while the row status is active(1)")
jnxVplsPwBindType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("mesh", 1), ("spoke", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsPwBindType.setDescription("The value of this object indicates\nwhether the Pseudo Wire binding is of\ntype mesh or spoke.\n\nThe value of this object must be\nspecifed when the row is created and cannot\nbe changed while the row status is active(1)")
jnxVplsPwBindRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4, 1, 3), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsPwBindRowStatus.setDescription("For creating, modifying, and deleting this row.\nNone of the read-create objects in the\nconceptual rows may be changed when this\nobject is in the active(1) state")
jnxVplsPwBindStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4, 1, 4), StorageType().clone('volatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsPwBindStorageType.setDescription("This variable indicates the storage type for this row.")
jnxVplsPwBindIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 4, 1, 5), PwIndexType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsPwBindIndex.setDescription("Secondary Index for the conceptual row identifying\na pseudowire within the PwEntry which MUST \nmatch an entry from the PW-STD-MIB's PwTable\nwhich represents an already-provisioned\npseudowire that is then associated with this\nVPLS instance.")
jnxVplsBgpADConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 5))
if mibBuilder.loadTexts: jnxVplsBgpADConfigTable.setDescription("This table specifies information for configuring \nBGP Auto-discovery parameters for a given Vpls service. ")
jnxVplsBgpADConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 5, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"))
if mibBuilder.loadTexts: jnxVplsBgpADConfigEntry.setDescription("A row in this table represents BGP based autodiscovery \nis in use for this instance of Vpls. \nA row in this table is indexed by jnxVplsConfigIndex, which \nuniquely identifies a single VPLS.  \nNone of the read-create objects can be changed when  \njnxVplsBGPADConfigRowStatus is in active(1) state. Changes \nare allowed when the jnxVplsBGPADConfigRowStatus is in  \nnotInService(2) or notReady(3) states only.  \nIf the operator need to change one of the values \nfor an active row the jnxVplsConfigRowStatus should be \nfirst changed to notInService(2), the objects may \nbe changed now, and later to active(1) in order to \nre-initiate the signaling process with the new \nvalues in effect. ")
jnxVplsBgpADConfigRouteDistinguisher = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 5, 1, 1), JnxVplsBgpRouteDistinguisher()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpADConfigRouteDistinguisher.setDescription(" The route distinguisher for this VPLS. See [RFC4364]  \nfor a complete definition of a route distinguisher. \nfor more details on use of a route distinguisher \nfor a VPLS service, see [RFC4761] ")
jnxVplsBgpADConfigPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 5, 1, 2), Unsigned32().clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpADConfigPrefix.setDescription(" In case of auto-discovery the default prefix advertised \nis the ip address of the loopback. In case the user wants \nto override the loopback address, jnxVplsBgpADConfigPrefix  \nshould be set. When this value if non-zero it is used \nas the advertised IP address in the NLRI. ")
jnxVplsBgpADConfigVplsId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 5, 1, 3), JnxVplsBgpRouteDistinguisher()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpADConfigVplsId.setDescription(" VplsId is a unique identifier for all VSIs belonging to \nthe same VPLS. It is advertised as an extended community ")
jnxVplsBgpADConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 5, 1, 4), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpADConfigRowStatus.setDescription(" For creating, modifying, and deleting this row. \nNone of the read-create objects in the \nconceptual rows may be changed when this \nobject is in the active(1) state. ")
jnxVplsBgpRteTargetTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 6))
if mibBuilder.loadTexts: jnxVplsBgpRteTargetTable.setDescription(" This table specifies the list of Route Targets \nimported or exported by BGP during auto-discovery of VPLS. ")
jnxVplsBgpRteTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 6, 1)).setIndexNames((0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigIndex"), (0, "VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsBgpRteTargetIndex"))
if mibBuilder.loadTexts: jnxVplsBgpRteTargetEntry.setDescription("An entry in this table specifies the value of the \nRoute Target being used by BGP. Depending on the value\nof jnxVplsBgpRteTargetType an RT might be exported or \nimported or both. Every VPLS which \nuses auto-discovery for finding peer nodes can import and\nexport multiple Route Targets. This representation allows \nsupport for hierarchical VPLS. ")
jnxVplsBgpRteTargetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 6, 1, 1), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxVplsBgpRteTargetIndex.setDescription("This index along with jnxVplsConfigIndex,identifies one entry \nin the jnxVplsBgpRteTargetTable. By keeping jnxVplsConfigIndex \nconstant and using new value of jnxVplsBgpRteTargetIndex user \n can configure multiple Route Targets for the same Vpls. ")
jnxVplsBgpRteTargetRTType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 6, 1, 2), JnxVplsBgpRouteTargetType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpRteTargetRTType.setDescription(" Used to define the type of a route target usage. \nRoute targets can be specified to be imported, \nexported, or both.  For a complete definition of a \nroute target, see [RFC4364]. ")
jnxVplsBgpRteTargetRT = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 6, 1, 3), JnxVplsBgpRouteTarget()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpRteTargetRT.setDescription(" The route target associated with the VPLS service. \nFor more details on use of route targets \nfor a VPLS service, see [RFC4761] ")
jnxVplsBgpRteTargetRTRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 6, 1, 4), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxVplsBgpRteTargetRTRowStatus.setDescription("This variable is used to create, modify, and/or \ndelete a row in this table.  When a row in this \ntable is in active(1) state, no objects in that row \ncan be modified ")
jnxVplsStatusNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxVplsStatusNotifEnable.setDescription("If this object is set to true(1), then it enables \nthe emission of jnxVplsStatusChanged \nnotification; otherwise this notification is not \nemitted.")
jnxVplsNotificationMaxRate = MibScalar((1, 3, 6, 1, 4, 1, 2636, 5, 8, 1, 8), Unsigned32().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: jnxVplsNotificationMaxRate.setDescription("This object indicates the maximum number of\nnotifications issued per second. If events occur\nmore rapidly, the implementation may simply fail to\nemit these notifications during that period, or may\nqueue them until an appropriate time. A value of 0\nmeans no throttling is applied and events may be\nnotified at the rate at which they occur.")
jnxVplsConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 5, 8, 2))

# Augmentions

# Notifications

jnxVplsStatusChanged = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 8, 0, 1)).setObjects(*(("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigAdminStatus"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigVpnId"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsStatusOperStatus"), ) )
if mibBuilder.loadTexts: jnxVplsStatusChanged.setDescription("The jnxVplsStatusChanged notification is generated\nwhen there is a change in the administrative or\noperating status of a VPLS service.")
jnxVplsFwdFullAlarmRaised = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 8, 0, 2)).setObjects(*(("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigFwdFullHighWatermark"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigVpnId"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigFwdFullLowWatermark"), ) )
if mibBuilder.loadTexts: jnxVplsFwdFullAlarmRaised.setDescription("The jnxVplsFwdFullAlarmRaised notification is\ngenerated when the utilization of the Forwarding\ndatabase is above the value specified by\njnxVplsConfigFwdFullHighWatermark.")
jnxVplsFwdFullAlarmCleared = NotificationType((1, 3, 6, 1, 4, 1, 2636, 5, 8, 0, 3)).setObjects(*(("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigFwdFullHighWatermark"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigVpnId"), ("VPLS-GENERIC-DRAFT-01-MIB", "jnxVplsConfigFwdFullLowWatermark"), ) )
if mibBuilder.loadTexts: jnxVplsFwdFullAlarmCleared.setDescription("The jnxVplsFwdFullAlarmCleared notification is\ngenerated when the utilization of the Forwarding\ndatabase is below the value specified by\njnxVplsConfigFwdFullLowWatermark.")

# Exports

# Module identity
mibBuilder.exportSymbols("VPLS-GENERIC-DRAFT-01-MIB", PYSNMP_MODULE_ID=jnxVplsGenericDraft01MIB)

# Types
mibBuilder.exportSymbols("VPLS-GENERIC-DRAFT-01-MIB", JnxVplsBgpRouteDistinguisher=JnxVplsBgpRouteDistinguisher, JnxVplsBgpRouteTarget=JnxVplsBgpRouteTarget, JnxVplsBgpRouteTargetType=JnxVplsBgpRouteTargetType, PwIndexType=PwIndexType)

# Objects
mibBuilder.exportSymbols("VPLS-GENERIC-DRAFT-01-MIB", jnxVplsGenericDraft01MIB=jnxVplsGenericDraft01MIB, jnxVplsNotifications=jnxVplsNotifications, jnxVplsObjects=jnxVplsObjects, jnxVplsConfigIndexNext=jnxVplsConfigIndexNext, jnxVplsConfigTable=jnxVplsConfigTable, jnxVplsConfigEntry=jnxVplsConfigEntry, jnxVplsConfigIndex=jnxVplsConfigIndex, jnxVplsConfigName=jnxVplsConfigName, jnxVplsConfigDescr=jnxVplsConfigDescr, jnxVplsConfigAdminStatus=jnxVplsConfigAdminStatus, jnxVplsConfigMacLearning=jnxVplsConfigMacLearning, jnxVplsConfigDiscardUnknownDest=jnxVplsConfigDiscardUnknownDest, jnxVplsConfigMacAging=jnxVplsConfigMacAging, jnxVplsConfigFwdFullHighWatermark=jnxVplsConfigFwdFullHighWatermark, jnxVplsConfigFwdFullLowWatermark=jnxVplsConfigFwdFullLowWatermark, jnxVplsConfigRowStatus=jnxVplsConfigRowStatus, jnxVplsConfigMtu=jnxVplsConfigMtu, jnxVplsConfigVpnId=jnxVplsConfigVpnId, jnxVplsConfigServiceType=jnxVplsConfigServiceType, jnxVplsConfigStorageType=jnxVplsConfigStorageType, jnxVplsStatusTable=jnxVplsStatusTable, jnxVplsStatusEntry=jnxVplsStatusEntry, jnxVplsStatusOperStatus=jnxVplsStatusOperStatus, jnxVplsStatusPeerCount=jnxVplsStatusPeerCount, jnxVplsPwBindTable=jnxVplsPwBindTable, jnxVplsPwBindEntry=jnxVplsPwBindEntry, jnxVplsPwBindConfigType=jnxVplsPwBindConfigType, jnxVplsPwBindType=jnxVplsPwBindType, jnxVplsPwBindRowStatus=jnxVplsPwBindRowStatus, jnxVplsPwBindStorageType=jnxVplsPwBindStorageType, jnxVplsPwBindIndex=jnxVplsPwBindIndex, jnxVplsBgpADConfigTable=jnxVplsBgpADConfigTable, jnxVplsBgpADConfigEntry=jnxVplsBgpADConfigEntry, jnxVplsBgpADConfigRouteDistinguisher=jnxVplsBgpADConfigRouteDistinguisher, jnxVplsBgpADConfigPrefix=jnxVplsBgpADConfigPrefix, jnxVplsBgpADConfigVplsId=jnxVplsBgpADConfigVplsId, jnxVplsBgpADConfigRowStatus=jnxVplsBgpADConfigRowStatus, jnxVplsBgpRteTargetTable=jnxVplsBgpRteTargetTable, jnxVplsBgpRteTargetEntry=jnxVplsBgpRteTargetEntry, jnxVplsBgpRteTargetIndex=jnxVplsBgpRteTargetIndex, jnxVplsBgpRteTargetRTType=jnxVplsBgpRteTargetRTType, jnxVplsBgpRteTargetRT=jnxVplsBgpRteTargetRT, jnxVplsBgpRteTargetRTRowStatus=jnxVplsBgpRteTargetRTRowStatus, jnxVplsStatusNotifEnable=jnxVplsStatusNotifEnable, jnxVplsNotificationMaxRate=jnxVplsNotificationMaxRate, jnxVplsConformance=jnxVplsConformance)

# Notifications
mibBuilder.exportSymbols("VPLS-GENERIC-DRAFT-01-MIB", jnxVplsStatusChanged=jnxVplsStatusChanged, jnxVplsFwdFullAlarmRaised=jnxVplsFwdFullAlarmRaised, jnxVplsFwdFullAlarmCleared=jnxVplsFwdFullAlarmCleared)

