# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-MIMSTP-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:53 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( jnxXstpMibs, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxXstpMibs")
( Bits, Counter32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, enterprises, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "enterprises")
( MacAddress, RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "RowStatus", "TextualConvention", "TruthValue")

# Types

class BridgeId(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(8,8)
    fixedLength = 8
    
class EnabledStatus(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("enabled", 1), ("disabled", 2), )
    
class Timeout(TextualConvention, Integer32):
    displayHint = "d4"
    
class VlanId(Integer32):
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,4094)
    

# Objects

jnxMIMstMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1)).setRevisions(("2007-12-18 00:00","2007-05-24 00:00","2007-05-03 00:00","2007-05-03 00:00",))
if mibBuilder.loadTexts: jnxMIMstMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxMIMstMIB.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxMIMstMIB.setDescription("This mib module is for Juniper Networks Proprietory\nMultiple Instance MSTP mib")
jnxMIDot1sJuniperMst = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1))
jnxMIMstGlobalTrace = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstGlobalTrace.setDescription("This object is used to enable Global Trace \nStatements in the MSTP Module.")
jnxMIMstGlobalDebug = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstGlobalDebug.setDescription("This object is used to enable Global Debug \nStatements in the MSTP Module.")
jnxMIDot1sJuniperMstTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3))
if mibBuilder.loadTexts: jnxMIDot1sJuniperMstTable.setDescription("List of per Virtual Context Mst Module Parameters.")
jnxMIDot1sJuniperMstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIDot1sJuniperMstContextId"))
if mibBuilder.loadTexts: jnxMIDot1sJuniperMstEntry.setDescription("Virtual Context Mst Module Parameters.")
jnxMIDot1sJuniperMstContextId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMIDot1sJuniperMstContextId.setDescription("Identifies the Virtual Context.")
jnxMIMstSystemControl = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("start", 1), ("shutdown", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstSystemControl.setDescription("The administrative shutdown status requested by management for the MST  \nfeature. The value start (1) indicates that MST should be active in \nthe device on all ports. The value shutdown (2) indicates that MST \nshould be shutdown in the device on all ports. All memory should \nbe released on all ports.")
jnxMIMstModuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 3), EnabledStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstModuleStatus.setDescription("The administrative status requested by management for the MST  \nfeature. The value enabled(1) indicates that Mst should be enabled  \nin the device on all ports. The value disabled(2) indicates that \nMst should be disabled in the device on all ports. The object can \nbe set to enabled(1) if and only if, jnxMIMstSystemControl set to start.")
jnxMIMstMaxMstInstanceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMaxMstInstanceNumber.setDescription("The Maximun number of spanning trees to be allowed.\nA User may limit the Number of Spanning Tree instance \nto be allowed in the Bridge.")
jnxMIMstNoOfMstiSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstNoOfMstiSupported.setDescription("Indicates Maximum number of spanning tree Instances supported.")
jnxMIMstMaxHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMaxHopCount.setDescription("Indicates the Maximum Hop Count value.\nThe granularity of this timer is specified \nto be 1 second.  An agent may return a badValue \nerror if a set is attempted to a value which is \nnot a whole number of seconds.")
jnxMIMstBrgAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 7), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstBrgAddress.setDescription("The MAC address used by this bridge when it must\nbe referred to in a unique fashion.   It is\nrecommended that this be the numerically smallest\nMAC address of all ports that belong to this\nbridge.  However it is only required to be unique.\nWhen concatenated with jnxMIMstCistBridgePriority or \njnxMIMstMstiBridgePriority a unique BridgeIdentifier \nis formed which is used in the Spanning Tree Protocol.")
jnxMIMstCistRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 8), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistRoot.setDescription("The bridge identifier of the Root of the common spanning\ntree as determined by the Spanning Tree Protocol\nas executed by this node.  This value is used as\nthe CIST Root Identifier parameter in all Configuration\nBridge PDUs originated by this node.")
jnxMIMstCistRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 9), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistRegionalRoot.setDescription("The bridge identifier of the Root of the Multiple\nspanning tree region as determined by the Spanning Tree\nProtocol as executed by this node.  This value is used as\nthe CIST Regional Root Identifier parameter in all Configuration\nBridge PDUs originated by this node.")
jnxMIMstCistRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistRootCost.setDescription("The Cost of the path to the CIST Root as seen \nfrom this bridge.")
jnxMIMstCistRegionalRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistRegionalRootCost.setDescription("The Cost of the path to the CIST Regional Root \nas seen from this bridge.")
jnxMIMstCistRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistRootPort.setDescription("The Port Number of the Port which offers the lowest    \npath cost from this bridge to the CIST Root Bridge.")
jnxMIMstCistBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistBridgePriority.setDescription("The Value of the writable portion of the Bridge\nIdentifier comprising of the first two octets.\nThe values that are set for Bridge Priority must be \nin steps of 4096.")
jnxMIMstCistBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 14), Timeout().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistBridgeMaxAge.setDescription("The value that all bridges use for MaxAge when\nthis bridge is acting as the root. The granularity \nof this timer is specified to be 1 second.\nAn agent may return a badValue error if a set is\nattempted to a value which is not a whole number\nof seconds.")
jnxMIMstCistBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 15), Timeout().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistBridgeForwardDelay.setDescription("The value that all bridges use for ForwardDelay\nwhen this bridge is acting as the root.  Note that\n802.1D specifies that the range for this\nparameter is related to the value of\nBridgeMaxAge.  The granularity of this\ntimer is specified to be 1 second.\nAn agent may return a badValue error if a set is\nattempted to a value which is not a whole number\nof seconds.")
jnxMIMstCistHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistHoldTime.setDescription("This time value determines the interval length\nduring which no more than two Configuration bridge\nPDUs shall be transmitted by this node, in units\nof hundredths of a second.")
jnxMIMstCistMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 17), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistMaxAge.setDescription("The maximum age of Spanning Tree Protocol\ninformation learned from the network on any port\nbefore it is discarded, in units of hundredths of\na second.  This is the actual value that this\nbridge is currently using.")
jnxMIMstCistForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 18), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistForwardDelay.setDescription("This time value, measured in units of hundredths\nof a second, controls how fast a port changes its\nspanning state when moving towards the Forwarding\nstate.  The value determines how long the port\nstays in a particular state before moving to the\nnext state.")
jnxMIMstMstpUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstpUpCount.setDescription("The number of times MSTP Module has been enabled.")
jnxMIMstMstpDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstpDownCount.setDescription("The number of times MSTP Module has been disabled.")
jnxMIMstPathCostDefaultType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 21), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("stp8021d1998", 1), ("stp8021t2001", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstPathCostDefaultType.setDescription("The version of the Spanning Tree default Path Costs that\nare to be used by this Bridge.  A value of 8021d1998(1)\nuses the 16-bit default Path Costs from IEEE Std. 802.1D-1998.\nA value of stp8021t2001(2) uses the 32-bit default Path\nCosts from IEEE Std. 802.1t.")
jnxMIMstTrace = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstTrace.setDescription("This object is used to enable Trace Statements in the MSTP\nModule.\n\nA FOUR BYTE integer is used for enabling the level of tracing. \nEach BIT in the four byte integer, represents a particular \nlevel of Trace. \n\nThe mapping between the bit positions & the level of trace is \nas follows: \n0 - Init and Shutdown Traces\n1 - Management Traces\n2 - Data Path Traces\n3 - Control Plane Traces\n4 - Packet Dump Traces\n5 - Traces related to All Resources except Buffers\n6 - All Failure Traces\n7 - Buffer Traces\n\nThe remaining bits are unused. Combination of trace levels are \nalso allowed.\n\nFor example if the bits 0 and 1 are set, then the Trace\nstatements related to Init-Shutdown and management \nwill be printed.\n\nThe user has to enter the corresponding INTEGER VALUE for the\nbits set. For example if bits 0 and 1 are to be set then user has\nto give the value for this object as 3.\n\nSetting the Trace Option to any value will cause the Debug Option\nto be set to 0 (i.e.) the Trace Option and Debug Option are mutually\nexclusive.")
jnxMIMstDebug = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 131071)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstDebug.setDescription("This object is used to enable Debug Statements in the MSTP\nModule.\n\nA FOUR BYTE integer is used for enabling the level of debugging. \nEach BIT in the four byte integer, represents a particular \nlevel of Debug. \n\nThe mapping between the bit positions & the level of debug is \nas follows: \n0 - Init and Shutdown Debug statements\n1 - Management Debug statements\n2 - Memory related Debug statements\n3 - BPDU related Debug statements\n4 - Event Handling Debug statements\n5 - Timer Module Debug statements\n6 - Port Information SEM Debug statements\n7 - Port Receive SEM Debug statements (valid in the case of MSTP alone)\n8 - Role Selection SEM Debug statements\n9 - Role Transition SEM Debug statements\n10 - State Transition SEM Debug statements\n11 - Protocol Migration SEM Debug statements\n12 - Topology Change SEM Debug statements\n13 - Port Transmit SEM Debug statements\n14 - Bridge Detection SEM Debug statements\n15 - All Failure Debug statements\n16 - Redundancy code flow Debug statements\n\nThe remaining bits are unused. Combination of debug levels are \nalso allowed.\n\nFor example if the bits 0 and 1 are set, then the Debug\nstatements related to Init-Shutdown and management \nwill be printed.\n\nThe user has to enter the corresponding INTEGER VALUE for the\nbits set. For example if bits 0 and 1 are to be set then user has\nto give the value for this object as 3.\n\nSetting the Debug Option to any value will cause the Trace Option\nto be set to 0 (i.e.) the Trace Option and Debug Option are mutually\nexclusive.")
jnxMIMstForceProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 24), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,2,)).subtype(namedValues=NamedValues(("stpCompatible", 0), ("rstp", 2), ("mstp", 3), )).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstForceProtocolVersion.setDescription("The version of Spanning Tree Protocol the bridge is\ncurrently running.  The value 'stpCompatible(0)'\nindicates the Spanning Tree Protocol specified in\nIEEE 802.1D and 'rstp(2)' indicates the Rapid Spanning\nTree Protocol specified in IEEE 802.1w and 'mstp(3)'\nindicates the Multiple Spanning Tree Protocol Specified\nin IEEE 802.1s.")
jnxMIMstTxHoldCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstTxHoldCount.setDescription("The value used by the Port Transmit state machine to limit\nthe maximum transmission rate.")
jnxMIMstMstiConfigIdSel = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiConfigIdSel.setDescription("The Configuration Identifier Format Selector used \nby the Bridge. This has a fixed value of 0 to indicate\nRegionName, RegionVersion are specified as in Standard.")
jnxMIMstMstiRegionName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiRegionName.setDescription("The Name for the Region's configuration. By Default \nRegion Name will be equal to the Bridge Mac Address.")
jnxMIMstMstiRegionVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiRegionVersion.setDescription("Version of the MST Region.")
jnxMIMstMstiConfigDigest = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiConfigDigest.setDescription("The Configuration Digest value for this Region.")
jnxMIMstBufferOverFlowCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstBufferOverFlowCount.setDescription("The number of times Buffer overflows/failures have occured.\nA Trap is generated on the occurence of this event.")
jnxMIMstMemAllocFailureCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMemAllocFailureCount.setDescription("The number of times memory allocation failures have occured.\nA Trap is generated on the occurence of this event.")
jnxMIMstRegionConfigChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstRegionConfigChangeCount.setDescription("The number of times a Region Configuration Identifier Change \nwas detected. \nA Trap is generated on the occurence of this event.")
jnxMIMstCistBridgeRoleSelectionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 33), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("initbridge", 0), ("roleselection", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistBridgeRoleSelectionSemState.setDescription("Current state of the Port Role Selection State Machine          \nof this bridge in Common Spanning Tree context")
jnxMIMstCistTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 34), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistTimeSinceTopologyChange.setDescription("The time (in hundredths of a second) since the\nTcWhile Timer for any port in this Bridge was \nnon-zero for Common Spanning Tree context.")
jnxMIMstCistTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistTopChanges.setDescription("The number of times that there have been atleast\none non-zero TcWhile Timer on this Bridge for Common\nSpanning Tree context.")
jnxMIMstCistNewRootBridgeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistNewRootBridgeCount.setDescription("The number of times this Bridge has detected a Root\nBridge change for Common Spanning Tree context.\nA Trap is generated on the occurence of this event.")
jnxMIMstCistHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 37), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistHelloTime.setDescription("This time value, measured in units of hundredths\nof a second, specifies the amount of time between\nthe transmission of configuration BPDUs by this node\non any port when it is the root of the spanning tree \nor trying to become so.")
jnxMIMstCistBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 38), Timeout().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistBridgeHelloTime.setDescription("The amount of time between the transmission of\nConfiguration bridge PDUs by this node in units \nof hundredths of a second.")
jnxMIMstCistDynamicPathcostCalculation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 3, 1, 39), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistDynamicPathcostCalculation.setDescription("This object is used to determine whether dynamic pathcost\ncalculation is allowed or not.The value is determined by \nmanagement. If set to true, pathcost is calculated dynamically \nfrom port speed, otherwise the link speed at the time of port \ncreation is used for calculating the path cost. In both cases\nif the user has configured a pathcost for the port that will be \nused. By default dynamic pathcost calculation is set to false.")
jnxMIMstMstiBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4))
if mibBuilder.loadTexts: jnxMIMstMstiBridgeTable.setDescription("Table containing Bridge Information specific to Spanning \nTree Instance. This table maintains context ID as one \nmore index to support Multiple Instances.")
jnxMIMstMstiBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIDot1sJuniperMstContextId"), (0, "JUNIPER-MIMSTP-MIB", "jnxMIMstMstiInstanceIndex"))
if mibBuilder.loadTexts: jnxMIMstMstiBridgeEntry.setDescription("Entry indicating the Bridge Information.")
jnxMIMstMstiInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiInstanceIndex.setDescription("Spanning Tree Instance to which the information belongs.")
jnxMIMstMstiBridgeRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 2), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiBridgeRegionalRoot.setDescription("MSTI Regional Root Identifier value for the Instance. This value \nis used as the MSTI Regional Root Identifier parameter in all\nConfiguration Bridge PDUs originated by this node")
jnxMIMstMstiBridgePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 61440)).clone(32768)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiBridgePriority.setDescription("The writable portion of the MSTI Bridge Identifier.\ncomprising of the first two octets.\nThe values that are set for Bridge Priority must be \nin steps of 4096.")
jnxMIMstMstiRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiRootCost.setDescription("The Cost of the path to the MSTI Regional Root as seen \nby this bridge.")
jnxMIMstMstiRootPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiRootPort.setDescription("The Port Number of the Port which offers the lowest    \npath cost from this bridge to the MSTI Region Root Bridge.")
jnxMIMstMstiTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiTimeSinceTopologyChange.setDescription("The time (in hundredths of a second) since the\nTcWhile Timer for any port in this Bridge was \nnon-zero for this spanning tree instance.")
jnxMIMstMstiTopChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiTopChanges.setDescription("The number of times that there have been atleast\none non-zero TcWhile Timer on this Bridge for this\nspanning tree instance.")
jnxMIMstMstiNewRootBridgeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiNewRootBridgeCount.setDescription("The number of times this Bridge has detected a Root\nBridge change for this spanning tree instance.\nA Trap is generated on the occurence of this event.")
jnxMIMstMstiBridgeRoleSelectionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("initbridge", 0), ("roleselection", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiBridgeRoleSelectionSemState.setDescription("Current state of the Port Role Selection State Machine          \nfor this spanning tree instance for this bridge.")
jnxMIMstInstanceUpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstInstanceUpCount.setDescription("The number of times a new spanning tree instance has\nbeen created. This counter is incremented whenever a new\nspanning tree instance is created and also whenever a \nvlan is mapped to the instance.\nA Trap is generated on the occurence of this event.")
jnxMIMstInstanceDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstInstanceDownCount.setDescription("The number of times a spanning tree instance has\nbeen deleted. This counter is incremented whenever a \nspanning tree instance is deleted and also whenever a \nvlan is unmapped from the instance.\nA Trap is generated on the occurence of this event.")
jnxMIMstOldDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 4, 1, 12), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstOldDesignatedRoot.setDescription("The bridge identifier of the old root of the spanning\ntree instance as determined by the Spanning Tree Protocol\nas executed by this node. ")
jnxMIMstVlanInstanceMappingTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5))
if mibBuilder.loadTexts: jnxMIMstVlanInstanceMappingTable.setDescription("This table contains one entry for each instance of MSTP. \nThis table maintains context ID as one more index to \nsupport Multiple Instances.")
jnxMIMstVlanInstanceMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIDot1sJuniperMstContextId"), (0, "JUNIPER-MIMSTP-MIB", "jnxMIMstInstanceIndex"))
if mibBuilder.loadTexts: jnxMIMstVlanInstanceMappingEntry.setDescription("A conceptual row containing the status of the MSTP instance.")
jnxMIMstInstanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMIMstInstanceIndex.setDescription("An arbitrary integer within the range from 1 to the value of\nMax Instance Number that uniquely identifies an instance.")
jnxMIMstMapVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 2), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMapVlanIndex.setDescription("The VlanId will get mapped to the spanning tree instance \nspecified. All the Instance Specific information for the \nMember ports of the Vlan will be created.This object is \nused only for SET operation.GET Operation returns null values.\nIf the VlanId to Instance Mapping has to be known then any \none of the VlanMapped object should be used.")
jnxMIMstUnMapVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 3), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstUnMapVlanIndex.setDescription("The VlanId will get unmapped from spanning tree instance\nto which it it mapped. All the Instance Specific information\nfor the Member ports of the Vlan will get released.This object \nis used only for SET operation.GET Operation returns null values.")
jnxMIMstSetVlanList = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstSetVlanList.setDescription("A string of octets containing one bit per VLAN. The\nfirst octet corresponds to VLANs with VlanIndex values\n1 through 8; the second octet to VLANs 9 through\n16 etc.  The most significant bit of each octet\ncorresponds to the lowest VlanIndex value in that octet.\nThe set of vlans configured by management to map for this \nInstance.  If the VlanId to Instance Mapping has to be known\nthen any one of the VlanMapped object should be used.If a \nvlan is already mapped to this Instance, it may not be mapped \nagain. This object is used only for SET operation.\nGET Operation returns null values.")
jnxMIMstResetVlanList = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstResetVlanList.setDescription("A string of octets containing one bit per VLAN. The\nfirst octet corresponds to VLANs with VlanIndex values\n1 through 8; the second octet to VLANs 9 through\n16 etc.  The most significant bit of each octet\ncorresponds to the lowest VlanIndex value in that octet.\nThe set of vlans configured by management to unmap from this \nInstance. A vlan may not be unmapped from this instance if \nit is not already mapped to this Instance. This object is\nused only for SET operation.GET Operation returns null values.")
jnxMIMstInstanceVlanMapped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstInstanceVlanMapped.setDescription("A string of octets containing one bit per VLAN. The\nfirst octet corresponds to VLANs with VlanIndex values\n1 through 8; the second octet to VLANs 9 through\n16 etc.  The most significant bit of each octet\ncorresponds to the lowest VlanIndex value in that octet.\n\nFor each VLAN that is mapped to this MSTP instance,\nthe bit corresponding to that VLAN is set to '1'.")
jnxMIMstInstanceVlanMapped2k = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstInstanceVlanMapped2k.setDescription("A string of octets containing one bit per VLAN for\nVLANS with VlanIndex values 1024 through 2047. The\nfirst octet corresponds to VLANs with VlanIndex values\n1024 through 1031; the second octet to VLANs 1032\nthrough 1039 etc.  The most significant bit of each\noctet corresponds to the lowest VlanIndex value in that\noctet.\n\nFor each VLAN that is mapped to this MSTP instance,\nthe bit corresponding to that VLAN is set to '1'.\n\nThis object is only instantiated on devices with \nsupport for VlanIndex values up to 4095.")
jnxMIMstInstanceVlanMapped3k = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstInstanceVlanMapped3k.setDescription("A string of octets containing one bit per VLAN for\nVLANS with VlanIndex values 2048 through 3071. The\nfirst octet corresponds to VLANs with VlanIndex values\nof 2048 through 2055; the second octet to VLANs 2056\nthrough 2063 etc.  The most significant bit of each\noctet corresponds to the lowest VlanIndex value in that\noctet.\n\nFor each VLAN that is mapped to this MSTP instance,\nthe bit corresponding to that VLAN is set to '1'.\n\nThis object is only instantiated on devices with \nsupport for VlanIndex values up to 4095.")
jnxMIMstInstanceVlanMapped4k = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 5, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstInstanceVlanMapped4k.setDescription("A string of octets containing one bit per VLAN for\nVLANS with VlanIndex values 3072 through 4095. The\nfirst octet corresponds to VLANs with VlanIndex values\n3072 through 3079; the second octet to VLANs 3080\nthrough 3087 etc.  The most significant bit of each\noctet corresponds to the lowest VlanIndex value in that\noctet.\n\nFor each VLAN that is mapped to this MSTP instance,\nthe bit corresponding to that VLAN is set to '1'.\n\nThis object is only instantiated on devices with \nsupport for VlanIndex values up to 4095.")
jnxMIMstCistPortTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6))
if mibBuilder.loadTexts: jnxMIMstCistPortTable.setDescription("This table contains Common Spanning Tree Port\nInformation.")
jnxMIMstCistPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIMstCistPort"))
if mibBuilder.loadTexts: jnxMIMstCistPortEntry.setDescription("A list of information maintained by every port for \nCommon Spanning tree.")
jnxMIMstCistPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMIMstCistPort.setDescription("The Port number of the port for which this entry contains   \nspanning tree information.")
jnxMIMstCistPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortPathCost.setDescription("The contribution of this port to the path cost of\npaths towards the CIST Root which include this port.")
jnxMIMstCistPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortPriority.setDescription("The four most significant bits of the Port Identifier \nof the Spanning Tree instance can be modified by setting \nthe CistPortPriority value. The values that are set for Port \nPriority must be in steps of 16.")
jnxMIMstCistPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortDesignatedRoot.setDescription("The unique Bridge Identifier of the bridge recorded as the  \nCIST Root in the configuration BPDUs transmitted.")
jnxMIMstCistPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortDesignatedBridge.setDescription("The unique Bridge Identifier of the bridge which this port  \nconsiders to be the Designated Bridge for the port's segment.")
jnxMIMstCistPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortDesignatedPort.setDescription("The Port identifier of the port on the Designated Bridge    \nfor this port's segment.")
jnxMIMstCistPortAdminP2P = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,2,)).subtype(namedValues=NamedValues(("forceTrue", 0), ("forceFalse", 1), ("auto", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortAdminP2P.setDescription("The administrative point-to-point status of the LAN segment\nattached to this port.  A value of forceTrue(0) indicates that\nthis port should always be treated as if it is connected to\na point-to-point link.  A value of forceFalse(1) indicates\nthat this port should be treated as having a shared media\nconnection.  A value of auto(2) indicates that this port is\nconsidered to have a point-to-point link if it is an Aggregator\nand all of its members are aggregatable, or if the MAC entity\nis configured for full duplex operation, either through\nauto-negotiation or by management means.")
jnxMIMstCistPortOperP2P = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortOperP2P.setDescription("The operational point-to-point status of the LAN segment\nattached to this port.  It indicates whether a port is\nconsidered to have a point-to-point connection or not.\nThe value is determined by management or by auto-detection,\nas described in the jnxMIMstCistPortAdminP2P object.")
jnxMIMstCistPortAdminEdgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortAdminEdgeStatus.setDescription("The administrative value of the Edge Port parameter.  A\nvalue of TRUE(1) indicates that this port should be\nassumed as an edge-port and a value of FALSE(2) indicates\nthat this port should be assumed as a non-edge-port.")
jnxMIMstCistPortOperEdgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortOperEdgeStatus.setDescription("The operational value of the Edge Port parameter.  The\nobject is initialized to the value of\njnxMIMstCistPortAdminEdgeStatus and is set FALSE on reception \nof a BPDU.")
jnxMIMstCistPortProtocolMigration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortProtocolMigration.setDescription("Indicates the Protocol migration state of this Port.         \nWhen operating in RSTP/MSTP (version >= 2) mode, writing \nTRUE(1) to this object forces this port to transmit MSTP \nBPDUs without instance information.\nAny other operation on this object has no effect and\nit always returns FALSE(2) when read.")
jnxMIMstCistPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,5,4,)).subtype(namedValues=NamedValues(("disabled", 1), ("discarding", 2), ("learning", 4), ("forwarding", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortState.setDescription("Current state of the Port as defined by the Common    \nspanning tree protocol.")
jnxMIMstCistForcePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 13), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistForcePortState.setDescription("Current state of the Port which can be changed to either \nDisabled or Enabled for ALL spanning tree   \ninstances. Setting this object will override the port's\nstatus in any of the MSTI contexts")
jnxMIMstCistPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortForwardTransitions.setDescription("Number of times this port has transitioned to the     \nForwarding State.")
jnxMIMstCistPortRxMstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRxMstBpduCount.setDescription("Number of MST BPDUs received on this port.")
jnxMIMstCistPortRxRstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRxRstBpduCount.setDescription("Number of RST BPDUs received on this port.")
jnxMIMstCistPortRxConfigBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRxConfigBpduCount.setDescription("Number of Configuration BPDUs received on this port.")
jnxMIMstCistPortRxTcnBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRxTcnBpduCount.setDescription("Number of TCN BPDUs received on this port.")
jnxMIMstCistPortTxMstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortTxMstBpduCount.setDescription("Number of MST BPDUs Transmitted from this port.")
jnxMIMstCistPortTxRstBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortTxRstBpduCount.setDescription("Number of RST BPDUs Transmitted from this port.")
jnxMIMstCistPortTxConfigBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortTxConfigBpduCount.setDescription("Number of Configuration BPDUs Transmitted from this port.")
jnxMIMstCistPortTxTcnBpduCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortTxTcnBpduCount.setDescription("Number of TCN BPDUs Transmitted from this port.")
jnxMIMstCistPortInvalidMstBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortInvalidMstBpduRxCount.setDescription("Number of Invalid MST BPDUs Received on this port.")
jnxMIMstCistPortInvalidRstBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortInvalidRstBpduRxCount.setDescription("Number of Invalid RST BPDUs Received on this port.")
jnxMIMstCistPortInvalidConfigBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortInvalidConfigBpduRxCount.setDescription("Number of Invalid Configuration BPDUs Received on this port.")
jnxMIMstCistPortInvalidTcnBpduRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortInvalidTcnBpduRxCount.setDescription("Number of Invalid TCN BPDUs Received on this port.")
jnxMIMstCistPortTransmitSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 27), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,0,5,1,4,)).subtype(namedValues=NamedValues(("transmitinit", 0), ("transmitperiodic", 1), ("transmitconfig", 2), ("transmittcn", 3), ("transmitrstp", 4), ("idle", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortTransmitSemState.setDescription("Indicates current State of the Port Transmit state machine.")
jnxMIMstCistPortReceiveSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 28), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("discard", 0), ("receive", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortReceiveSemState.setDescription("Indicates current State of the Port Receive state machine.")
jnxMIMstCistPortProtMigrationSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 29), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,0,2,4,)).subtype(namedValues=NamedValues(("init", 0), ("sendrstp", 1), ("sendingrstp", 2), ("sendstp", 3), ("sendingstp", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortProtMigrationSemState.setDescription("Indicates current State of the Port Protocol Migration\nState machine.")
jnxMIMstCistProtocolMigrationCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistProtocolMigrationCount.setDescription("The number of times this Port has migrated from one STP protocol \nversion to another. The relevant protocols are STP-COMPATIBLE and \nRSTP/MSTP.\nA Trap is generated on the occurence of this event.")
jnxMIMstCistPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortDesignatedCost.setDescription("The path cost of the Designated Port of the\nsegment connected to this port.")
jnxMIMstCistPortRegionalRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 32), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRegionalRoot.setDescription("The unique Bridge Identifier of the bridge recorded as the  \nCIST Regional Root Identifier in the configuration BPDUs \ntransmitted.")
jnxMIMstCistPortRegionalPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRegionalPathCost.setDescription("The contribution of this port to the path cost of paths     \ntowards the CIST Regional Root which include this port.")
jnxMIMstCistSelectedPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 34), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,4,0,3,)).subtype(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistSelectedPortRole.setDescription("Selected Port Role of the port for this spanning \ntree instance.")
jnxMIMstCistCurrentPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 35), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,4,0,3,)).subtype(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistCurrentPortRole.setDescription("Current Port Role of the port for this spanning \ntree instance.")
jnxMIMstCistPortInfoSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 36), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,2,8,9,1,5,7,4,6,)).subtype(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("aged", 2), ("update", 3), ("superiordesg", 4), ("repeatdesg", 5), ("root", 6), ("other", 7), ("present", 8), ("receive", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortInfoSemState.setDescription("Current state of the Port Information State Machine          \nfor this port in this spanning tree context.")
jnxMIMstCistPortRoleTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 37), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,1,2,)).subtype(namedValues=NamedValues(("init", 0), ("blockport", 1), ("blockedport", 2), ("activeport", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRoleTransitionSemState.setDescription("Current state of the Port Role Transition State Machine          \nfor this port in this spanning tree context.")
jnxMIMstCistPortStateTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 38), Integer().subtype(subtypeSpec=SingleValueConstraint(0,2,1,)).subtype(namedValues=NamedValues(("discarding", 0), ("learning", 1), ("forwarding", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortStateTransitionSemState.setDescription("Current state of the Port State Transition State Machine          \nfor this port in this spanning tree context.")
jnxMIMstCistPortTopologyChangeSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 39), Integer().subtype(subtypeSpec=SingleValueConstraint(4,0,1,5,2,6,7,3,)).subtype(namedValues=NamedValues(("init", 0), ("inactive", 1), ("active", 2), ("detected", 3), ("notifiedtcn", 4), ("notifiedtc", 5), ("propagating", 6), ("acknowledged", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortTopologyChangeSemState.setDescription("Current state of the Topology Change State Machine          \nfor this port in this spanning tree context.")
jnxMIMstCistPortHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 40), Timeout().subtype(subtypeSpec=ValueRangeConstraint(100, 1000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortHelloTime.setDescription("The amount of time between the transmission of\nConfiguration bridge PDUs by this node on this port\nin units of hundredths of a second.")
jnxMIMstCistPortOperVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 41), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,2,)).subtype(namedValues=NamedValues(("stpCompatible", 0), ("rstp", 2), ("mstp", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortOperVersion.setDescription("This indicates whether the Port is operationally in the Mstp\nmode, Rstp mode or the Stp-compatible mode i.e., whether the\nPort is transmitting MST BPDUs, RST BPDUs or Config/TCN BPDUs.")
jnxMIMstCistPortEffectivePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 42), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortEffectivePortState.setDescription("The effective operational state of the port for CIST. This will\nTRUE only when the port is operationally up in the Interface level\nand Protocol level for CIST. This is will be set to False for all \nother times.")
jnxMIMstCistPortAutoEdgeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 6, 1, 43), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortAutoEdgeStatus.setDescription("This parameter when TRUE(1) indicates that detection \nof a port as Edge Port happens automatically\nand FALSE(2) indicates that this feature is disabled.")
jnxMIMstMstiPortTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7))
if mibBuilder.loadTexts: jnxMIMstMstiPortTable.setDescription("This table contains Spanning Tree Instance Specific Port\nInformation.")
jnxMIMstMstiPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIMstMstiPort"), (0, "JUNIPER-MIMSTP-MIB", "jnxMIMstInstanceIndex"))
if mibBuilder.loadTexts: jnxMIMstMstiPortEntry.setDescription("A list of information maintained by every port for each \nand every spanning tree instance.")
jnxMIMstMstiPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMIMstMstiPort.setDescription("The Port number of the port for which this entry contains   \nspanning tree information.")
jnxMIMstMstiPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortPathCost.setDescription("The contribution of this port to the path cost of\npaths towards the MSTI Root which include this port.")
jnxMIMstMstiPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240)).clone(128)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortPriority.setDescription("The four most significant bits of the Port Identifier \nfor a given Spanning Tree instance can be modified \nindependently for each Spanning Tree instance \nsupported by the Bridge. The values that are set for Port \nPriority must be in steps of 16.")
jnxMIMstMstiPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 4), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortDesignatedRoot.setDescription("The unique Bridge Identifier of the bridge recorded as the  \nMSTI Regional Root in the configuration BPDUs transmitted.")
jnxMIMstMstiPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortDesignatedBridge.setDescription("The unique Bridge Identifier of the bridge which this port  \nconsiders to be the Designated Bridge for the port's segment.")
jnxMIMstMstiPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortDesignatedPort.setDescription("The Port identifier of the port on the Designated Bridge    \nfor this port's segment.")
jnxMIMstMstiPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,5,4,)).subtype(namedValues=NamedValues(("disabled", 1), ("discarding", 2), ("learning", 4), ("forwarding", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortState.setDescription("Current state of the Port as defined by the Multiple  \nspanning tree protocol. Port which is Forwarding state\nin one instance can be in Discarding (Blocking) state \nin another instance.")
jnxMIMstMstiForcePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiForcePortState.setDescription("Current state of the Port which can be changed to either \nDisabled or Enabled for the specific spanning tree   \ninstance. This object can be set to enabled only if the \n'jnxMIMstCistForcePortState' is set to 'enabled' for this port")
jnxMIMstMstiPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortForwardTransitions.setDescription("Number of times this port has transitioned to the     \nForwarding State for specific instance.")
jnxMIMstMstiPortReceivedBPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortReceivedBPDUs.setDescription("Number of BPDUs received by this port for this \nspanning tree instance.")
jnxMIMstMstiPortTransmittedBPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortTransmittedBPDUs.setDescription("Number of BPDUs transmitted on this port for \nthis spanning tree instance.")
jnxMIMstMstiPortInvalidBPDUsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortInvalidBPDUsRcvd.setDescription("Number of Invalid BPDUs received on this Port\nfor this spanning tree instance.")
jnxMIMstMstiPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortDesignatedCost.setDescription("The path cost of the Designated Port of the\nsegment connected to this port.")
jnxMIMstMstiSelectedPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,4,0,5,3,)).subtype(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4), ("master", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiSelectedPortRole.setDescription("Selected Port Role of the port for this spanning \ntree instance.")
jnxMIMstMstiCurrentPortRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 15), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,4,0,5,3,)).subtype(namedValues=NamedValues(("disabled", 0), ("alternate", 1), ("backup", 2), ("root", 3), ("designated", 4), ("master", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiCurrentPortRole.setDescription("Current Port Role of the port for this spanning \ntree instance.")
jnxMIMstMstiPortInfoSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 16), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,2,8,9,1,5,7,4,6,)).subtype(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("aged", 2), ("update", 3), ("superiordesg", 4), ("repeatdesg", 5), ("root", 6), ("other", 7), ("present", 8), ("receive", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortInfoSemState.setDescription("Current state of the Port Information State Machine          \nfor this port in this spanning tree context.")
jnxMIMstMstiPortRoleTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 17), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,1,2,)).subtype(namedValues=NamedValues(("init", 0), ("blockport", 1), ("blockedport", 2), ("activeport", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortRoleTransitionSemState.setDescription("Current state of the Port Role Transition State Machine          \nfor this port in this spanning tree context.")
jnxMIMstMstiPortStateTransitionSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 18), Integer().subtype(subtypeSpec=SingleValueConstraint(0,2,1,)).subtype(namedValues=NamedValues(("discarding", 0), ("learning", 1), ("forwarding", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortStateTransitionSemState.setDescription("Current state of the Port State Transition State Machine          \nfor this port in this spanning tree context.")
jnxMIMstMstiPortTopologyChangeSemState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 19), Integer().subtype(subtypeSpec=SingleValueConstraint(4,0,1,5,2,6,7,3,)).subtype(namedValues=NamedValues(("init", 0), ("inactive", 1), ("active", 2), ("detected", 3), ("notifiedtcn", 4), ("notifiedtc", 5), ("propagating", 6), ("acknowledged", 7), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortTopologyChangeSemState.setDescription("Current state of the Topology Change State Machine          \nfor this port in this spanning tree context.")
jnxMIMstMstiPortEffectivePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 7, 1, 20), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortEffectivePortState.setDescription("The effective operational stae of the port for specific instance.\nThis is will be TRUE only when the port is operationally up in the\ninterface level and Protocol level for the specific instance.\nThis is will be set to false at all other times.")
jnxMIMstCistPortProtectTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 8))
if mibBuilder.loadTexts: jnxMIMstCistPortProtectTable.setDescription("Defines the jnxMIMstCist Port Table for providing extensions \nfor Root Protect and Loop Protect to the corresponding \njnxMIMstCistPortTable entry.")
jnxMIMstCistPortProtectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 8, 1))
if mibBuilder.loadTexts: jnxMIMstCistPortProtectEntry.setDescription("Defines an entry in the jnxMIMstCistPortProtectTable.  This essentially\naugments the jnxMIMstCistPortEntry with additional objects.")
jnxMIMstCistPortRootProtectEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 8, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRootProtectEnabled.setDescription("A Boolean value set by management indicating whether Root protect \nfunctionality is enabled on the port. If TRUE causes the Port not\nto be selected as Root Port for the CIST or any MSTI, even it has\nthe best spanning tree priority vector. This parameter should be \nFALSE by default. ")
jnxMIMstCistPortRootProtectState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 8, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("no-error", 0), ("root-prevented", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortRootProtectState.setDescription("Indicates whether the port was prevented from being a root port \nfor CIST. This parameter will always return 'no-error (0)' if \njnxMIMstCistPortRootProtectEnabled is FALSE. ")
jnxMIMstCistPortLoopProtectEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 8, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortLoopProtectEnabled.setDescription("A Boolean value set by management indicating whether Loop protect \nfunctionality is enabled on the port. If TRUE causes the Port not\nto be selected as Designated Port for the CIST or any MSTI, when\nthe received superior BPDU is aged out. This parameter should be \nFALSE by default. ")
jnxMIMstCistPortLoopProtectState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 8, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("no-error", 0), ("loop-prevented", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstCistPortLoopProtectState.setDescription("Indicates whether a potential Loop was prevented on the port for CIST.\nThis parameter will always return 'no-error (0)' if \njnxMIMstCistPortLoopProtectEnabled is FALSE. ")
jnxMIMstMstiPortProtectTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 9))
if mibBuilder.loadTexts: jnxMIMstMstiPortProtectTable.setDescription("Defines the jnxMIMstMsti Port Table for providing extensions \nfor Root Protect and Loop Protect to the corresponding \njnxMIMstMstiPortTable entry.")
jnxMIMstMstiPortProtectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 9, 1))
if mibBuilder.loadTexts: jnxMIMstMstiPortProtectEntry.setDescription("Defines an entry in the jnxMIMstMstiPortProtectTable.  This essentially\naugments the jnxMIMstMstiPortEntry with additional objects.")
jnxMIMstMstiPortRootProtectState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 9, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("no-error", 0), ("root-prevented", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortRootProtectState.setDescription("Indicates whether the port was prevented from being a root port \nfor CIST. This parameter will always return 'no-error (0)' if \njnxMIMstCistPortRootProtectEnabled is FALSE. ")
jnxMIMstMstiPortLoopProtectState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 1, 9, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("no-error", 0), ("loop-prevented", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstMstiPortLoopProtectState.setDescription("Indicates whether a potential Loop was prevented on the port for CIST.\nThis parameter will always return 'no-error (0)' if \njnxMIMstCistPortLoopProtectEnabled is FALSE. ")
jnxMIDot1sJnxMstTrapsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2))
jnxMIDot1sJnxMstSetGlobalTrapOption = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIDot1sJnxMstSetGlobalTrapOption.setDescription("This object is used to enable and disable MSTP traps for memory\nfailure or buffer failure irrespective of the context in which\nthe failure occurs.\n0 - Traps are not enabled.\n1 - Memory and buffer failure traps enabled")
jnxMIMstGlobalErrTrapType = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(0,2,1,)).subtype(namedValues=NamedValues(("none", 0), ("memfail", 1), ("bufffail", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstGlobalErrTrapType.setDescription("Used within the Trap Notification PDU. \nIt denotes general events like \nnone - none of the below values\nmemfail - memory allocation failure\nbufffail - buffer allocation failure")
jnxMIDot1sJnxMstTrapsControlTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 3))
if mibBuilder.loadTexts: jnxMIDot1sJnxMstTrapsControlTable.setDescription("List of per virtual bridge Trap Control Info.")
jnxMIDot1sJnxMstTrapsControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 3, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIDot1sJuniperMstContextId"))
if mibBuilder.loadTexts: jnxMIDot1sJnxMstTrapsControlEntry.setDescription("Virtual bridge TrapsControl information.")
jnxMIMstSetTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstSetTraps.setDescription("This object is used to enable and  disable context-specific\nMSTP traps. Currently the following are defined\n0 - Traps are not enabled.\n1 - General Traps like protocol up or down \n2 - Exception Traps like port protocol migration or \ninvalid packet rcvd in port\n3 - All the above Traps ")
jnxMIMstGenTrapType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,0,1,)).subtype(namedValues=NamedValues(("none", 0), ("up", 1), ("down", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstGenTrapType.setDescription("Used within the Trap Notification PDU. \nIt denotes general events like \nnone - none of the below values\nup - protocol UP,\ndown - protocol DOWN")
jnxMIMstPortTrapNotificationTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 4))
if mibBuilder.loadTexts: jnxMIMstPortTrapNotificationTable.setDescription("This table is used to store the notification information\noccured in each of the port for protocol migration and \ninvalid packet received. This table is maintained per virtual\ncontext in the system.")
jnxMIMstPortTrapNotificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 4, 1)).setIndexNames((0, "JUNIPER-MIMSTP-MIB", "jnxMIMstPortTrapIndex"))
if mibBuilder.loadTexts: jnxMIMstPortTrapNotificationEntry.setDescription(" This entry is used to store the notification information")
jnxMIMstPortTrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstPortTrapIndex.setDescription("A unique value, greater than zero, indicating the Port number.")
jnxMIMstPortMigrationType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("sendstp", 0), ("sendrstp", 1), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstPortMigrationType.setDescription("Port Protocol migration type occured in the port")
jnxMIMstPktErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 4, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,5,7,6,4,8,0,)).subtype(namedValues=NamedValues(("protocolIdErr", 0), ("invalidBpdu", 1), ("configLengthErr", 2), ("tcnLengthErr", 3), ("rstpLengthErr", 4), ("maxAgeErr", 5), ("fwdDelayErr", 6), ("helloTimeErr", 7), ("mstpLengthErr", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstPktErrType.setDescription("Type of invalid packet received in each of the port ")
jnxMIMstPktErrVal = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMIMstPktErrVal.setDescription("Packet error value corresponding to the above type ")
jnxMIDot1sJuniperMstTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3))
jnxMIMstTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0))

# Augmentions
jnxMIMstCistPortEntry.registerAugmentions(("JUNIPER-MIMSTP-MIB", "jnxMIMstCistPortProtectEntry"))
jnxMIMstCistPortProtectEntry.setIndexNames(*jnxMIMstCistPortEntry.getIndexNames())
jnxMIMstMstiPortEntry.registerAugmentions(("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiPortProtectEntry"))
jnxMIMstMstiPortProtectEntry.setIndexNames(*jnxMIMstMstiPortEntry.getIndexNames())

# Notifications

jnxMIMstGenTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 1)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstGenTrapType"), ) )
if mibBuilder.loadTexts: jnxMIMstGenTrap.setDescription("Generated when any of the general events like protocol up or \nprotocol down occurs")
jnxMIMstErrTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 2)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstGlobalErrTrapType"), ) )
if mibBuilder.loadTexts: jnxMIMstErrTrap.setDescription("Generated when any of the error events like memory failure or buffer failure\nor protocol migration or new root or topology change occurs ")
jnxMIMstNewRootTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 3)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstOldDesignatedRoot"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiInstanceIndex"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiBridgeRegionalRoot"), ) )
if mibBuilder.loadTexts: jnxMIMstNewRootTrap.setDescription("Generated whenever a new root bridge is selected in the topology. \nThe jnxMIMstNewRootTrap indicates that the sending agent has become \nthe new root of the Spanning Tree; the trap is sent by a bridge soon \nafter its election as the new root")
jnxMIMstTopologyChgTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 4)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiInstanceIndex"), ) )
if mibBuilder.loadTexts: jnxMIMstTopologyChgTrap.setDescription("Generated when topology change is detected ")
jnxMIMstProtocolMigrationTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 5)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstPortMigrationType"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstForceProtocolVersion"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstPortTrapIndex"), ) )
if mibBuilder.loadTexts: jnxMIMstProtocolMigrationTrap.setDescription("Generated when port protocol migration happens in the port ")
jnxMIMstInvalidBpduRxdTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 6)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstPktErrType"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstPktErrVal"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstPortTrapIndex"), ) )
if mibBuilder.loadTexts: jnxMIMstInvalidBpduRxdTrap.setDescription("Generated when the invalid packet is received for \nbpdu/stp/rstp/maximum age/forward delay/hello time")
jnxMIMstRegionConfigChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 7)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiRegionName"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiRegionVersion"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiConfigIdSel"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiConfigDigest"), ) )
if mibBuilder.loadTexts: jnxMIMstRegionConfigChangeTrap.setDescription("Generated when the MST region's configuration     \nidentifier changes.")
jnxMIMstCistPortRootProtectStateChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 8)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstCistPortRootProtectState"), ) )
if mibBuilder.loadTexts: jnxMIMstCistPortRootProtectStateChangeTrap.setDescription("Generated when the ports Root-protect state (no-error or root-prevented) \nfor CIST changes.")
jnxMIMstMstiPortRootProtectStateChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 9)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiPortRootProtectState"), ) )
if mibBuilder.loadTexts: jnxMIMstMstiPortRootProtectStateChangeTrap.setDescription("Generated when the ports Root-protect state (no-error or root-prevented) \nan MSTI changes.")
jnxMIMstCistPortLoopProtectStateChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 10)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstCistPortLoopProtectState"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ) )
if mibBuilder.loadTexts: jnxMIMstCistPortLoopProtectStateChangeTrap.setDescription("Generated when the ports Loop-protect state (no-error or loop-prevented) \nfor CIST changes.")
jnxMIMstMstiPortLoopProtectStateChangeTrap = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 46, 1, 3, 0, 11)).setObjects(*(("JUNIPER-MIMSTP-MIB", "jnxMIMstMstiPortLoopProtectState"), ("JUNIPER-MIMSTP-MIB", "jnxMIMstBrgAddress"), ) )
if mibBuilder.loadTexts: jnxMIMstMstiPortLoopProtectStateChangeTrap.setDescription("Generated when the ports Loop-protect state (no-error or loop-prevented) \nan MSTI changes.")

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-MIMSTP-MIB", PYSNMP_MODULE_ID=jnxMIMstMIB)

# Types
mibBuilder.exportSymbols("JUNIPER-MIMSTP-MIB", BridgeId=BridgeId, EnabledStatus=EnabledStatus, Timeout=Timeout, VlanId=VlanId)

# Objects
mibBuilder.exportSymbols("JUNIPER-MIMSTP-MIB", jnxMIMstMIB=jnxMIMstMIB, jnxMIDot1sJuniperMst=jnxMIDot1sJuniperMst, jnxMIMstGlobalTrace=jnxMIMstGlobalTrace, jnxMIMstGlobalDebug=jnxMIMstGlobalDebug, jnxMIDot1sJuniperMstTable=jnxMIDot1sJuniperMstTable, jnxMIDot1sJuniperMstEntry=jnxMIDot1sJuniperMstEntry, jnxMIDot1sJuniperMstContextId=jnxMIDot1sJuniperMstContextId, jnxMIMstSystemControl=jnxMIMstSystemControl, jnxMIMstModuleStatus=jnxMIMstModuleStatus, jnxMIMstMaxMstInstanceNumber=jnxMIMstMaxMstInstanceNumber, jnxMIMstNoOfMstiSupported=jnxMIMstNoOfMstiSupported, jnxMIMstMaxHopCount=jnxMIMstMaxHopCount, jnxMIMstBrgAddress=jnxMIMstBrgAddress, jnxMIMstCistRoot=jnxMIMstCistRoot, jnxMIMstCistRegionalRoot=jnxMIMstCistRegionalRoot, jnxMIMstCistRootCost=jnxMIMstCistRootCost, jnxMIMstCistRegionalRootCost=jnxMIMstCistRegionalRootCost, jnxMIMstCistRootPort=jnxMIMstCistRootPort, jnxMIMstCistBridgePriority=jnxMIMstCistBridgePriority, jnxMIMstCistBridgeMaxAge=jnxMIMstCistBridgeMaxAge, jnxMIMstCistBridgeForwardDelay=jnxMIMstCistBridgeForwardDelay, jnxMIMstCistHoldTime=jnxMIMstCistHoldTime, jnxMIMstCistMaxAge=jnxMIMstCistMaxAge, jnxMIMstCistForwardDelay=jnxMIMstCistForwardDelay, jnxMIMstMstpUpCount=jnxMIMstMstpUpCount, jnxMIMstMstpDownCount=jnxMIMstMstpDownCount, jnxMIMstPathCostDefaultType=jnxMIMstPathCostDefaultType, jnxMIMstTrace=jnxMIMstTrace, jnxMIMstDebug=jnxMIMstDebug, jnxMIMstForceProtocolVersion=jnxMIMstForceProtocolVersion, jnxMIMstTxHoldCount=jnxMIMstTxHoldCount, jnxMIMstMstiConfigIdSel=jnxMIMstMstiConfigIdSel, jnxMIMstMstiRegionName=jnxMIMstMstiRegionName, jnxMIMstMstiRegionVersion=jnxMIMstMstiRegionVersion, jnxMIMstMstiConfigDigest=jnxMIMstMstiConfigDigest, jnxMIMstBufferOverFlowCount=jnxMIMstBufferOverFlowCount, jnxMIMstMemAllocFailureCount=jnxMIMstMemAllocFailureCount, jnxMIMstRegionConfigChangeCount=jnxMIMstRegionConfigChangeCount, jnxMIMstCistBridgeRoleSelectionSemState=jnxMIMstCistBridgeRoleSelectionSemState, jnxMIMstCistTimeSinceTopologyChange=jnxMIMstCistTimeSinceTopologyChange, jnxMIMstCistTopChanges=jnxMIMstCistTopChanges, jnxMIMstCistNewRootBridgeCount=jnxMIMstCistNewRootBridgeCount, jnxMIMstCistHelloTime=jnxMIMstCistHelloTime, jnxMIMstCistBridgeHelloTime=jnxMIMstCistBridgeHelloTime, jnxMIMstCistDynamicPathcostCalculation=jnxMIMstCistDynamicPathcostCalculation, jnxMIMstMstiBridgeTable=jnxMIMstMstiBridgeTable, jnxMIMstMstiBridgeEntry=jnxMIMstMstiBridgeEntry, jnxMIMstMstiInstanceIndex=jnxMIMstMstiInstanceIndex, jnxMIMstMstiBridgeRegionalRoot=jnxMIMstMstiBridgeRegionalRoot, jnxMIMstMstiBridgePriority=jnxMIMstMstiBridgePriority, jnxMIMstMstiRootCost=jnxMIMstMstiRootCost, jnxMIMstMstiRootPort=jnxMIMstMstiRootPort, jnxMIMstMstiTimeSinceTopologyChange=jnxMIMstMstiTimeSinceTopologyChange, jnxMIMstMstiTopChanges=jnxMIMstMstiTopChanges, jnxMIMstMstiNewRootBridgeCount=jnxMIMstMstiNewRootBridgeCount, jnxMIMstMstiBridgeRoleSelectionSemState=jnxMIMstMstiBridgeRoleSelectionSemState, jnxMIMstInstanceUpCount=jnxMIMstInstanceUpCount, jnxMIMstInstanceDownCount=jnxMIMstInstanceDownCount, jnxMIMstOldDesignatedRoot=jnxMIMstOldDesignatedRoot, jnxMIMstVlanInstanceMappingTable=jnxMIMstVlanInstanceMappingTable, jnxMIMstVlanInstanceMappingEntry=jnxMIMstVlanInstanceMappingEntry, jnxMIMstInstanceIndex=jnxMIMstInstanceIndex, jnxMIMstMapVlanIndex=jnxMIMstMapVlanIndex, jnxMIMstUnMapVlanIndex=jnxMIMstUnMapVlanIndex, jnxMIMstSetVlanList=jnxMIMstSetVlanList, jnxMIMstResetVlanList=jnxMIMstResetVlanList, jnxMIMstInstanceVlanMapped=jnxMIMstInstanceVlanMapped, jnxMIMstInstanceVlanMapped2k=jnxMIMstInstanceVlanMapped2k, jnxMIMstInstanceVlanMapped3k=jnxMIMstInstanceVlanMapped3k, jnxMIMstInstanceVlanMapped4k=jnxMIMstInstanceVlanMapped4k, jnxMIMstCistPortTable=jnxMIMstCistPortTable, jnxMIMstCistPortEntry=jnxMIMstCistPortEntry, jnxMIMstCistPort=jnxMIMstCistPort, jnxMIMstCistPortPathCost=jnxMIMstCistPortPathCost, jnxMIMstCistPortPriority=jnxMIMstCistPortPriority, jnxMIMstCistPortDesignatedRoot=jnxMIMstCistPortDesignatedRoot, jnxMIMstCistPortDesignatedBridge=jnxMIMstCistPortDesignatedBridge, jnxMIMstCistPortDesignatedPort=jnxMIMstCistPortDesignatedPort, jnxMIMstCistPortAdminP2P=jnxMIMstCistPortAdminP2P, jnxMIMstCistPortOperP2P=jnxMIMstCistPortOperP2P, jnxMIMstCistPortAdminEdgeStatus=jnxMIMstCistPortAdminEdgeStatus, jnxMIMstCistPortOperEdgeStatus=jnxMIMstCistPortOperEdgeStatus, jnxMIMstCistPortProtocolMigration=jnxMIMstCistPortProtocolMigration, jnxMIMstCistPortState=jnxMIMstCistPortState, jnxMIMstCistForcePortState=jnxMIMstCistForcePortState, jnxMIMstCistPortForwardTransitions=jnxMIMstCistPortForwardTransitions, jnxMIMstCistPortRxMstBpduCount=jnxMIMstCistPortRxMstBpduCount, jnxMIMstCistPortRxRstBpduCount=jnxMIMstCistPortRxRstBpduCount, jnxMIMstCistPortRxConfigBpduCount=jnxMIMstCistPortRxConfigBpduCount, jnxMIMstCistPortRxTcnBpduCount=jnxMIMstCistPortRxTcnBpduCount, jnxMIMstCistPortTxMstBpduCount=jnxMIMstCistPortTxMstBpduCount, jnxMIMstCistPortTxRstBpduCount=jnxMIMstCistPortTxRstBpduCount, jnxMIMstCistPortTxConfigBpduCount=jnxMIMstCistPortTxConfigBpduCount, jnxMIMstCistPortTxTcnBpduCount=jnxMIMstCistPortTxTcnBpduCount, jnxMIMstCistPortInvalidMstBpduRxCount=jnxMIMstCistPortInvalidMstBpduRxCount, jnxMIMstCistPortInvalidRstBpduRxCount=jnxMIMstCistPortInvalidRstBpduRxCount, jnxMIMstCistPortInvalidConfigBpduRxCount=jnxMIMstCistPortInvalidConfigBpduRxCount, jnxMIMstCistPortInvalidTcnBpduRxCount=jnxMIMstCistPortInvalidTcnBpduRxCount, jnxMIMstCistPortTransmitSemState=jnxMIMstCistPortTransmitSemState, jnxMIMstCistPortReceiveSemState=jnxMIMstCistPortReceiveSemState, jnxMIMstCistPortProtMigrationSemState=jnxMIMstCistPortProtMigrationSemState, jnxMIMstCistProtocolMigrationCount=jnxMIMstCistProtocolMigrationCount, jnxMIMstCistPortDesignatedCost=jnxMIMstCistPortDesignatedCost, jnxMIMstCistPortRegionalRoot=jnxMIMstCistPortRegionalRoot, jnxMIMstCistPortRegionalPathCost=jnxMIMstCistPortRegionalPathCost, jnxMIMstCistSelectedPortRole=jnxMIMstCistSelectedPortRole, jnxMIMstCistCurrentPortRole=jnxMIMstCistCurrentPortRole, jnxMIMstCistPortInfoSemState=jnxMIMstCistPortInfoSemState, jnxMIMstCistPortRoleTransitionSemState=jnxMIMstCistPortRoleTransitionSemState, jnxMIMstCistPortStateTransitionSemState=jnxMIMstCistPortStateTransitionSemState, jnxMIMstCistPortTopologyChangeSemState=jnxMIMstCistPortTopologyChangeSemState, jnxMIMstCistPortHelloTime=jnxMIMstCistPortHelloTime, jnxMIMstCistPortOperVersion=jnxMIMstCistPortOperVersion, jnxMIMstCistPortEffectivePortState=jnxMIMstCistPortEffectivePortState, jnxMIMstCistPortAutoEdgeStatus=jnxMIMstCistPortAutoEdgeStatus, jnxMIMstMstiPortTable=jnxMIMstMstiPortTable, jnxMIMstMstiPortEntry=jnxMIMstMstiPortEntry, jnxMIMstMstiPort=jnxMIMstMstiPort, jnxMIMstMstiPortPathCost=jnxMIMstMstiPortPathCost, jnxMIMstMstiPortPriority=jnxMIMstMstiPortPriority, jnxMIMstMstiPortDesignatedRoot=jnxMIMstMstiPortDesignatedRoot, jnxMIMstMstiPortDesignatedBridge=jnxMIMstMstiPortDesignatedBridge, jnxMIMstMstiPortDesignatedPort=jnxMIMstMstiPortDesignatedPort, jnxMIMstMstiPortState=jnxMIMstMstiPortState, jnxMIMstMstiForcePortState=jnxMIMstMstiForcePortState, jnxMIMstMstiPortForwardTransitions=jnxMIMstMstiPortForwardTransitions)
mibBuilder.exportSymbols("JUNIPER-MIMSTP-MIB", jnxMIMstMstiPortReceivedBPDUs=jnxMIMstMstiPortReceivedBPDUs, jnxMIMstMstiPortTransmittedBPDUs=jnxMIMstMstiPortTransmittedBPDUs, jnxMIMstMstiPortInvalidBPDUsRcvd=jnxMIMstMstiPortInvalidBPDUsRcvd, jnxMIMstMstiPortDesignatedCost=jnxMIMstMstiPortDesignatedCost, jnxMIMstMstiSelectedPortRole=jnxMIMstMstiSelectedPortRole, jnxMIMstMstiCurrentPortRole=jnxMIMstMstiCurrentPortRole, jnxMIMstMstiPortInfoSemState=jnxMIMstMstiPortInfoSemState, jnxMIMstMstiPortRoleTransitionSemState=jnxMIMstMstiPortRoleTransitionSemState, jnxMIMstMstiPortStateTransitionSemState=jnxMIMstMstiPortStateTransitionSemState, jnxMIMstMstiPortTopologyChangeSemState=jnxMIMstMstiPortTopologyChangeSemState, jnxMIMstMstiPortEffectivePortState=jnxMIMstMstiPortEffectivePortState, jnxMIMstCistPortProtectTable=jnxMIMstCistPortProtectTable, jnxMIMstCistPortProtectEntry=jnxMIMstCistPortProtectEntry, jnxMIMstCistPortRootProtectEnabled=jnxMIMstCistPortRootProtectEnabled, jnxMIMstCistPortRootProtectState=jnxMIMstCistPortRootProtectState, jnxMIMstCistPortLoopProtectEnabled=jnxMIMstCistPortLoopProtectEnabled, jnxMIMstCistPortLoopProtectState=jnxMIMstCistPortLoopProtectState, jnxMIMstMstiPortProtectTable=jnxMIMstMstiPortProtectTable, jnxMIMstMstiPortProtectEntry=jnxMIMstMstiPortProtectEntry, jnxMIMstMstiPortRootProtectState=jnxMIMstMstiPortRootProtectState, jnxMIMstMstiPortLoopProtectState=jnxMIMstMstiPortLoopProtectState, jnxMIDot1sJnxMstTrapsControl=jnxMIDot1sJnxMstTrapsControl, jnxMIDot1sJnxMstSetGlobalTrapOption=jnxMIDot1sJnxMstSetGlobalTrapOption, jnxMIMstGlobalErrTrapType=jnxMIMstGlobalErrTrapType, jnxMIDot1sJnxMstTrapsControlTable=jnxMIDot1sJnxMstTrapsControlTable, jnxMIDot1sJnxMstTrapsControlEntry=jnxMIDot1sJnxMstTrapsControlEntry, jnxMIMstSetTraps=jnxMIMstSetTraps, jnxMIMstGenTrapType=jnxMIMstGenTrapType, jnxMIMstPortTrapNotificationTable=jnxMIMstPortTrapNotificationTable, jnxMIMstPortTrapNotificationEntry=jnxMIMstPortTrapNotificationEntry, jnxMIMstPortTrapIndex=jnxMIMstPortTrapIndex, jnxMIMstPortMigrationType=jnxMIMstPortMigrationType, jnxMIMstPktErrType=jnxMIMstPktErrType, jnxMIMstPktErrVal=jnxMIMstPktErrVal, jnxMIDot1sJuniperMstTraps=jnxMIDot1sJuniperMstTraps, jnxMIMstTraps=jnxMIMstTraps)

# Notifications
mibBuilder.exportSymbols("JUNIPER-MIMSTP-MIB", jnxMIMstGenTrap=jnxMIMstGenTrap, jnxMIMstErrTrap=jnxMIMstErrTrap, jnxMIMstNewRootTrap=jnxMIMstNewRootTrap, jnxMIMstTopologyChgTrap=jnxMIMstTopologyChgTrap, jnxMIMstProtocolMigrationTrap=jnxMIMstProtocolMigrationTrap, jnxMIMstInvalidBpduRxdTrap=jnxMIMstInvalidBpduRxdTrap, jnxMIMstRegionConfigChangeTrap=jnxMIMstRegionConfigChangeTrap, jnxMIMstCistPortRootProtectStateChangeTrap=jnxMIMstCistPortRootProtectStateChangeTrap, jnxMIMstMstiPortRootProtectStateChangeTrap=jnxMIMstMstiPortRootProtectStateChangeTrap, jnxMIMstCistPortLoopProtectStateChangeTrap=jnxMIMstCistPortLoopProtectStateChangeTrap, jnxMIMstMstiPortLoopProtectStateChangeTrap=jnxMIMstMstiPortLoopProtectStateChangeTrap)

