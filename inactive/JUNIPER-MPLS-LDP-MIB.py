# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-MPLS-LDP-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:54 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InterfaceIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
( InetAddress, InetAddressType, InetPortNumber, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetPortNumber")
( jnxMibs, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
( MplsLabel, MplsLabelDistributionMethod, MplsLdpIdentifier, MplsLdpLabelType, MplsLspType, MplsLsrIdentifier, MplsRetentionMode, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsLabel", "MplsLabelDistributionMethod", "MplsLdpIdentifier", "MplsLdpLabelType", "MplsLspType", "MplsLsrIdentifier", "MplsRetentionMode")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( RowPointer, RowStatus, StorageType, TimeInterval, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "RowStatus", "StorageType", "TimeInterval", "TimeStamp", "TruthValue")

# Objects

jnxMplsLdpMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 36)).setRevisions(("2006-05-16 12:00",))
if mibBuilder.loadTexts: jnxMplsLdpMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxMplsLdpMIB.setContactInfo("    Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxMplsLdpMIB.setDescription("This MIB contains managed object definitions for the\n'Multiprotocol Label Switching, Label Distribution\nProtocol, LDP' document.")
jnxMplsLdpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1))
jnxMplsLdpLsrObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 1))
jnxMplsLdpLsrId = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 1, 1), MplsLsrIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLsrId.setDescription("The LSR's Identifier.")
jnxMplsLdpLsrLoopDetectionCapable = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,5,3,)).subtype(namedValues=NamedValues(("none", 1), ("other", 2), ("hopCount", 3), ("pathVector", 4), ("hopCountAndPathVector", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLsrLoopDetectionCapable.setDescription("A indication of whether this\nLabel Switching Router supports\nloop detection.\n\nnone(1) -- Loop Detection is not supported\n           on this LSR.\n\nother(2) -- Loop Detection is supported but\n            by a method other than those\n            listed below.\n\nhopCount(3) -- Loop Detection is supported by\n               Hop Count only.\n\npathVector(4) -- Loop Detection is supported by\n                Path Vector only.\n\nhopCountAndPathVector(5) -- Loop Detection is\n                     supported by both Hop Count\n                     And Path Vector.\n\nSince Loop Detection is determined during\nSession Initialization, an individual session\nmay not be running with loop detection.  This\nobject simply gives an indication of whether or not the\nLSR has the ability to support Loop Detection and\nwhich types.")
jnxMplsLdpEntityObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2))
jnxMplsLdpEntityLastChange = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityLastChange.setDescription("The value of sysUpTime at the time of the most\nrecent addition or deletion of an entry\nto the jnxMplsLdpEntityTable/jnxMplsLdpEntityStatsTable.\n\nIf no such changes have occurred since the last\n\nre-initialization of the local management subsystem,\nthen this object contains a zero value.")
jnxMplsLdpEntityIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityIndexNext.setDescription("This object contains an appropriate value to\nbe used for jnxMplsLdpEntityIndex when creating\nentries in the jnxMplsLdpEntityTable. The value\n0 indicates that no unassigned entries are\navailable. To obtain the jnxMplsLdpEntityIndex\nvalue for a new entry, the manager issues a\nmanagement protocol retrieval operation to obtain\nthe current value of this object.  After each\nretrieval, the agent should modify the value to\nthe next unassigned index.")
jnxMplsLdpEntityTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3))
if mibBuilder.loadTexts: jnxMplsLdpEntityTable.setDescription("This table contains information about the\nMPLS Label Distribution Protocol Entities which\nexist on this Label Switching Router (LSR).")
jnxMplsLdpEntityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndex"))
if mibBuilder.loadTexts: jnxMplsLdpEntityEntry.setDescription("An entry in this table represents an LDP entity.\nAn entry can be created by a network administrator\nor by an SNMP agent as instructed by LDP.")
jnxMplsLdpEntityLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 1), MplsLdpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpEntityLdpId.setDescription("The LDP identifier.")
jnxMplsLdpEntityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpEntityIndex.setDescription("This index is used as a secondary index to uniquely\nidentify this row.  Before creating a row in this table,\nthe 'jnxMplsLdpEntityIndexNext' object should be retrieved.\nThat value should be used for the value of this index\nwhen creating a row in this table.  (NOTE:  if a value\nof zero (0) is retrieved, that indicates that no rows\ncan be created in this table at this time.\n\nA secondary index (this object) is meaningful to some\nbut not all, LDP implementations.  For example\nin an LDP implementation which uses PPP would\nuse this index to differentiate PPP sub-links.\n\nAnother way to use this index is to give this the\nvalue of ifIndex.  However, this is dependant\non the implementation.")
jnxMplsLdpEntityProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityProtocolVersion.setDescription("The version number of the LDP protocol which will be\nused in the session initialization message.\n\nSection 3.5.3 in the LDP Specification specifies\nthat the version of the LDP protocol is negotiated during\nsession establishment. The value of this object\nrepresents the value that is sent in the initialization\nmessage.")
jnxMplsLdpEntityAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityAdminStatus.setDescription("The administrative status of this LDP Entity.\nIf this object is changed from 'enable' to 'disable'\nand this entity has already attempted to establish\ncontact with a Peer, then all contact with that\nPeer is lost and all information from that Peer\nneeds to be removed from the MIB. (This implies\nthat the network management subsystem should clean\nup any related entry in the jnxMplsLdpPeerTable).\n\nAt this point the user is able to change values\nwhich are related to this entity.\n\nWhen the admin status is set back to 'up', then\nthis Entity will attempt to establish a new session\nwith the Peer.")
jnxMplsLdpEntityOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("unknown", 1), ("enabled", 2), ("disabled", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityOperStatus.setDescription("The operational status of this LDP Entity.")
jnxMplsLdpEntityTcpDscPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 6), InetPortNumber().clone('646')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityTcpDscPort.setDescription("The TCP Discovery Port for\nLDP.  The default value is the well-known\nvalue of this port.")
jnxMplsLdpEntityUdpDscPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 7), InetPortNumber().clone('646')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityUdpDscPort.setDescription("The UDP Discovery Port for\nLDP.  The default value is the\nwell-known value for this port.")
jnxMplsLdpEntityMaxPduLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(256, 65535)).clone(4096)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityMaxPduLength.setDescription("The maximum PDU Length that is sent in\nthe Common Session Parameters of an Initialization\nMessage. According to the LDP Specification [RFC3036]\na value of 255 or less specifies the\ndefault maximum length of 4096 octets, this is why\nthe value of this object starts at 256.  The operator\nshould explicitely choose the default value (i.e. 4096),\nor some other value.\n\nThe receiving LSR MUST calculate the maximum PDU\nlength for the session by using the smaller of its and\nits peer's proposals for Max PDU Length.")
jnxMplsLdpEntityKeepAliveHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityKeepAliveHoldTimer.setDescription("The 16-bit integer value which is the proposed keep\nalive hold timer for this LDP Entity.")
jnxMplsLdpEntityHelloHoldTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityHelloHoldTimer.setDescription("The 16-bit integer value which is the proposed Hello\nhold timer for this LDP Entity. The Hello Hold time\nin seconds.\n\nAn LSR maintains a record of Hellos received\nfrom potential peers.  This object represents\nthe Hold Time in the Common Hello Parameters TLV of\nthe Hello Message.\n\nA value of 0 is a default value and should be\ninterpretted in conjunction with the\njnxMplsLdpEntityTargetPeer object.\n\nIf the value of this object is 0: if the value of the\njnxMplsLdpEntityTargetPeer object is false(2), then this\n\nspecifies that the Hold Time's actual default value is\n15 seconds (i.e. the default Hold time for Link Hellos\nis 15 seconds).  Otherwise if the value of the\njnxMplsLdpEntityTargetPeer object is true(1), then this\nspecifies that the Hold Time's actual default value is\n45 seconds (i.e. the default Hold time for Targeted\nHellos is 45 seconds).\n\nA value of 65535 means infinite (i.e. wait forever).\n\nAll other values represent the amount of time in\nseconds to wait for a Hello Message.  Setting the\nhold time to a value smaller than 15 is not\nrecommended, although not forbidden according\nto [RFC3036].")
jnxMplsLdpEntityInitSesThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityInitSesThreshold.setDescription("When attempting to establish a session with a\ngiven Peer, the given LDP Entity should\nsend out the SNMP notification,\n'jnxMplsLdpInitSesThresholdExceeded', when\nthe number of Session Initialization messages sent\nexceeds this threshold.  The notification is\nused to notify an operator when this Entity and\nits Peer are possibily engaged in an endless\nsequence of messages as each NAKs the other's\nInitialization messages with Error Notification\nmessages.  Setting this threshold which triggers\nthe notification is one way to\nnotify the operator.\n\nA value of 0 (zero) for this object\nindicates that the threshold is infinity, thus\nthe SNMP notification will never be generated.")
jnxMplsLdpEntityLabelDistMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 12), MplsLabelDistributionMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityLabelDistMethod.setDescription("For any given LDP session, the method of\nlabel distribution must be specified.")
jnxMplsLdpEntityLabelRetentionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 13), MplsRetentionMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityLabelRetentionMode.setDescription("The LDP Entity can be configured to use either\nconservative or liberal label retention mode.\n\nIf the value of this object is conservative(1)\nthen advertized label mappings are retained\nonly if they will be used to forward packets,\ni.e. if label came from a valid next hop.\n\nIf the value of this object is liberal(2)\nthen all advertized label mappings are retained\nwhether they are from a valid next hop or not.")
jnxMplsLdpEntityPathVectorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityPathVectorLimit.setDescription("If the value of this object is 0 (zero) then\nLoop Dection for Path Vectors is disabled.\n\nOtherwise, if this object has a value greater than\nzero, then Loop Dection for Path Vectors is enabled,\nand the Path Vector Limit is this value.\nAlso, the value of the object,\n'jnxMplsLdpLsrLoopDetectionCapable', must be set to\neither 'pathVector(4)' or 'hopCountAndPathVector(5)',\nif this object has a value greater than 0 (zero),\notherwise it is ignored.")
jnxMplsLdpEntityHopCountLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityHopCountLimit.setDescription("If the value of this object is 0 (zero),\nthen Loop Detection using Hop Counters is\ndisabled.\n\nIf the value of this object is greater than\n0 (zero) then Loop Detection using Hop\nCounters is enabled, and this object\nspecifies this Entity's maximum allowable\nvalue for the Hop Count.\nAlso, the value of the object\njnxMplsLdpLsrLoopDetectionCapable must be set\nto either 'hopCount(3)' or\n'hopCountAndPathVector(5)' if this object\nhas a value greater than 0 (zero), otherwise\nit is ignored.")
jnxMplsLdpEntityTargetPeer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 16), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityTargetPeer.setDescription("If this LDP entity uses targeted peer then set\nthis to true.")
jnxMplsLdpEntityTargetPeerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 17), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityTargetPeerAddrType.setDescription("The type of the internetwork layer address used for\nthe Extended Discovery. This object indicates how\nthe value of jnxMplsLdpEntityTargetPeerAddr is to\nbe interpreted.")
jnxMplsLdpEntityTargetPeerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityTargetPeerAddr.setDescription("The value of the internetwork layer address used for\nthe Extended Discovery.")
jnxMplsLdpEntityLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 19), MplsLdpLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityLabelType.setDescription("Specifies the optional parameters for the LDP\nInitialization Message.  If the value is generic(1)\nthen no optional parameters will be sent in\nthe LDP Initialization message associated with\nthis Entity.\n\nIf the value is atmParameters(2) then\na row must be created in the jnxMplsLdpEntityAtmParms\nTable, which corresponds to this entry.\n\nIf the value is frameRelayParameters(3) then\na row must be created in the jnxMplsLdpEntityFrameRelayParms\nTable, which corresponds to this entry.")
jnxMplsLdpEntityDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 20), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion\nat which any one or more of this entity's counters\nsuffered a discontinuity.  The relevant counters are the\nspecific instances associated with this entity of\nany Counter32, or Counter64 object contained\nin the 'jnxMplsLdpEntityStatsTable'.  If no such\ndiscontinuities have occurred since the last\nre-initialization of the local management\nsubsystem, then this object contains a zero\nvalue.")
jnxMplsLdpEntityStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 21), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityStorageType.setDescription("The storage type for this entry.")
jnxMplsLdpEntityRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 3, 1, 22), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpEntityRowStatus.setDescription("An object that allows entries in this table to\nbe created and deleted using the\nRowStatus convention.")
jnxMplsLdpEntityStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4))
if mibBuilder.loadTexts: jnxMplsLdpEntityStatsTable.setDescription("This table is a read-only table which augments\nthe jnxMplsLdpEntityTable.  The purpose of this\ntable is to keep statistical information about\nthe LDP Entities on the LSR.")
jnxMplsLdpEntityStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1))
if mibBuilder.loadTexts: jnxMplsLdpEntityStatsEntry.setDescription("A row in this table contains statistical information\nabout an LDP Entity.  Some counters contained in a\nrow are for fatal errors received during a former\nLDP Session associated with this entry.  For example,\nan Ldp Pdu received on a TCP connection during an\nLDP Session contains a fatal error.  That\nerror is counted here, because the\nsession is terminated.\n\nIf the error is NOT fatal (i.e. and the Session\nremains), then the error is counted in the\njnxMplsLdpSesStatsEntry.")
jnxMplsLdpAttemptedSessions = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpAttemptedSessions.setDescription("A count of the total attempted sessions for\nthis LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpSesRejectedNoHelloErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesRejectedNoHelloErrors.setDescription("A count of the Session Rejected/No Hello Error\nNotification Messages sent or received by\nthis LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpSesRejectedAdErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesRejectedAdErrors.setDescription("A count of the Session Rejected/Parameters\nAdvertisement Mode Error Notification Messages sent\nor received by this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpSesRejectedMaxPduErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesRejectedMaxPduErrors.setDescription("A count of the Session Rejected/Parameters\nMax Pdu Length Error Notification Messages sent\nor received by this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpSesRejectedLRErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesRejectedLRErrors.setDescription("A count of the Session Rejected/Parameters\nLabel Range Notification Messages sent\nor received by this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpBadLdpIdentifierErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpBadLdpIdentifierErrors.setDescription("This object counts the number of Bad LDP Identifier\nFatal Errors detected by the session(s)\n(past and present) associated with this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpBadPduLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpBadPduLengthErrors.setDescription("This object counts the number of Bad Pdu Length\nFatal Errors detected by the session(s)\n(past and present) associated with this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpBadMessageLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpBadMessageLengthErrors.setDescription("This object counts the number of Bad Message\nLength Fatal Errors detected by the session(s)\n(past and present) associated with this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpBadTlvLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpBadTlvLengthErrors.setDescription("This object counts the number of Bad TLV\nLength Fatal Errors detected by the session(s)\n(past and present) associated with this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\n\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpMalformedTlvValueErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpMalformedTlvValueErrors.setDescription("This object counts the number of Malformed TLV\nValue Fatal Errors detected by the session(s)\n(past and present) associated with this\nLDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpKeepAliveTimerExpErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpKeepAliveTimerExpErrors.setDescription("This object counts the number of Session Keep Alive\nTimer Expired Errors detected by the session(s)\n(past and present) associated with this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpShutdownNotifReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpShutdownNotifReceived.setDescription("This object counts the number of Shutdown Notfications\nreceived related to session(s) (past and present)\nassociated with this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\n\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpShutdownNotifSent = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 2, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpShutdownNotifSent.setDescription("This object counts the number of Shutdown Notfications\nsent related to session(s) (past and present) associated\nwith this LDP Entity.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpEntityDiscontinuityTime.")
jnxMplsLdpSessionObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3))
jnxMplsLdpPeerLastChange = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpPeerLastChange.setDescription("The value of sysUpTime at the time of the most\nrecent addition or deletion to the\njnxMplsLdpPeerTable/jnxMplsLdpSessionTable.")
jnxMplsLdpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 2))
if mibBuilder.loadTexts: jnxMplsLdpPeerTable.setDescription("Information about LDP peers known by Entities in\nthe jnxMplsLdpEntityTable.  The information in this table\nis based on information from the Entity-Peer interaction\nduring session initialization but is not appropriate\nfor the jnxMplsLdpSessionTable, because objects in this\ntable may or may not be used in session establishment.")
jnxMplsLdpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 2, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLdpId"))
if mibBuilder.loadTexts: jnxMplsLdpPeerEntry.setDescription("Information about a single Peer which is related\nto a Session.  NOTE:  this table is augmented by\nthe jnxMplsLdpSessionTable.")
jnxMplsLdpPeerLdpId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 2, 1, 1), MplsLdpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpPeerLdpId.setDescription("The LDP identifier of this LDP Peer.")
jnxMplsLdpPeerLabelDistMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 2, 1, 2), MplsLabelDistributionMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpPeerLabelDistMethod.setDescription("For any given LDP session, the method of\nlabel distribution must be specified.")
jnxMplsLdpPeerPathVectorLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpPeerPathVectorLimit.setDescription("If the value of this object is 0 (zero) then\nLoop Dection for Path Vectors for this Peer\nis disabled.\n\nOtherwise, if this object has a value greater than\nzero, then Loop Dection for Path  Vectors for this\nPeer is enabled and the Path Vector Limit is this value.")
jnxMplsLdpSessionTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3))
if mibBuilder.loadTexts: jnxMplsLdpSessionTable.setDescription("A table of Sessions between the LDP Entities and\nLDP Peers.  Each row represents a single session.")
jnxMplsLdpSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1))
if mibBuilder.loadTexts: jnxMplsLdpSessionEntry.setDescription("An entry in this table represents information on a\nsingle session between an LDP Entity and LDP Peer.\nThe information contained in a row is read-only.\n\nPlease note:  the Path Vector Limit for the\nSession is the value which is configured in\nthe corresponding jnxMplsLdpEntityEntry. The\nPeer's Path Vector Limit is in noted in the\njnxMplsLdpPeerTable.\n\nValues which may differ from those configured are\nnoted in the objects of this table, the\njnxMplsLdpAtmSesTable and the\njnxMplsLdpFrameRelaySesTable. A value will\ndiffer if it was negotiated between the\nEntity and the Peer. Values may or may not\nbe negotiated. For example, if the values\nare the same then no negotiation takes place.\nIf they are negotiated, then they may differ.")
jnxMplsLdpSesStateLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesStateLastChange.setDescription("The value of this object is sysUpTime when the\nmost recent change in the jnxMplsLdpSesState\nobject occurred.  When the entry is created, then\nthis object has the value of sysUpTime when the\nentry was created.")
jnxMplsLdpSesState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,4,1,5,2,)).subtype(namedValues=NamedValues(("nonexistent", 1), ("initialized", 2), ("openrec", 3), ("opensent", 4), ("operational", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesState.setDescription("The current state of the session, all of the\nstates 1 to 5 are based on the state machine for\nsession negotiation behavior.")
jnxMplsLdpSesProtocolVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesProtocolVersion.setDescription("The version of the LDP Protocol which\nthis session is using.  This is the version of\nthe LDP protocol which has been negotiated during\nsession initialization.")
jnxMplsLdpSesKeepAliveHoldTimeRem = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1, 4), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesKeepAliveHoldTimeRem.setDescription("The keep alive hold time remaining for this session.")
jnxMplsLdpSesMaxPduLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesMaxPduLength.setDescription("The value of maximum allowable length for LDP PDUs for\nthis session.  This value may have been negotiated during\nthe Session Initialization.  This object is related to\nthe jnxMplsLdpEntityMaxPduLength object.  The\njnxMplsLdpEntityMaxPduLength object specifies the requested\nLDP PDU length, and this object reflects the negotiated\nLDP PDU length between the Entity and\nthe Peer.")
jnxMplsLdpSesDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 3, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\nwhich any one or more of this session's counters\nsuffered a discontinuity.  The relevant counters are\nthe specific instances associated with this session\nof any Counter32 or Counter64 object contained in the\njnxMplsLdpSessionStatsTable.\n\nThe initial value of this object is the value of\nsysUpTime when the entry was created in this table.\n\nAlso, a command generator can distinguish when a session\nbetween a given Entity and Peer goes away and then is\n're-established'.  This value would change and\nthus indicate to the command generator that this is a\ndifferent session.")
jnxMplsLdpSesStatsTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 4))
if mibBuilder.loadTexts: jnxMplsLdpSesStatsTable.setDescription("A table of statistics for Sessions between\nLDP Entities and LDP Peers.")
jnxMplsLdpSesStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 4, 1))
if mibBuilder.loadTexts: jnxMplsLdpSesStatsEntry.setDescription("An entry in this table represents statistical\ninformation on a single session between an LDP\nEntity and LDP Peer.")
jnxMplsLdpSesStatsUnkMesTypeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesStatsUnkMesTypeErrors.setDescription("This object counts the number of Unknown Message Type\nErrors detected during this session.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\njnxMplsLdpSesDiscontinuityTime.")
jnxMplsLdpSesStatsUnkTlvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesStatsUnkTlvErrors.setDescription("This object counts the number of Unknown TLV Errors\ndetected during this session.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\n\njnxMplsLdpSessionDiscontinuityTime.")
jnxMplsLdpHelloAdjacencyObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 5))
jnxMplsLdpHelloAdjacencyTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 5, 1))
if mibBuilder.loadTexts: jnxMplsLdpHelloAdjacencyTable.setDescription("A table of Hello Adjacencies for Sessions.")
jnxMplsLdpHelloAdjacencyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 5, 1, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpHelloAdjIndex"))
if mibBuilder.loadTexts: jnxMplsLdpHelloAdjacencyEntry.setDescription("Each row represents a single LDP Hello Adjacency.\nAn LDP Session can have one or more Hello adjacencies.")
jnxMplsLdpHelloAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpHelloAdjIndex.setDescription("An identifier for this specific adjacency.")
jnxMplsLdpHelloAdjHoldTimeRem = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 5, 1, 1, 2), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpHelloAdjHoldTimeRem.setDescription("The time remaining for this Hello Adjacency.\nThis interval will change when the 'next'\nHello message which corresponds to this\nHello Adjacency is received.")
jnxMplsLdpHelloAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 5, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("link", 1), ("targeted", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpHelloAdjType.setDescription("This adjacency is the result of a 'link'\nhello if the value of this object is link(1).\nOtherwise, it is a result of a 'targeted'\nhello, targeted(2).")
jnxMplsLdpLspTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6))
if mibBuilder.loadTexts: jnxMplsLdpLspTable.setDescription("A table of LDP LSP's which\nmap to a Segment Table in the\nthe LSR MIB's (either the mplsInSegmentTable\nor mplsOutSegmentTable) AND to the\nLSR MIB's mplsXCTable.")
jnxMplsLdpLspEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspIfIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspLabel"))
if mibBuilder.loadTexts: jnxMplsLdpLspEntry.setDescription("An entry in this table represents information on a\nsingle LDP LSP which is represented by\na session's index triple (jnxMplsLdpEntityLdpId,\njnxMplsLdpEntityIndex, jnxMplsLdpPeerLdpId) AND the\nindex tuple (jnxMplsLdpLspIfIndex, jnxMplsLdpLspLabel).\n\nThe information contained in a row is read-only.")
jnxMplsLdpLspIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpLspIfIndex.setDescription("The ifIndex value associated with this LSP.")
jnxMplsLdpLspLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 2), MplsLabel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpLspLabel.setDescription("The LDP label for this LSP.")
jnxMplsLdpLspLabelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 3), MplsLdpLabelType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspLabelType.setDescription("The Layer 2 Label Type.")
jnxMplsLdpLspType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 4), MplsLspType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspType.setDescription("The type of LSP connection.\nThe possible values are:\n\n   unknown(1)         --  if the LSP is not known\n                          to be one of the following.\n\n  terminatingLsp(2)   -- if the LSP terminates\n                         on the LSR, then this\n                         is an ingressing LSP\n                         which ends on the LSR,\n\n  originatingLsp(3)   -- if the LSP originates\n                         from the LSR, then this\n                         is an egressing LSP which is\n                         the head-end of the LSP,\n\ncrossConnectingLsp(4) -- if the LSP ingresses\n                         and egresses on the LSR,\n                         then it is cross-connecting\n                         on that LSR.")
jnxMplsLdpLspLsrInSegmentPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspLsrInSegmentPointer.setDescription("If this LSP terminates or is cross-connecting\non this LSR, then this RowPointer should point\nto an instance of an object in the\nmplsLsrInSegmentTable. In other words if\nthe value of jnxMplsLdpLspType is\nterminatingLsp(2) or crossConnectingLsp(4),\nthen this should point to an instance of an object\nin the LSR-MIB's mplsInSegmentTable.\n\nOtherwise, a value of zeroDotzero indicates that\nthis LSP has no corresponding mplsInSegmentEntry.")
jnxMplsLdpLspLsrOutSegmentPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 6), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspLsrOutSegmentPointer.setDescription("If this LSP originates or is cross-connecting\non this LSR, then this RowPointer should point\nto an instance of an object in the LSR-MIB's\nmplsOutSegmentTable. In other words if\nthe value of jnxMplsLdpLspType is\noriginatingLsp(3) or crossConnectingLsp(4),\nthen this should point to an instance of an object\nin the LSR-MIB's mplsOutSegmentTable.\n\nOtherwise, a value of zeroDotzero indicates that\nthis LSP has no corresponding mplsOutSegmentEntry.")
jnxMplsLdpLspLsrXCPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 6, 1, 7), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspLsrXCPointer.setDescription("If this LSP is cross-connecting on this LSR,\nthen this RowPointer should point\nto an instance of an object in the\nLSR-MIB's mplsXCTable. In other words if\nthe value of jnxMplsLdpLspType is crossConnectingLsp(4),\nthen this should point to an instance of an object\nin the LSR-MIB's mplsXCTable.\n\nOtherwise, a value of zeroDotzero indicates that\nthis LSP has no corresponding mplsXCEntry.")
jnxMplsFecObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7))
jnxMplsFecIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecIndexNext.setDescription("This object contains an appropriate value to\nbe used for jnxMplsFecIndex when creating\nentries in the jnxMplsFecTable. The value\n0 indicates that no unassigned entries are\navailable. To obtain the jnxMplsFecIndex\nvalue for a new entry, the manager issues a\nmanagement protocol retrieval operation to obtain\nthe current value of this object.  After each\nretrieval, the agent should modify the value to\nthe next unassigned index.")
jnxMplsFecTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2))
if mibBuilder.loadTexts: jnxMplsFecTable.setDescription("This table represents the FEC\n(Forwarding Equivalence Class)\nInformation associated with an LSP.")
jnxMplsFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsFecIndex"))
if mibBuilder.loadTexts: jnxMplsFecEntry.setDescription("Each row represents a single FEC Element.")
jnxMplsFecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsFecIndex.setDescription("The index which uniquely identifies this entry.")
jnxMplsFecType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("prefix", 1), ("hostAddress", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecType.setDescription("The type of the FEC.  If the value of this object\nis 'prefix(1)' then the FEC type described by this\nrow is for address prefixes.\n\nIf the value of this object is 'hostAddress(2)' then\nthe FEC type described by this row is a host address.")
jnxMplsFecAddrLength = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecAddrLength.setDescription("If the value of 'jnxMplsFecType' is 'prefix(1)'\nthen the value of this object is the length in\nbits of the address prefix represented by\n'jnxMplsFecAddr', or if the length is zero then\nthis is a special value which indicates that the\nprefix matches all addresses.  In this case the\nprefix is also zero (i.e. 'jnxMplsFecAddr' will\nhave the value of zero.)")
jnxMplsFecAddrFamily = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecAddrFamily.setDescription("The value of this object is from the Address Family\nNumbers.")
jnxMplsFecAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecAddr.setDescription("If the value of 'jnxMplsFecType' is 'prefix(1)'\nthen the value of this object is the address prefix.\nIf the value of the 'jnxMplsFecAddrLength'\nis object is zero, then this object should also be\nzero.\n\nIf the value of the 'jnxMplsFecType' is 'hostAddress(2)'\nthen this is the host address.")
jnxMplsFecStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 6), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecStorageType.setDescription("The storage type for this entry.")
jnxMplsFecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 7, 2, 1, 7), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsFecRowStatus.setDescription("An object that allows entries in this table to\nbe created and deleted using the\nRowStatus convention.")
jnxMplsLdpLspFecTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 8))
if mibBuilder.loadTexts: jnxMplsLdpLspFecTable.setDescription("A table which shows the relationship between\nLDP LSP's and FECs.  Each row represents\na single LSP to FEC association.\nThis table is read-only.")
jnxMplsLdpLspFecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 8, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspIfIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspLabel"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsFecIndex"))
if mibBuilder.loadTexts: jnxMplsLdpLspFecEntry.setDescription("An entry represents a LDP LSP\nto FEC association.")
jnxMplsLdpLspFecOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 8, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("unknown", 1), ("inUse", 2), ("notInUse", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspFecOperStatus.setDescription("An indication of the operational status of\nthe FEC associated with LDP LSP.\n\nunknown(1) - this is a temporary state which\n             may indicate the LSP-FEC association\n             is in a state of transition.\n\ninUse(2) - the FEC associated with the LSP is\n           currently being applied.\n\nnotInUse(3) - the FEC associated with the LSP is\n              not being applied.  Eventually, this\n              entry may be aged out.")
jnxMplsLdpLspFecLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 8, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspFecLastChange.setDescription("This value of sysUpTime when the\njnxMplsLdpLspFecOperStatus last changed state.")
jnxMplsLdpLspFecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 8, 1, 3), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpLspFecRowStatus.setDescription("An object that allows entries in this table to\nbe created and deleted using the\nRowStatus convention.")
jnxMplsLdpSesPeerAddrTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 9))
if mibBuilder.loadTexts: jnxMplsLdpSesPeerAddrTable.setDescription("This table 'extends' the jnxMplsLdpSessionTable.\nThis table is used to store Label Address Information\nfrom Label Address Messages received by this LSR from\nPeers.  This table is read-only and should be updated\nwhen Label Withdraw Address Messages are received, i.e.\nRows should be deleted as apropriate.\n\nNOTE:  since more than one address may be contained\nin a Label Address Message, this table 'extends',\nrather than 'AUGMENTS' the jnxMplsLdpSessionTable's\ninformation.")
jnxMplsLdpSesPeerAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 9, 1)).setIndexNames((0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndex"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLdpId"), (0, "JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesPeerAddrIndex"))
if mibBuilder.loadTexts: jnxMplsLdpSesPeerAddrEntry.setDescription("An entry in this table represents information on\nsession's for a single next hop address which was\nadvertised in an Address Message from the LDP peer.\nThe information contained in a row is read-only.")
jnxMplsLdpSesPeerAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxMplsLdpSesPeerAddrIndex.setDescription("An index which uniquely identifies this entry within\na given session.")
jnxMplsLdpSesPeerNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 9, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesPeerNextHopAddrType.setDescription("The internetwork layer address type of this Next Hop\nAddress as specified in the Label Address Message\nassociated with this Session. The value of this\nobject indicates how to interpret the value of\njnxMplsLdpSessionPeerNextHopAddress.")
jnxMplsLdpSesPeerNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 36, 1, 3, 9, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMplsLdpSesPeerNextHopAddr.setDescription("The value of the next hop address.")
jnxMplsLdpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 2))
jnxMplsLdpNotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 2, 0))
jnxMplsLdpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3))
jnxMplsLdpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 1))
jnxMplsLdpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 2))

# Augmentions
jnxMplsLdpPeerEntry.registerAugmentions(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSessionEntry"))
jnxMplsLdpSessionEntry.setIndexNames(*jnxMplsLdpPeerEntry.getIndexNames())
jnxMplsLdpEntityEntry.registerAugmentions(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityStatsEntry"))
jnxMplsLdpEntityStatsEntry.setIndexNames(*jnxMplsLdpEntityEntry.getIndexNames())
jnxMplsLdpPeerEntry.registerAugmentions(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsEntry"))
jnxMplsLdpSesStatsEntry.setIndexNames(*jnxMplsLdpPeerEntry.getIndexNames())

# Notifications

jnxMplsLdpInitSesThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 36, 2, 0, 1)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityInitSesThreshold"), ) )
if mibBuilder.loadTexts: jnxMplsLdpInitSesThresholdExceeded.setDescription("This notification is generated when the value of\nthe 'jnxMplsLdpEntityInitSesThreshold' object\nis not zero, and the number of Session\nInitialization messages exceeds the value\nof the 'jnxMplsLdpEntityInitSesThreshold' object.")
jnxMplsLdpPathVectorLimitMismatch = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 36, 2, 0, 2)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerPathVectorLimit"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityPathVectorLimit"), ) )
if mibBuilder.loadTexts: jnxMplsLdpPathVectorLimitMismatch.setDescription("If this notification is enabled to generated,\n\nthen this notification is sent when the\n'jnxMplsLdpEntityPathVectorLimit' does NOT match\nthe value of the 'jnxMplsLdpPeerPathVectorLimit' for\na specific Entity.")
jnxMplsLdpSessionUp = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 36, 2, 0, 3)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesState"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsUnkMesTypeErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsUnkTlvErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesDiscontinuityTime"), ) )
if mibBuilder.loadTexts: jnxMplsLdpSessionUp.setDescription("If this notification is enabled to generated,\nthen this notification is sent when the\nvalue of 'jnxMplsLdpSesState' enters\nthe 'operational(5)' state.")
jnxMplsLdpSessionDown = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 36, 2, 0, 4)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesState"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsUnkMesTypeErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsUnkTlvErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesDiscontinuityTime"), ) )
if mibBuilder.loadTexts: jnxMplsLdpSessionDown.setDescription("If this notification is enabled to generated,\nthen this notification is sent when the\nthe value of 'jnxMplsLdpSesState' leaves\nthe 'operational(5)' state.")

# Groups

jnxMplsLdpGeneralGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 1, 1)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecStorageType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityTargetPeerAddr"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityUdpDscPort"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspFecRowStatus"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecIndexNext"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesKeepAliveHoldTimeRem"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityTargetPeer"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesProtocolVersion"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpMalformedTlvValueErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityKeepAliveHoldTimer"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLastChange"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecAddr"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspFecOperStatus"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityDiscontinuityTime"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityProtocolVersion"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityAdminStatus"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityPathVectorLimit"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerLabelDistMethod"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityHelloHoldTimer"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsUnkMesTypeErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityTargetPeerAddrType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesDiscontinuityTime"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityRowStatus"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLabelDistMethod"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesRejectedAdErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityStorageType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesRejectedMaxPduErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesState"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpHelloAdjType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpBadPduLengthErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityIndexNext"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLabelRetentionMode"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpBadLdpIdentifierErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityHopCountLimit"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpShutdownNotifSent"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesRejectedNoHelloErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPeerPathVectorLimit"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpShutdownNotifReceived"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLabelType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecAddrLength"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpBadTlvLengthErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityOperStatus"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLsrId"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpBadMessageLengthErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpKeepAliveTimerExpErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityInitSesThreshold"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesMaxPduLength"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStateLastChange"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesPeerNextHopAddr"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLsrLoopDetectionCapable"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspFecLastChange"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecRowStatus"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityTcpDscPort"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityMaxPduLength"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesPeerNextHopAddrType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsFecAddrFamily"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesRejectedLRErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpHelloAdjHoldTimeRem"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpAttemptedSessions"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSesStatsUnkTlvErrors"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpEntityLastChange"), ) )
if mibBuilder.loadTexts: jnxMplsLdpGeneralGroup.setDescription("Objects that apply to all MPLS LDP implementations.")
jnxMplsLdpLspGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 1, 2)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspLabelType"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspType"), ) )
if mibBuilder.loadTexts: jnxMplsLdpLspGroup.setDescription("These objects are specific to LDP LSPs.")
jnxMplsLdpLsrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 1, 3)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspLsrOutSegmentPointer"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspLsrXCPointer"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspLsrInSegmentPointer"), ) )
if mibBuilder.loadTexts: jnxMplsLdpLsrGroup.setDescription("These objects are optional and only need to be supported\nfor LDP implementations which support the following\ntables in the LSR MIB: mplsInSegmentTable,\nmplsOutSegmentTable and mplsXCTable.")
jnxMplsLdpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 1, 4)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpPathVectorLimitMismatch"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSessionUp"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpSessionDown"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpInitSesThresholdExceeded"), ) )
if mibBuilder.loadTexts: jnxMplsLdpNotificationsGroup.setDescription("The notification(s) which an MPLS LDP implemention\nis required to implement.")

# Compliances

jnxMplsLdpModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 2, 1)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspGroup"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpNotificationsGroup"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLsrGroup"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpGeneralGroup"), ) )
if mibBuilder.loadTexts: jnxMplsLdpModuleFullCompliance.setDescription("The Module is implemented with support\nfor read-create and read-write.  In other\nwords, both monitoring and configuration\nare available when using this MODULE-COMPLIANCE.")
jnxMplsLdpModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 3, 36, 3, 2, 2)).setObjects(*(("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLspGroup"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpNotificationsGroup"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpLsrGroup"), ("JUNIPER-MPLS-LDP-MIB", "jnxMplsLdpGeneralGroup"), ) )
if mibBuilder.loadTexts: jnxMplsLdpModuleReadOnlyCompliance.setDescription("The Module is implemented with support\nfor read-only.  In other words, only monitoring\nis available by implementing this MODULE-COMPLIANCE.")

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-MPLS-LDP-MIB", PYSNMP_MODULE_ID=jnxMplsLdpMIB)

# Objects
mibBuilder.exportSymbols("JUNIPER-MPLS-LDP-MIB", jnxMplsLdpMIB=jnxMplsLdpMIB, jnxMplsLdpObjects=jnxMplsLdpObjects, jnxMplsLdpLsrObjects=jnxMplsLdpLsrObjects, jnxMplsLdpLsrId=jnxMplsLdpLsrId, jnxMplsLdpLsrLoopDetectionCapable=jnxMplsLdpLsrLoopDetectionCapable, jnxMplsLdpEntityObjects=jnxMplsLdpEntityObjects, jnxMplsLdpEntityLastChange=jnxMplsLdpEntityLastChange, jnxMplsLdpEntityIndexNext=jnxMplsLdpEntityIndexNext, jnxMplsLdpEntityTable=jnxMplsLdpEntityTable, jnxMplsLdpEntityEntry=jnxMplsLdpEntityEntry, jnxMplsLdpEntityLdpId=jnxMplsLdpEntityLdpId, jnxMplsLdpEntityIndex=jnxMplsLdpEntityIndex, jnxMplsLdpEntityProtocolVersion=jnxMplsLdpEntityProtocolVersion, jnxMplsLdpEntityAdminStatus=jnxMplsLdpEntityAdminStatus, jnxMplsLdpEntityOperStatus=jnxMplsLdpEntityOperStatus, jnxMplsLdpEntityTcpDscPort=jnxMplsLdpEntityTcpDscPort, jnxMplsLdpEntityUdpDscPort=jnxMplsLdpEntityUdpDscPort, jnxMplsLdpEntityMaxPduLength=jnxMplsLdpEntityMaxPduLength, jnxMplsLdpEntityKeepAliveHoldTimer=jnxMplsLdpEntityKeepAliveHoldTimer, jnxMplsLdpEntityHelloHoldTimer=jnxMplsLdpEntityHelloHoldTimer, jnxMplsLdpEntityInitSesThreshold=jnxMplsLdpEntityInitSesThreshold, jnxMplsLdpEntityLabelDistMethod=jnxMplsLdpEntityLabelDistMethod, jnxMplsLdpEntityLabelRetentionMode=jnxMplsLdpEntityLabelRetentionMode, jnxMplsLdpEntityPathVectorLimit=jnxMplsLdpEntityPathVectorLimit, jnxMplsLdpEntityHopCountLimit=jnxMplsLdpEntityHopCountLimit, jnxMplsLdpEntityTargetPeer=jnxMplsLdpEntityTargetPeer, jnxMplsLdpEntityTargetPeerAddrType=jnxMplsLdpEntityTargetPeerAddrType, jnxMplsLdpEntityTargetPeerAddr=jnxMplsLdpEntityTargetPeerAddr, jnxMplsLdpEntityLabelType=jnxMplsLdpEntityLabelType, jnxMplsLdpEntityDiscontinuityTime=jnxMplsLdpEntityDiscontinuityTime, jnxMplsLdpEntityStorageType=jnxMplsLdpEntityStorageType, jnxMplsLdpEntityRowStatus=jnxMplsLdpEntityRowStatus, jnxMplsLdpEntityStatsTable=jnxMplsLdpEntityStatsTable, jnxMplsLdpEntityStatsEntry=jnxMplsLdpEntityStatsEntry, jnxMplsLdpAttemptedSessions=jnxMplsLdpAttemptedSessions, jnxMplsLdpSesRejectedNoHelloErrors=jnxMplsLdpSesRejectedNoHelloErrors, jnxMplsLdpSesRejectedAdErrors=jnxMplsLdpSesRejectedAdErrors, jnxMplsLdpSesRejectedMaxPduErrors=jnxMplsLdpSesRejectedMaxPduErrors, jnxMplsLdpSesRejectedLRErrors=jnxMplsLdpSesRejectedLRErrors, jnxMplsLdpBadLdpIdentifierErrors=jnxMplsLdpBadLdpIdentifierErrors, jnxMplsLdpBadPduLengthErrors=jnxMplsLdpBadPduLengthErrors, jnxMplsLdpBadMessageLengthErrors=jnxMplsLdpBadMessageLengthErrors, jnxMplsLdpBadTlvLengthErrors=jnxMplsLdpBadTlvLengthErrors, jnxMplsLdpMalformedTlvValueErrors=jnxMplsLdpMalformedTlvValueErrors, jnxMplsLdpKeepAliveTimerExpErrors=jnxMplsLdpKeepAliveTimerExpErrors, jnxMplsLdpShutdownNotifReceived=jnxMplsLdpShutdownNotifReceived, jnxMplsLdpShutdownNotifSent=jnxMplsLdpShutdownNotifSent, jnxMplsLdpSessionObjects=jnxMplsLdpSessionObjects, jnxMplsLdpPeerLastChange=jnxMplsLdpPeerLastChange, jnxMplsLdpPeerTable=jnxMplsLdpPeerTable, jnxMplsLdpPeerEntry=jnxMplsLdpPeerEntry, jnxMplsLdpPeerLdpId=jnxMplsLdpPeerLdpId, jnxMplsLdpPeerLabelDistMethod=jnxMplsLdpPeerLabelDistMethod, jnxMplsLdpPeerPathVectorLimit=jnxMplsLdpPeerPathVectorLimit, jnxMplsLdpSessionTable=jnxMplsLdpSessionTable, jnxMplsLdpSessionEntry=jnxMplsLdpSessionEntry, jnxMplsLdpSesStateLastChange=jnxMplsLdpSesStateLastChange, jnxMplsLdpSesState=jnxMplsLdpSesState, jnxMplsLdpSesProtocolVersion=jnxMplsLdpSesProtocolVersion, jnxMplsLdpSesKeepAliveHoldTimeRem=jnxMplsLdpSesKeepAliveHoldTimeRem, jnxMplsLdpSesMaxPduLength=jnxMplsLdpSesMaxPduLength, jnxMplsLdpSesDiscontinuityTime=jnxMplsLdpSesDiscontinuityTime, jnxMplsLdpSesStatsTable=jnxMplsLdpSesStatsTable, jnxMplsLdpSesStatsEntry=jnxMplsLdpSesStatsEntry, jnxMplsLdpSesStatsUnkMesTypeErrors=jnxMplsLdpSesStatsUnkMesTypeErrors, jnxMplsLdpSesStatsUnkTlvErrors=jnxMplsLdpSesStatsUnkTlvErrors, jnxMplsLdpHelloAdjacencyObjects=jnxMplsLdpHelloAdjacencyObjects, jnxMplsLdpHelloAdjacencyTable=jnxMplsLdpHelloAdjacencyTable, jnxMplsLdpHelloAdjacencyEntry=jnxMplsLdpHelloAdjacencyEntry, jnxMplsLdpHelloAdjIndex=jnxMplsLdpHelloAdjIndex, jnxMplsLdpHelloAdjHoldTimeRem=jnxMplsLdpHelloAdjHoldTimeRem, jnxMplsLdpHelloAdjType=jnxMplsLdpHelloAdjType, jnxMplsLdpLspTable=jnxMplsLdpLspTable, jnxMplsLdpLspEntry=jnxMplsLdpLspEntry, jnxMplsLdpLspIfIndex=jnxMplsLdpLspIfIndex, jnxMplsLdpLspLabel=jnxMplsLdpLspLabel, jnxMplsLdpLspLabelType=jnxMplsLdpLspLabelType, jnxMplsLdpLspType=jnxMplsLdpLspType, jnxMplsLdpLspLsrInSegmentPointer=jnxMplsLdpLspLsrInSegmentPointer, jnxMplsLdpLspLsrOutSegmentPointer=jnxMplsLdpLspLsrOutSegmentPointer, jnxMplsLdpLspLsrXCPointer=jnxMplsLdpLspLsrXCPointer, jnxMplsFecObjects=jnxMplsFecObjects, jnxMplsFecIndexNext=jnxMplsFecIndexNext, jnxMplsFecTable=jnxMplsFecTable, jnxMplsFecEntry=jnxMplsFecEntry, jnxMplsFecIndex=jnxMplsFecIndex, jnxMplsFecType=jnxMplsFecType, jnxMplsFecAddrLength=jnxMplsFecAddrLength, jnxMplsFecAddrFamily=jnxMplsFecAddrFamily, jnxMplsFecAddr=jnxMplsFecAddr, jnxMplsFecStorageType=jnxMplsFecStorageType, jnxMplsFecRowStatus=jnxMplsFecRowStatus, jnxMplsLdpLspFecTable=jnxMplsLdpLspFecTable, jnxMplsLdpLspFecEntry=jnxMplsLdpLspFecEntry, jnxMplsLdpLspFecOperStatus=jnxMplsLdpLspFecOperStatus, jnxMplsLdpLspFecLastChange=jnxMplsLdpLspFecLastChange, jnxMplsLdpLspFecRowStatus=jnxMplsLdpLspFecRowStatus, jnxMplsLdpSesPeerAddrTable=jnxMplsLdpSesPeerAddrTable, jnxMplsLdpSesPeerAddrEntry=jnxMplsLdpSesPeerAddrEntry, jnxMplsLdpSesPeerAddrIndex=jnxMplsLdpSesPeerAddrIndex, jnxMplsLdpSesPeerNextHopAddrType=jnxMplsLdpSesPeerNextHopAddrType, jnxMplsLdpSesPeerNextHopAddr=jnxMplsLdpSesPeerNextHopAddr, jnxMplsLdpNotifications=jnxMplsLdpNotifications, jnxMplsLdpNotificationPrefix=jnxMplsLdpNotificationPrefix, jnxMplsLdpConformance=jnxMplsLdpConformance, jnxMplsLdpGroups=jnxMplsLdpGroups, jnxMplsLdpCompliances=jnxMplsLdpCompliances)

# Notifications
mibBuilder.exportSymbols("JUNIPER-MPLS-LDP-MIB", jnxMplsLdpInitSesThresholdExceeded=jnxMplsLdpInitSesThresholdExceeded, jnxMplsLdpPathVectorLimitMismatch=jnxMplsLdpPathVectorLimitMismatch, jnxMplsLdpSessionUp=jnxMplsLdpSessionUp, jnxMplsLdpSessionDown=jnxMplsLdpSessionDown)

# Groups
mibBuilder.exportSymbols("JUNIPER-MPLS-LDP-MIB", jnxMplsLdpGeneralGroup=jnxMplsLdpGeneralGroup, jnxMplsLdpLspGroup=jnxMplsLdpLspGroup, jnxMplsLdpLsrGroup=jnxMplsLdpLsrGroup, jnxMplsLdpNotificationsGroup=jnxMplsLdpNotificationsGroup)

# Compliances
mibBuilder.exportSymbols("JUNIPER-MPLS-LDP-MIB", jnxMplsLdpModuleFullCompliance=jnxMplsLdpModuleFullCompliance, jnxMplsLdpModuleReadOnlyCompliance=jnxMplsLdpModuleReadOnlyCompliance)
