# PySNMP SMI module. Autogenerated from smidump -f python JNX-IPSEC-MONITOR-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:50 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( jnxMibs, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
( jnxSpSvcSetName, ) = mibBuilder.importSymbols("JUNIPER-SP-MIB", "jnxSpSvcSetName")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( DisplayString, TextualConvention, TimeInterval, ) = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeInterval")

# Types

class JnxAuthAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,0,4,2,)
    namedValues = NamedValues(("unknown", 0), ("hmacMd5", 2), ("hmacSha", 3), ("hmacSha256", 4), )
    
class JnxDiffHellmanGrp(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(5,19,20,0,1,14,2,)
    namedValues = NamedValues(("unknown", 0), ("modp768", 1), ("modp2048", 14), ("ecmodp256", 19), ("modp1024", 2), ("ecmodp384", 20), ("modp1536", 5), )
    
class JnxEncapMode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,0,2,)
    namedValues = NamedValues(("unknown", 0), ("tunnel", 1), ("transport", 2), )
    
class JnxEncryptAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,3,4,6,5,2,)
    namedValues = NamedValues(("espDes", 1), ("esp3des", 2), ("espNull", 3), ("espAes128", 4), ("espAes192", 5), ("espAes256", 6), )
    
class JnxIkeAuthMethod(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,5,4,3,2,)
    namedValues = NamedValues(("preSharedKey", 1), ("dssSignature", 2), ("rsaSignature", 3), ("rsaEncryption", 4), ("revRsaEncryption", 5), )
    
class JnxIkeHashAlgo(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,4,3,1,)
    namedValues = NamedValues(("md5", 1), ("sha", 2), ("sha256", 3), ("sha384", 4), )
    
class JnxIkeNegState(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("matured", 1), ("notmatured", 2), )
    
class JnxIkeNegoMode(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,2,1,)
    namedValues = NamedValues(("main", 1), ("aggressive", 2), ("ikev2", 3), )
    
class JnxIkePeerRole(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("initiator", 1), ("responder", 2), )
    
class JnxIkePeerType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,2,0,1,)
    namedValues = NamedValues(("unknown", 0), ("idIpv4Addr", 1), ("idFqdn", 2), ("idDn", 3), )
    
class JnxKeyType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,2,1,)
    namedValues = NamedValues(("unknown", 0), ("keyIke", 1), ("keyManual", 2), )
    
class JnxRemotePeerType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,2,1,)
    namedValues = NamedValues(("unknown", 0), ("static", 1), ("dynamic", 2), )
    
class JnxSAType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(0,1,2,)
    namedValues = NamedValues(("unknown", 0), ("manual", 1), ("dynamic", 2), )
    
class JnxSpi(Unsigned32):
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(256,4294967295)
    

# Objects

jnxIpSecMonitorMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 22)).setRevisions(("2012-02-10 21:00",))
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxIpSecMonitorMIB.setDescription(" ")
jnxIpSecMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1))
jnxIpSecLevels = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 1))
jnxIpSecMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecMibLevel.setDescription("The version of the IPsec MIB.")
jnxIpSecPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2))
jnxIkeTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1))
if mibBuilder.loadTexts: jnxIkeTunnelTable.setDescription("The IPsec Phase-1 Internet Key Exchange Tunnel Table.\nThere is one entry in this table for each active IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1)).setIndexNames((0, "JUNIPER-SP-MIB", "jnxSpSvcSetName"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIkeTunRemoteGwAddrType"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIkeTunRemoteGwAddr"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIkeTunIndex"))
if mibBuilder.loadTexts: jnxIkeTunnelEntry.setDescription("Each entry contains the attributes associated with\nan active IPsec Phase-1 IKE Tunnel.")
jnxIkeTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIkeTunIndex.setDescription("The index of the IPsec Phase-1 IKE Tunnel Table.\nThe value of the index is a number which begins\nat one and is incremented with each tunnel that\nis created. The value of this object will\nwrap at 2,147,483,647.")
jnxIkeTunLocalRole = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 2), JnxIkePeerRole()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalRole.setDescription("The role of local peer identity.  The Role of \nthe local peer can be:\n1. initiator.\n2. or responder.")
jnxIkeTunNegState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 3), JnxIkeNegState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunNegState.setDescription("The state of the current negotiation , It can be \n1. matured\n2. not matured ")
jnxIkeTunInitiatorCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunInitiatorCookie.setDescription("Cookie as generated by the peer that initiated the IKE Phase-1\nnegotiation. This cookie is carried in the ISAKMP header.")
jnxIkeTunResponderCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunResponderCookie.setDescription("Cookie as generated by the peer responding to the IKE Phase-1\nnegotiation initiated by the remote peer. This cookie is carried\nin the ISAKMP header.")
jnxIkeTunLocalIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 6), JnxIkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalIdType.setDescription("The type of local peer identity.  The local\npeer may be identified by:\n 1. an IP address, or\n 2. or a fully qualified domain name string.\n 3. or a distinguished name string.")
jnxIkeTunLocalIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalIdValue.setDescription("The value of the local peer identity.\n\nIf the local peer type is an IP Address, then this\nis the IP Address used to identify the local peer.\n\nIf the local peer type is id_fqdn, then this is\nthe FQDN of the remote peer.\n\nIf the local peer type is a id_dn, then this is\nthe distinguished name string of the local peer.")
jnxIkeTunLocalGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalGwAddrType.setDescription("The IP address type of the local endpoint (gateway) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunLocalGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalGwAddr.setDescription("The IP address of the local endpoint (gateway) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunLocalCertName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLocalCertName.setDescription("Name of the certificate used for authentication of the local\ntunnel endpoint. This object will have some valid value only\nif negotiated IKE authentication method is other than pre-saherd\nkey. If the IKE negotiation do not use certificate based\nauthentication method, then the value of this object will be a\nNULL string.")
jnxIkeTunRemoteIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 11), JnxIkePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteIdType.setDescription("The type of remote peer identity.\nThe remote peer may be identified by:\n 1. an IP address, or\n 2. or a fully qualified domain name string.\n 3. or a distinguished name string.")
jnxIkeTunRemoteIdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteIdValue.setDescription("The value of the remote peer identity.\n\nIf the remote peer type is an IP Address, then this\nis the IP Address used to identify the remote peer.\n\nIf the remote peer type is id_fqdn, then this is\nthe FQDN of the remote peer.\n\nIf the remote peer type is a id_dn, then this is\nthe distinguished named string of the remote peer.")
jnxIkeTunRemoteGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 13), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteGwAddrType.setDescription("The IP address type of the remote gateway (endpoint) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunRemoteGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 14), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunRemoteGwAddr.setDescription("The IP address of the remote gateway (endpoint) for the IPsec\nPhase-1 IKE Tunnel.")
jnxIkeTunNegoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 15), JnxIkeNegoMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunNegoMode.setDescription("The negotiation mode of the IPsec Phase-1 IKE Tunnel.")
jnxIkeTunDiffHellmanGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 16), JnxDiffHellmanGrp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunDiffHellmanGrp.setDescription("The Diffie Hellman Group used in IPsec Phase-1 IKE\nnegotiations.")
jnxIkeTunEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 17), JnxEncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunEncryptAlgo.setDescription("The encryption algorithm used in IPsec Phase-1 IKE\nnegotiations.")
jnxIkeTunHashAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 18), JnxIkeHashAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunHashAlgo.setDescription("The hash algorithm used in IPsec Phase-1 IKE\nnegotiations.")
jnxIkeTunAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 19), JnxIkeAuthMethod()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunAuthMethod.setDescription("The authentication method used in IPsec Phase-1 IKE\nnegotiations.")
jnxIkeTunLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-1 IKE Tunnel\nin seconds.")
jnxIkeTunActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 21), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunActiveTime.setDescription("The length of time the IPsec Phase-1 IKE tunnel has been\nactive in hundredths of seconds.")
jnxIkeTunInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunInOctets.setDescription("The total number of octets received by\nthis IPsec Phase-1 IKE security association.")
jnxIkeTunInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunInPkts.setDescription("The total number of packets received by\nthis IPsec Phase-1 IKE security association.")
jnxIkeTunOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunOutOctets.setDescription("The total number of octets sent by this IPsec Phase-1\nIKE security association.")
jnxIkeTunOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIkeTunOutPkts.setDescription("The total number of packets sent by this IPsec Phase-1\nIKE security association.")
jnxIpSecPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3))
jnxIpSecTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1))
if mibBuilder.loadTexts: jnxIpSecTunnelTable.setDescription("The IPsec Phase-2 Tunnel Table.\nThere is one entry in this table for\neach active IPsec Phase-2 Tunnel.")
jnxIpSecTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1)).setIndexNames((0, "JUNIPER-SP-MIB", "jnxSpSvcSetName"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddrType"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddr"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunIndex"))
if mibBuilder.loadTexts: jnxIpSecTunnelEntry.setDescription("Each entry contains the attributes\nassociated with an active IPsec Phase-2 Tunnel.")
jnxIpSecTunIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecTunIndex.setDescription("The index of the IPsec Phase-2 Tunnel Table.\nThe value of the index is a number which begins\nat one and is incremented with each tunnel that\nis created. The value of this object will wrap\nat 2,147,483,647.")
jnxIpSecRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecRuleName.setDescription("Name of the rule configured in IPSec configuration.")
jnxIpSecTermName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTermName.setDescription("Name of the term configured under IPSec rule.")
jnxIpSecTunLocalGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunLocalGwAddrType.setDescription("The IP address type of the local gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunLocalGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunLocalGwAddr.setDescription("The IP address of the local gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunRemoteGwAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunRemoteGwAddrType.setDescription("The IP address type of the remote gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunRemoteGwAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunRemoteGwAddr.setDescription("The IP address of the remote gateway (endpoint) for the IPsec\nPhase-2 Tunnel.")
jnxIpSecTunLocalProxyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunLocalProxyId.setDescription("Identifier for the local end.")
jnxIpSecTunRemoteProxyId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunRemoteProxyId.setDescription("Identifier for the remote end.")
jnxIpSecTunKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 10), JnxKeyType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunKeyType.setDescription("The type of key used by the IPsec Phase-2 Tunnel. It can be\none of the following two types:\n  - IKE negotiated\n  - Manually installed")
jnxIpSecRemotePeerType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 11), JnxRemotePeerType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecRemotePeerType.setDescription("The type of the remote peer gateway (endpoint). It can be one\nof the following two types:\n  - static (Remote peer whose IP address is known beforehand)\n  - dynamic (Remote peer whose IP address is not known\n             beforehand)")
jnxIpSecTunMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunMtu.setDescription("MTU value of this Phase-2 tunnel.")
jnxIpSecTunOutEncryptedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunOutEncryptedBytes.setDescription("Number of bytes encrypted by this Phase-2 tunnel.")
jnxIpSecTunOutEncryptedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunOutEncryptedPkts.setDescription("Number of packets encrypted by this Phase-2 tunnel.")
jnxIpSecTunInDecryptedBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunInDecryptedBytes.setDescription("Number of bytes decrypted by this Phase-2 tunnel.")
jnxIpSecTunInDecryptedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunInDecryptedPkts.setDescription("Number of packets decrypted by this Phase-2 tunnel.")
jnxIpsSecTunAHInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHInBytes.setDescription("Number of incoming bytes authenticated using AH by this Phase-2\ntunnel.")
jnxIpsSecTunAHInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHInPkts.setDescription("Number of incoming packets authenticated using AH by this Phase-2\ntunnel.")
jnxIpsSecTunAHOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHOutBytes.setDescription("Number of outgoing bytes applied AH by this Phase-2 tunnel.")
jnxIpsSecTunAHOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 20), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpsSecTunAHOutPkts.setDescription("Number of outgoing packets applied AH by this Phase-2 tunnel.")
jnxIpSecTunReplayDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 21), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunReplayDropPkts.setDescription("Number of packets dropped by this Phase-2 tunnel due to\nanti replay check failure.")
jnxIpSecTunAhAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 22), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunAhAuthFails.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed AH authentication.")
jnxIpSecTunEspAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 23), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunEspAuthFails.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed ESP authentication.")
jnxIpSecTunDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 24), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunDecryptFails.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed decryption.")
jnxIpSecTunBadHeaders = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 25), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunBadHeaders.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed due to bad headers.")
jnxIpSecTunBadTrailers = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 26), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunBadTrailers.setDescription("Number of packets received by this Phase-2 tunnel that\nfailed due to bad ESP trailers.")
jnxIpSecTunDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 1, 1, 27), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecTunDroppedPkts.setDescription("Total number of dropped packets for this Phase-2 tunnel.")
jnxIpSecSaTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2))
if mibBuilder.loadTexts: jnxIpSecSaTable.setDescription("The IPsec Phase-2 Security Association Table.\nThis table identifies the structure (in terms of\ncomponent SAs) of each active Phase-2 IPsec tunnel.\nThis table contains an entry for each active and\nexpiring security association and maps each entry\nin the active Phase-2 tunnel table (ipSecTunTable)\ninto a number of entries in this table. The index of this\ntable reflects the\n\n    <destination-address, protocol, spi>\n\nrule for identifying Security Associations.")
jnxIpSecSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1)).setIndexNames((0, "JUNIPER-SP-MIB", "jnxSpSvcSetName"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddrType"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunRemoteGwAddr"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecTunIndex"), (0, "JNX-IPSEC-MONITOR-MIB", "jnxIpSecSaIndex"))
if mibBuilder.loadTexts: jnxIpSecSaEntry.setDescription("Each entry contains the attributes associated with\nactive and expiring IPsec Phase-2\nsecurity associations.")
jnxIpSecSaProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("ah", 1), ("esp", 2), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecSaProtocol.setDescription("The index, represents the security protocol (AH, ESP or\nIPComp) for which this security association was setup.")
jnxIpSecSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxIpSecSaIndex.setDescription("The index, in the context of the IPsec tunnel ipSecTunIndex,\nof the security association represented by this table entry.\nThe value of this index is a number which begins at one and\nis incremented with each SPI associated with an IPsec Phase-2\nTunnel.  The value of this object will wrap at 2,147,483,647.")
jnxIpSecSaInSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 3), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaInSpi.setDescription("The value of the incoming SPI.")
jnxIpSecSaOutSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 4), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaOutSpi.setDescription("The value of the outgoing SPI.")
jnxIpSecSaInAuxSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 5), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaInAuxSpi.setDescription("The value of the incoming auxiliary SPI. This is valid for AH\nand ESP bundles.")
jnxIpSecSaOutAuxSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 6), JnxSpi()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaOutAuxSpi.setDescription("The value of the outgoing auxiliary SPI. This is valid for AH\nand ESP bundles.")
jnxIpSecSaType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 7), JnxSAType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaType.setDescription("This field represents the type of security associations \nwhich can be either manual or dynamic")
jnxIpSecSaEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 8), JnxEncapMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaEncapMode.setDescription("The encapsulation mode used by an IPsec Phase-2 Tunnel. ")
jnxIpSecSaLifeSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeSize.setDescription("The negotiated LifeSize of the IPsec Phase-2 Tunnel in kilobytes. ")
jnxIpSecSaLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeTime.setDescription("The negotiated LifeTime of the IPsec Phase-2 Tunnel in seconds. ")
jnxIpSecSaActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 11), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaActiveTime.setDescription("The length of time the IPsec Phase-2 Tunnel has been active in seconds. ")
jnxIpSecSaLifeSizeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeSizeThreshold.setDescription("The security association LifeSize refresh threshold in kilobytes. ")
jnxIpSecSaLifeTimeThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaLifeTimeThreshold.setDescription("The security association LifeTime refresh threshold in seconds. ")
jnxIpSecSaEncryptAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 14), JnxEncryptAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaEncryptAlgo.setDescription("The Encryption algorithm used to encrypt \nthe packets which can be either es-cbc or 3des-cbc. ")
jnxIpSecSaAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 15), JnxAuthAlgo()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaAuthAlgo.setDescription("The algorithm used for authentication of packets which\ncan be hmac-md5-96 or hmac-sha1-96")
jnxIpSecSaState = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 22, 1, 3, 2, 1, 16), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,2,)).subtype(namedValues=NamedValues(("unknown", 0), ("active", 1), ("expiring", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxIpSecSaState.setDescription("This column represents the status of the security association\nrepresented by this table entry. If the status of the SA is\n'active', the SA is ready for active use. The status\n'expiring' represents any of the various states that the\nsecurity association transitions through before being purged.")

# Augmentions

# Exports

# Module identity
mibBuilder.exportSymbols("JNX-IPSEC-MONITOR-MIB", PYSNMP_MODULE_ID=jnxIpSecMonitorMIB)

# Types
mibBuilder.exportSymbols("JNX-IPSEC-MONITOR-MIB", JnxAuthAlgo=JnxAuthAlgo, JnxDiffHellmanGrp=JnxDiffHellmanGrp, JnxEncapMode=JnxEncapMode, JnxEncryptAlgo=JnxEncryptAlgo, JnxIkeAuthMethod=JnxIkeAuthMethod, JnxIkeHashAlgo=JnxIkeHashAlgo, JnxIkeNegState=JnxIkeNegState, JnxIkeNegoMode=JnxIkeNegoMode, JnxIkePeerRole=JnxIkePeerRole, JnxIkePeerType=JnxIkePeerType, JnxKeyType=JnxKeyType, JnxRemotePeerType=JnxRemotePeerType, JnxSAType=JnxSAType, JnxSpi=JnxSpi)

# Objects
mibBuilder.exportSymbols("JNX-IPSEC-MONITOR-MIB", jnxIpSecMonitorMIB=jnxIpSecMonitorMIB, jnxIpSecMIBObjects=jnxIpSecMIBObjects, jnxIpSecLevels=jnxIpSecLevels, jnxIpSecMibLevel=jnxIpSecMibLevel, jnxIpSecPhaseOne=jnxIpSecPhaseOne, jnxIkeTunnelTable=jnxIkeTunnelTable, jnxIkeTunnelEntry=jnxIkeTunnelEntry, jnxIkeTunIndex=jnxIkeTunIndex, jnxIkeTunLocalRole=jnxIkeTunLocalRole, jnxIkeTunNegState=jnxIkeTunNegState, jnxIkeTunInitiatorCookie=jnxIkeTunInitiatorCookie, jnxIkeTunResponderCookie=jnxIkeTunResponderCookie, jnxIkeTunLocalIdType=jnxIkeTunLocalIdType, jnxIkeTunLocalIdValue=jnxIkeTunLocalIdValue, jnxIkeTunLocalGwAddrType=jnxIkeTunLocalGwAddrType, jnxIkeTunLocalGwAddr=jnxIkeTunLocalGwAddr, jnxIkeTunLocalCertName=jnxIkeTunLocalCertName, jnxIkeTunRemoteIdType=jnxIkeTunRemoteIdType, jnxIkeTunRemoteIdValue=jnxIkeTunRemoteIdValue, jnxIkeTunRemoteGwAddrType=jnxIkeTunRemoteGwAddrType, jnxIkeTunRemoteGwAddr=jnxIkeTunRemoteGwAddr, jnxIkeTunNegoMode=jnxIkeTunNegoMode, jnxIkeTunDiffHellmanGrp=jnxIkeTunDiffHellmanGrp, jnxIkeTunEncryptAlgo=jnxIkeTunEncryptAlgo, jnxIkeTunHashAlgo=jnxIkeTunHashAlgo, jnxIkeTunAuthMethod=jnxIkeTunAuthMethod, jnxIkeTunLifeTime=jnxIkeTunLifeTime, jnxIkeTunActiveTime=jnxIkeTunActiveTime, jnxIkeTunInOctets=jnxIkeTunInOctets, jnxIkeTunInPkts=jnxIkeTunInPkts, jnxIkeTunOutOctets=jnxIkeTunOutOctets, jnxIkeTunOutPkts=jnxIkeTunOutPkts, jnxIpSecPhaseTwo=jnxIpSecPhaseTwo, jnxIpSecTunnelTable=jnxIpSecTunnelTable, jnxIpSecTunnelEntry=jnxIpSecTunnelEntry, jnxIpSecTunIndex=jnxIpSecTunIndex, jnxIpSecRuleName=jnxIpSecRuleName, jnxIpSecTermName=jnxIpSecTermName, jnxIpSecTunLocalGwAddrType=jnxIpSecTunLocalGwAddrType, jnxIpSecTunLocalGwAddr=jnxIpSecTunLocalGwAddr, jnxIpSecTunRemoteGwAddrType=jnxIpSecTunRemoteGwAddrType, jnxIpSecTunRemoteGwAddr=jnxIpSecTunRemoteGwAddr, jnxIpSecTunLocalProxyId=jnxIpSecTunLocalProxyId, jnxIpSecTunRemoteProxyId=jnxIpSecTunRemoteProxyId, jnxIpSecTunKeyType=jnxIpSecTunKeyType, jnxIpSecRemotePeerType=jnxIpSecRemotePeerType, jnxIpSecTunMtu=jnxIpSecTunMtu, jnxIpSecTunOutEncryptedBytes=jnxIpSecTunOutEncryptedBytes, jnxIpSecTunOutEncryptedPkts=jnxIpSecTunOutEncryptedPkts, jnxIpSecTunInDecryptedBytes=jnxIpSecTunInDecryptedBytes, jnxIpSecTunInDecryptedPkts=jnxIpSecTunInDecryptedPkts, jnxIpsSecTunAHInBytes=jnxIpsSecTunAHInBytes, jnxIpsSecTunAHInPkts=jnxIpsSecTunAHInPkts, jnxIpsSecTunAHOutBytes=jnxIpsSecTunAHOutBytes, jnxIpsSecTunAHOutPkts=jnxIpsSecTunAHOutPkts, jnxIpSecTunReplayDropPkts=jnxIpSecTunReplayDropPkts, jnxIpSecTunAhAuthFails=jnxIpSecTunAhAuthFails, jnxIpSecTunEspAuthFails=jnxIpSecTunEspAuthFails, jnxIpSecTunDecryptFails=jnxIpSecTunDecryptFails, jnxIpSecTunBadHeaders=jnxIpSecTunBadHeaders, jnxIpSecTunBadTrailers=jnxIpSecTunBadTrailers, jnxIpSecTunDroppedPkts=jnxIpSecTunDroppedPkts, jnxIpSecSaTable=jnxIpSecSaTable, jnxIpSecSaEntry=jnxIpSecSaEntry, jnxIpSecSaProtocol=jnxIpSecSaProtocol, jnxIpSecSaIndex=jnxIpSecSaIndex, jnxIpSecSaInSpi=jnxIpSecSaInSpi, jnxIpSecSaOutSpi=jnxIpSecSaOutSpi, jnxIpSecSaInAuxSpi=jnxIpSecSaInAuxSpi, jnxIpSecSaOutAuxSpi=jnxIpSecSaOutAuxSpi, jnxIpSecSaType=jnxIpSecSaType, jnxIpSecSaEncapMode=jnxIpSecSaEncapMode, jnxIpSecSaLifeSize=jnxIpSecSaLifeSize, jnxIpSecSaLifeTime=jnxIpSecSaLifeTime, jnxIpSecSaActiveTime=jnxIpSecSaActiveTime, jnxIpSecSaLifeSizeThreshold=jnxIpSecSaLifeSizeThreshold, jnxIpSecSaLifeTimeThreshold=jnxIpSecSaLifeTimeThreshold, jnxIpSecSaEncryptAlgo=jnxIpSecSaEncryptAlgo, jnxIpSecSaAuthAlgo=jnxIpSecSaAuthAlgo, jnxIpSecSaState=jnxIpSecSaState)

