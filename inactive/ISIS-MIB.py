# PySNMP SMI module. Autogenerated from smidump -f python ISIS-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 12:08:38 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( IndexInteger, IndexIntegerNextFree, ) = mibBuilder.importSymbols("DIFFSERV-MIB", "IndexInteger", "IndexIntegerNextFree")
( InterfaceIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
( InetAddress, InetAddressPrefixLength, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "mib-2")
( RowStatus, TextualConvention, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TimeStamp", "TruthValue")

# Types

class IsisAdminState(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("on", 1), ("off", 2), )
    
class IsisCircuitID(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(7,7),)
    
class IsisDefaultMetric(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,63)
    
class IsisFullMetric(TextualConvention, Unsigned32):
    displayHint = "d"
    
class IsisISLevel(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,)
    namedValues = NamedValues(("area", 1), ("domain", 2), )
    
class IsisISPriority(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,127)
    
class IsisLSPBuffSize(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(512,16000)
    
class IsisLevel(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,3,)
    namedValues = NamedValues(("level1", 1), ("level2", 2), ("level1and2", 3), )
    
class IsisLevelState(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,1,4,3,)
    namedValues = NamedValues(("off", 1), ("on", 2), ("waiting", 3), ("overloaded", 4), )
    
class IsisLinkStatePDUID(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(8,8)
    fixedLength = 8
    
class IsisMetricStyle(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(2,3,1,)
    namedValues = NamedValues(("narrow", 1), ("wide", 2), ("both", 3), )
    
class IsisMetricType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,)
    namedValues = NamedValues(("internal", 1), ("external", 2), )
    
class IsisOSINSAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,20)
    
class IsisPDUHeader(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,64)
    
class IsisSupportedProtocol(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(204,129,142,)
    namedValues = NamedValues(("iso8473", 129), ("ipV6", 142), ("ip", 204), )
    
class IsisSystemID(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(6,6)
    fixedLength = 6
    
class IsisUnsigned16TC(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,65535)
    
class IsisUnsigned8TC(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,255)
    
class IsisWideMetric(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,16777215)
    

# Objects

isisMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 138)).setRevisions(("2006-04-04 00:00",))
if mibBuilder.loadTexts: isisMIB.setOrganization("IETF IS-IS for IP Internets Working Group")
if mibBuilder.loadTexts: isisMIB.setContactInfo("IS-IS for IP Internets working Group\nhttp://www.ietf.org/html.charters/isis-charter.html\nisis-wg@ietf.org\n\nJeff Parker\nDepartment of Computer Science\nMiddlebury College,\nMiddlebury, Vermont 05753\njeffp at middlbury dot edu")
if mibBuilder.loadTexts: isisMIB.setDescription("This document describes a management information base for\nthe IS-IS Routing protocol, as described in ISO 10589,\nwhen it is used to construct routing tables for IP\nnetworks, as described in RFC 1195.\n\nThis document is based on a 1994 IETF document by Chris\nGunner.  This version has been modified to include\ncurrent syntax, to exclude portions of the protocol that\nare not relevant to IP, and to add management support for\ncurrent practice.\n\n\n\n\n\n\nCopyright (C) The Internet Society (2006).  This version\nof this MIB module is part of RFC 4444; see the RFC\nitself for full legal notices.")
isisNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 0))
isisObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1))
isisSystem = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 1))
isisSysObject = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 1, 1))
isisSysVersion = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("unknown", 0), ("one", 1), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysVersion.setDescription("The version number of the IS-IS protocol that\nis implemented.")
isisSysLevelType = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 2), IsisLevel().clone('level1and2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelType.setDescription("At which levels is the Intermediate System\nrunning? This object may not be modified when\nthe isisSysAdminState variable is in state 'on'\nfor this Intermediate System.\n\nConfigured values MUST survive an agent reboot.")
isisSysID = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 3), IsisSystemID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysID.setDescription("The ID for this Intermediate System.\nThis value is appended to each of the\narea addresses to form the Network Entity Titles.\nThe derivation of a value for this object is\nimplementation specific.  Some implementations may\nautomatically assign values and not permit an\nSNMP write, while others may require the value\nto be set manually.\n\nConfigured values MUST survive an agent reboot.")
isisSysMaxPathSplits = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysMaxPathSplits.setDescription("Maximum number of paths with equal routing metric value\nwhich it is permitted to split between.  This object\nmay not be modified when the isisSysAdminState variable\nis in state 'on' for this Intermediate System.\n\nConfigured values MUST survive an agent reboot.")
isisSysMaxLSPGenInt = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65235)).clone(900)).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: isisSysMaxLSPGenInt.setDescription("Maximum interval, in seconds, between generated LSPs\nby this Intermediate System.  This object follows\nthe ResettingTimer behavior.  The value must be\ngreater than any value configured for\nisisSysLevelMinLSPGenInt, and should be at least 300\nseconds less than isisSysMaxAge.\n\nConfigured values MUST survive an agent reboot.")
isisSysPollESHelloRate = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 6), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: isisSysPollESHelloRate.setDescription("The value, in seconds, to be used for the suggested ES\nconfiguration timer in ISH PDUs when soliciting the ES\nconfiguration.\n\nConfigured values MUST survive an agent reboot.")
isisSysWaitTime = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 7), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(60)).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: isisSysWaitTime.setDescription("Number of seconds to delay in state 'waiting' before\nentering the state 'on'.  This object follows the\nResettingTimer behavior.\n\nConfigured values MUST survive an agent reboot.")
isisSysAdminState = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 8), IsisAdminState().clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysAdminState.setDescription("The administrative state of this Intermediate\nSystem.  Setting this object to the value 'on'\nwhen its current value is 'off' enables\nthe Intermediate System.\n\nConfigured values MUST survive an agent reboot.")
isisSysL2toL1Leaking = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysL2toL1Leaking.setDescription("If true, allow the router to leak L2 routes into L1.\n\nConfigured values MUST survive an agent reboot.")
isisSysMaxAge = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 10), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(350, 65535)).clone(1200)).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: isisSysMaxAge.setDescription("Value to place in RemainingLifeTime field of\nthe LSPs we generate.\nThis should be at least 300 seconds greater than\nisisSysMaxLSPGenInt.\n\nConfigured values MUST survive an agent reboot.")
isisSysReceiveLSPBufferSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 11), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1492, 16000)).clone(1492)).setMaxAccess("readwrite").setUnits("bytes")
if mibBuilder.loadTexts: isisSysReceiveLSPBufferSize.setDescription("Size of the largest buffer we are designed or\nconfigured to store.  This should be at least\nas big as the maximum isisSysLevelOrigLSPBuffSize\nsupported by the system.\n\n\n\nIf resources allow, we will store and flood LSPs\nlarger than isisSysReceiveLSPBufferSize, as this\ncan help avoid problems in networks with different\nvalues for isisSysLevelOrigLSPBuffSize.\n\nConfigured values MUST survive an agent reboot.")
isisSysProtSupported = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 12), Bits().subtype(namedValues=NamedValues(("iso8473", 0), ("ipv4", 1), ("ipv6", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysProtSupported.setDescription("This attribute contains the set of protocols\nsupported by this Intermediate System.")
isisSysNotificationEnable = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 1, 1, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysNotificationEnable.setDescription("If this object is set to true(1), then it enables\nthe emission of IS-IS Notifications.  If it is\nset to false(2), these notifications are not sent.\n\nConfigured values MUST survive an agent reboot.")
isisManAreaAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 2))
if mibBuilder.loadTexts: isisManAreaAddrTable.setDescription("The set of manual area addresses configured on this\nIntermediate System.\n\nAt least one row in which the value of\nisisManAreaAddrExistState is active must be present.\nThe maximum number of rows in this table for\n\n\n\nwhich the object isisManAreaAddrExistState has the\nvalue active is 3.\n\nAn attempt to create more than 3 rows of\nisisManAreaAddrEntry with state 'active' in one\ninstance of the IS-IS protocol should\nreturn inconsistentValue.")
isisManAreaAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1)).setIndexNames((0, "ISIS-MIB", "isisManAreaAddr"))
if mibBuilder.loadTexts: isisManAreaAddrEntry.setDescription("Each entry contains one area address manually configured\non this system.\n\nDynamically created rows MUST survive an agent reboot.")
isisManAreaAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1, 1), IsisOSINSAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisManAreaAddr.setDescription("A manually configured area address for this system.\n\nNote: An index for the entry {1, {49.0001} active} in\nthis table would be the ordered pair\n(1, (0x03 0x49 0x00 0x01)), as the length of an octet\nstring is part of the OID.")
isisManAreaAddrExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisManAreaAddrExistState.setDescription("The state of the isisManAreaAddrEntry.  If the\nisisSysAdminState for this Intermediate System is 'on' and\nan attempt is made to set this object to the value\n'destroy' or 'notInService' when this is the only\nisisManAreaAddrEntry in state 'active' for this\nIntermediate System should return inconsistentValue.\n\nA row entry cannot be modified when the value of this\nobject is 'active'.")
isisAreaAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 3))
if mibBuilder.loadTexts: isisAreaAddrTable.setDescription("The union of the sets of area addresses reported in all\nLevel 1 LSPs with fragment number zero generated by this\nIntermediate System, or received from other Intermediate\nSystems that are reachable via Level 1 routing.")
isisAreaAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 3, 1)).setIndexNames((0, "ISIS-MIB", "isisAreaAddr"))
if mibBuilder.loadTexts: isisAreaAddrEntry.setDescription("Each entry contains one area address reported in a\nLevel 1 LSP generated or received by this Intermediate\nSystem.\n\nDynamically learned rows do not survive an agent reboot.")
isisAreaAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 3, 1, 1), IsisOSINSAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisAreaAddr.setDescription("An area address reported in a Level 1 LSP.")
isisSummAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 4))
if mibBuilder.loadTexts: isisSummAddrTable.setDescription("The set of IP summary addresses to use in forming\nsummary TLVs originated by this Intermediate System.\n\nAn administrator may use a summary address to combine\nand modify IP Reachability announcements.  If the\nIntermediate system can reach any subset of the summary\naddress, the summary address MUST be announced instead,\nat the configured metric.")
isisSummAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1)).setIndexNames((0, "ISIS-MIB", "isisSummAddressType"), (0, "ISIS-MIB", "isisSummAddress"), (0, "ISIS-MIB", "isisSummAddrPrefixLen"))
if mibBuilder.loadTexts: isisSummAddrEntry.setDescription("Each entry contains one IP summary address.\n\nDynamically created rows MUST survive an agent reboot.\n\nImplementers need to be aware that if the total number\nof elements (octets or sub-identifiers) in\nisisSummAddress and isisSummAddrPrefixLen is too great,\nthen OIDs of column instances in this table will have\nmore than 128 subidentifiers and cannot be accessed\nusing SNMPv1, SNMPv2c, or SNMPv3.")
isisSummAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisSummAddressType.setDescription("The Type of IP address for this summary address.")
isisSummAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisSummAddress.setDescription("The IP Address value for this summary address.\nThe address must not contain any set host bits\n(bits set after the address prefix determined by\nisisSummAddrPrefixLen).\n\nThe type of this address is determined by the value of\nthe isisSummAddressType object.")
isisSummAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 3), InetAddressPrefixLength()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisSummAddrPrefixLen.setDescription("The Length of the IP NetMask for this summary address.\n\nThe values for the index objects isisSummAddress and\n\n\n\nisisSummAddrPrefixLen must be consistent.  When the value\nof isisSummAddress (excluding the zone index, if one\nis present) is x, then the bitwise logical-AND\nof x with the value of the mask formed from the\ncorresponding index object isisSummAddrPrefixLen MUST be\nequal to x.  If not, then the index pair is not\nconsistent, and an inconsistentName error must be\nreturned on SET or CREATE requests.")
isisSummAddrExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisSummAddrExistState.setDescription("The existence state of this summary address.  Support\nfor 'createAndWait' and 'notInService' is not required.\n\nA row entry cannot be modified when the value of this\nobject is 'active'.")
isisSummAddrMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 5), IsisDefaultMetric().clone('20')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisSummAddrMetric.setDescription("The metric value to announce this summary\naddress within LSPs generated by this system.")
isisSummAddrFullMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1, 6), IsisFullMetric().clone('20')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisSummAddrFullMetric.setDescription("The wide metric value to announce this summary\naddress within LSPs generated by this system.")
isisRedistributeAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 5))
if mibBuilder.loadTexts: isisRedistributeAddrTable.setDescription("This table provides criteria to decide if a route should\nbe leaked from L2 to L1 when Domain Wide Prefix leaking is\nenabled.\n\nAddresses that match the summary mask in the table MUST\nbe announced at L1 by routers when isisSysL2toL1Leaking\nis enabled.  Routes that fall into the ranges specified\nare announced as is, without being summarized.  Routes\nthat do not match a summary mask are not announced.")
isisRedistributeAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1)).setIndexNames((0, "ISIS-MIB", "isisRedistributeAddrType"), (0, "ISIS-MIB", "isisRedistributeAddrAddress"), (0, "ISIS-MIB", "isisRedistributeAddrPrefixLen"))
if mibBuilder.loadTexts: isisRedistributeAddrEntry.setDescription("Each entry contains one configured IP summary\naddress to manage leaking L2 addresses into L1.\n\nDynamically created rows MUST survive an agent reboot.\n\nImplementers need to be aware that if the total number\nof elements (octets or sub-identifiers) in\nisisRedistributeAddrAddress and\nisisRedistributeAddrPrefixLen is too great, then OIDs\nof column instances in this table will have more than\n128 subidentifiers and cannot be accessed using SNMPv1,\nSNMPv2c, or SNMPv3.")
isisRedistributeAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisRedistributeAddrType.setDescription("The Type of IP address for this summary address.")
isisRedistributeAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisRedistributeAddrAddress.setDescription("The IP Address value for this summary address.\nThe type of this address is determined by the\nvalue of the isisRedistributeAddrType object.\nThe address must not contain any set host bits -\nbits set after the address prefix determined by\nisisRedistributeAddrPrefixLen.")
isisRedistributeAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 3), InetAddressPrefixLength()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisRedistributeAddrPrefixLen.setDescription("The Length of the IP NetMask for this summary address.\n\nThe values for the index objects\nisisRedistributeAddrAddress and\nisisRedistributeAddrPrefixLen must be consistent.\nWhen the value of isisRedistributeAddrAddress\n(excluding the zone index, if one is present) is x,\nthen the bitwise logical-AND of x with the value of\nthe mask formed from the corresponding index object\nisisRedistributeAddrPrefixLen MUST be equal to x.\nIf not, then the index pair is not consistent, and an\ninconsistentName error must be returned on SET or\nCREATE requests.")
isisRedistributeAddrExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRedistributeAddrExistState.setDescription("The existence state of this summary address.  Support\n\n\n\nfor createAndWait and notInService is not required.\n\nA row entry cannot be modified when the value of this\nobject is 'active'.")
isisRouterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 1, 6))
if mibBuilder.loadTexts: isisRouterTable.setDescription("The set of hostnames and router ID.")
isisRouterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1)).setIndexNames((0, "ISIS-MIB", "isisRouterSysID"), (0, "ISIS-MIB", "isisRouterLevel"))
if mibBuilder.loadTexts: isisRouterEntry.setDescription("Each entry tracks information about one Intermediate\nSystem at one level.\n\nDynamically learned rows do not survive an agent reboot.")
isisRouterSysID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 1), IsisSystemID()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisRouterSysID.setDescription("The System ID of the Intermediate System.")
isisRouterLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 2), IsisISLevel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisRouterLevel.setDescription("The level at which the information about this\nIntermediate System was received.")
isisRouterHostName = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisRouterHostName.setDescription("The hostname listed in the LSP, or a zero-length\nstring if none.")
isisRouterID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 1, 6, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisRouterID.setDescription("The Router ID found in the LSP, or zero if none.")
isisSysLevel = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 2))
isisSysLevelTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 2, 1))
if mibBuilder.loadTexts: isisSysLevelTable.setDescription("Level specific information about the System.")
isisSysLevelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisSysLevelIndex"))
if mibBuilder.loadTexts: isisSysLevelEntry.setDescription("Each row describes variables configured for Area or Domain.\n\nConfigured values MUST survive an agent reboot.")
isisSysLevelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 1), IsisISLevel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisSysLevelIndex.setDescription("The level that this entry describes.")
isisSysLevelOrigLSPBuffSize = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 2), IsisLSPBuffSize().clone('1492')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelOrigLSPBuffSize.setDescription("The maximum size of LSPs and SNPs originated by\nthis Intermediate System at this level.  This\nobject may not be modified when the isisSysAdminState\nvariable is in state 'on' for this Intermediate System.")
isisSysLevelMinLSPGenInt = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 3), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelMinLSPGenInt.setDescription("Minimum interval, in seconds, between successive\ngeneration of LSPs with the same LSPID at this level\nby this Intermediate System.")
isisSysLevelState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 4), IsisLevelState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysLevelState.setDescription("The state of the database at this level.\nThe value 'off' indicates that IS-IS is not active at\nthis level.\nThe value 'on' indicates that IS-IS is active at this\nlevel and is not overloaded.\nThe value 'waiting' indicates a database that is low on\nan essential resource, such as memory.\nThe administrator may force the state to 'overloaded'\nby setting the object isisSysLevelSetOverload.\nIf the state is 'waiting' or 'overloaded', we\noriginate LSPs with the overload bit set.")
isisSysLevelSetOverload = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelSetOverload.setDescription("Administratively set the overload bit for the level.\nThe overload bit MUST continue to be set if the\nimplementation runs out of memory, independent of\nthis variable.  It may also be set manually independent\nof this variable, using the isisSysLevelSetOverloadUntil\nobject.")
isisSysLevelSetOverloadUntil = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelSetOverloadUntil.setDescription("If this object is non-zero, the overload bit is set at\nthis level when the isisSysAdminState variable goes to\nstate 'on' for this Intermediate System.  The overload bit\nremains set for isisSysLevelSetOverloadUntil seconds.\nWhen isisSysLevelSetOverloadUntil seconds have elapsed,\nthe overload flag remains set if the implementation has\nrun out of memory, or if it is set manually using the\nisisSysLevelSetOverload object.\n\nIf isisSysLevelSetOverload is false, the system clears\nthe overload bit when isisSysLevelSetOverloadUntil seconds\nhave elapsed, if the system has not run out of memory.")
isisSysLevelMetricStyle = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 7), IsisMetricStyle().clone('narrow')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelMetricStyle.setDescription("Which style of metric do we generate in our LSPs\nat this level?")
isisSysLevelSPFConsiders = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 8), IsisMetricStyle().clone('narrow')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelSPFConsiders.setDescription("Which style of metric do we consider in our\nSPF computation at this level?")
isisSysLevelTEEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 2, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisSysLevelTEEnabled.setDescription("Do we do Traffic Engineering at this level?")
isisCirc = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 3))
isisNextCircIndex = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 3, 1), IndexIntegerNextFree()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisNextCircIndex.setDescription("This object is used to assist a management\napplication in creating new rows in the\nisisCircTable.  If it is possible to create\na new instance of isisCircEntry, then this\nobject will contain a non-zero value that\nis not in use as the index of any row in the\nisisCircTable.  The network manager reads the\nvalue of this object and then (if the\nvalue read is non-zero) attempts to create\nthe corresponding instance of isisCircEntry.\nIf the set request fails with the code\n'inconsistentValue', then the process must be\nrepeated;  if the set request succeeds, then\nthe agent will change the value of this object\naccording to an implementation-specific\nalgorithm.")
isisCircTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 3, 2))
if mibBuilder.loadTexts: isisCircTable.setDescription("The table of circuits used by this\nIntermediate System.")
isisCircEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"))
if mibBuilder.loadTexts: isisCircEntry.setDescription("An isisCircEntry exists for each circuit configured\nfor Integrated IS-IS on this system.\n\nDynamically created rows MUST survive an agent reboot.")
isisCircIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 1), IndexInteger()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisCircIndex.setDescription("An index used to uniquely identify this circuit.\nWhen creating a row in this table, the\nisisNextCircIndex object should be retrieved,\nand its value should be specified as the value\nof this index using a SET operation.  A retrieved\nvalue of zero(0) indicates that no rows can be\ncreated at this time.")
isisCircIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircIfIndex.setDescription("The value of ifIndex for the interface to which this\ncircuit corresponds.  This object cannot be modified\nafter creation.")
isisCircAdminState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 3), IsisAdminState().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircAdminState.setDescription("The administrative state of the circuit.")
isisCircExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircExistState.setDescription("The existence state of this circuit.  Setting the state\nto 'notInService' halts the generation and processing of\nIS-IS protocol PDUs on this circuit.  Setting the state\nto destroy will also erase any configuration associated\nwith the circuit.  Support for 'createAndWait' and\n'notInService' is not required.\n\nA row entry cannot be modified when the value of this\nobject is 'active'.")
isisCircType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(4,5,1,3,2,)).subtype(namedValues=NamedValues(("broadcast", 1), ("ptToPt", 2), ("staticIn", 3), ("staticOut", 4), ("dA", 5), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircType.setDescription("The type of the circuit.  This object follows the\nReplaceOnlyWhileDisabled behavior.  The type specified\nmust be compatible with the type of the interface defined\n\n\n\nby the value of isisCircIfIndex.")
isisCircExtDomain = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircExtDomain.setDescription("If true, suppress normal transmission of and\ninterpretation of Intra-domain IS-IS PDUs on this\ncircuit.")
isisCircLevelType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 7), IsisLevel().clone('level1and2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircLevelType.setDescription("Indicates which type of packets will be sent and\naccepted on this circuit.  The values set will be\nsaved, but the values used will be modified by\nthe settings of isisSysLevelType.  Thus, if the\nisisSysTpe is level2 and the isisCircLevelType\nfor a circuit is level1, the circuit will not send\nor receive IS-IS packets.  This object follows the\nReplaceOnlyWhileDisabled behavior.")
isisCircPassiveCircuit = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircPassiveCircuit.setDescription("Should we include this interface in LSPs, even if\nit is not running the IS-IS Protocol?")
isisCircMeshGroupEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 9), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("inactive", 1), ("blocked", 2), ("set", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircMeshGroupEnabled.setDescription("Is this port a member of a mesh group, or is it\nblocked?  Circuits in the same mesh group act as a\nvirtual multiaccess network.  LSPs seen on one circuit\nin a mesh group will not be flooded to another circuit\nin the same mesh group.")
isisCircMeshGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircMeshGroup.setDescription("Circuits in the same mesh group act as a virtual\nmultiaccess network.  LSPs seen on one circuit in\na mesh group will not be flooded to another circuit\nin the same mesh group.  If isisCircMeshGroupEnabled\nis inactive or blocked, this value is ignored.")
isisCircSmallHellos = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 11), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircSmallHellos.setDescription("Can we send unpadded hellos on LAN circuits?  False\nmeans the LAN Hellos must be padded.\nImplementations should allow the administrator to read\nthis value.  An implementation need not be able to\nsupport unpadded hellos to be conformant.")
isisCircLastUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLastUpTime.setDescription("How long the circuit has been enabled, measured in\nhundredths of seconds since the last re-initialization\nof the network management subsystem; 0 if the\ncircuit has never been 'on'.")
isisCirc3WayEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 13), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCirc3WayEnabled.setDescription("Is this circuit enabled to run 3Way handshake?")
isisCircExtendedCircID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1, 14), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisCircExtendedCircID.setDescription("The value to be used as the extended circuit ID in\n3Way handshake.  This value is only used if\nisisCirc3WayEnabled is true, and it must be unique\nacross all circuits on this IS.")
isisCircLevelValues = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 4))
isisCircLevelTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 4, 1))
if mibBuilder.loadTexts: isisCircLevelTable.setDescription("Level specific information about circuits used by IS-IS.")
isisCircLevelEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisCircLevelIndex"))
if mibBuilder.loadTexts: isisCircLevelEntry.setDescription("An isisCircLevelEntry exists for each level on\neach circuit configured for Integrated IS-IS on\nthis system.\n\nConfigured values MUST survive an agent reboot.")
isisCircLevelIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 1), IsisISLevel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisCircLevelIndex.setDescription("The level that this entry describes.")
isisCircLevelMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 2), IsisDefaultMetric().clone('10')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelMetric.setDescription("The metric value of this circuit for this level.")
isisCircLevelWideMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 3), IsisWideMetric().clone('10')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelWideMetric.setDescription("The wide metric value of this circuit for this level.")
isisCircLevelISPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 4), IsisISPriority().clone('64')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelISPriority.setDescription("The priority for becoming the LAN-Designated\nIntermediate System at this level.")
isisCircLevelIDOctet = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLevelIDOctet.setDescription("A one-byte identifier for the circuit selected by the\nIntermediate System.\n\nOn point-to-point circuits, the value is used as the Local\nCircuit ID in point-to-point IIH PDUs transmitted on this\ncircuit.  In this case, values of isisCircLevelIDOctet do\nnot need to be unique.\n\nFor broadcast circuits, the value is used to generate the\nLAN ID that will be used if this Intermediate System is\nelected as the Designated IS on this circuit.  The value\nis required to differ on LANs where the Intermediate System\nis the Designated Intermediate System.")
isisCircLevelID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 6), IsisCircuitID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLevelID.setDescription("On a point-to-point circuit with a fully initialized\nadjacency to a peer IS, the value of this object is\nthe circuit ID negotiated during adjacency initialization.\n\n\n\nOn a point to point circuit without such an adjacency,\nthe value is the concatenation of the local system ID\nand the one-byte isisCircLevelIDOctet for this circuit,\ni.e., the value that would be proposed for the circuit ID.\nOn other circuit types, the value returned is the zero-\nlength OCTET STRING.")
isisCircLevelDesIS = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 7), IsisCircuitID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLevelDesIS.setDescription("The ID of the LAN-Designated Intermediate System\non this circuit at this level.  If, for any reason,\nthis system is not partaking in the relevant\nDesignated Intermediate System election process,\nthen the value returned is the zero-length OCTET STRING.")
isisCircLevelHelloMultiplier = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelHelloMultiplier.setDescription("This value is multiplied by the corresponding HelloTimer,\nand the result in seconds (rounded up) is used as the\nholding time in transmitted hellos, to be used by\nreceivers of hello packets from this IS.")
isisCircLevelHelloTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 600000)).clone(3000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelHelloTimer.setDescription("Maximum period, in milliseconds, between IIH PDUs\non multiaccess networks at this level for LANs.\nThe value at L1 is used as the period between\nHellos on L1L2 point-to-point circuits.  Setting\nthis value at level 2 on an L1L2 point-to-point\ncircuit will result in an error of InconsistentValue.\n\n\n\n\nThis object follows the ResettingTimer behavior.")
isisCircLevelDRHelloTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 120000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelDRHelloTimer.setDescription("Period, in milliseconds, between Hello PDUs on\nmultiaccess networks when this IS is the Designated\nIntermediate System.  This object follows the\nResettingTimer behavior.")
isisCircLevelLSPThrottle = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 11), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelLSPThrottle.setDescription("Minimal interval of time, in milliseconds, between\ntransmissions of LSPs on an interface at this level.")
isisCircLevelMinLSPRetransInt = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelMinLSPRetransInt.setDescription("Minimum interval, in seconds, between re-transmission of\nan LSP at this level.  This object follows the\nResettingTimer behavior.\n\nNote that isisCircLevelLSPThrottle controls\nhow fast we send back-to-back LSPs.  This variable\ncontrols how fast we re-send the same LSP.")
isisCircLevelCSNPInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelCSNPInterval.setDescription("Interval of time, in seconds, between periodic\ntransmission of a complete set of CSNPs on\nmultiaccess networks if this router is the\ndesignated router at this level.\nThis object follows the ResettingTimer behavior.")
isisCircLevelPartSNPInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 4, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 120)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: isisCircLevelPartSNPInterval.setDescription("Minimum interval, in seconds, between sending Partial\nSequence Number PDUs at this level.  This object\nfollows the ResettingTimer behavior.")
isisCounters = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 5))
isisSystemCounterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 5, 1))
if mibBuilder.loadTexts: isisSystemCounterTable.setDescription("System-wide counters for this Intermediate System.")
isisSystemCounterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisSysStatLevel"))
if mibBuilder.loadTexts: isisSystemCounterEntry.setDescription("System-wide IS-IS counters.")
isisSysStatLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 1), IsisISLevel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisSysStatLevel.setDescription("The level that this entry describes.")
isisSysStatCorrLSPs = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatCorrLSPs.setDescription("Number of corrupted in-memory LSPs detected.\n\nLSPs received from the wire with a bad checksum\nare silently dropped and are not counted.\n\n\n\n\nLSPs received from the wire with parse errors\nare counted by isisSysStatLSPErrors.")
isisSysStatAuthTypeFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatAuthTypeFails.setDescription("The number of authentication type mismatches recognized\nby this Intermediate System.")
isisSysStatAuthFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatAuthFails.setDescription("The number of authentication key failures recognized\nby this Intermediate System.")
isisSysStatLSPDbaseOloads = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatLSPDbaseOloads.setDescription("Number of times the LSP database has become\noverloaded.")
isisSysStatManAddrDropFromAreas = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatManAddrDropFromAreas.setDescription("Number of times a manual address has been dropped from\nthe area.")
isisSysStatAttmptToExMaxSeqNums = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatAttmptToExMaxSeqNums.setDescription("Number of times the IS has attempted to exceed the\nmaximum sequence number.")
isisSysStatSeqNumSkips = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatSeqNumSkips.setDescription("Number of times a sequence number skip has occurred.")
isisSysStatOwnLSPPurges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatOwnLSPPurges.setDescription("Number of times a zero-aged copy of the system's own LSP\nis received from some other node.")
isisSysStatIDFieldLenMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatIDFieldLenMismatches.setDescription("Number of times a PDU is received with a different value\nfor ID field length from that of the receiving system.")
isisSysStatPartChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatPartChanges.setDescription("Partition changes.")
isisSysStatSPFRuns = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatSPFRuns.setDescription("Number of times we ran SPF at this level.")
isisSysStatLSPErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisSysStatLSPErrors.setDescription("Number of LSPs with errors we have received.")
isisCircuitCounterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 5, 2))
if mibBuilder.loadTexts: isisCircuitCounterTable.setDescription("Circuit specific counters for this\nIntermediate System.")
isisCircuitCounterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisCircuitType"))
if mibBuilder.loadTexts: isisCircuitCounterEntry.setDescription("An isisCircuitCounterEntry exists for each circuit\nused by Integrated IS-IS on this system.")
isisCircuitType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("lanlevel1", 1), ("lanlevel2", 2), ("p2pcircuit", 3), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisCircuitType.setDescription("What type of circuit saw these counts?\n\nThe point-to-point Hello PDU includes\nboth L1 and L2, and ISs form a single\nadjacency on point-to-point links.\nThus, we combine counts on\npoint-to-point links into one group.")
isisCircAdjChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircAdjChanges.setDescription("The number of times an adjacency state change has\noccurred on this circuit.")
isisCircNumAdj = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircNumAdj.setDescription("The number of adjacencies on this circuit.")
isisCircInitFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircInitFails.setDescription("The number of times initialization of this circuit has\nfailed.  This counts events such as PPP NCP failures.\nFailures to form an adjacency are counted by\nisisCircRejAdjs.")
isisCircRejAdjs = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircRejAdjs.setDescription("The number of times an adjacency has been rejected on\nthis circuit.")
isisCircIDFieldLenMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircIDFieldLenMismatches.setDescription("The number of times an IS-IS control PDU with an ID\nfield length different from that for this system has been\nreceived.")
isisCircMaxAreaAddrMismatches = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircMaxAreaAddrMismatches.setDescription("The number of times an IS-IS control PDU with a\nmax area address field different from that for this\nsystem has been received.")
isisCircAuthTypeFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircAuthTypeFails.setDescription("The number of times an IS-IS control PDU with\nan auth type field different from that for this\nsystem has been received.")
isisCircAuthFails = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircAuthFails.setDescription("The number of times an IS-IS control PDU with\nthe correct auth type has failed to pass authentication\nvalidation.")
isisCircLANDesISChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisCircLANDesISChanges.setDescription("The number of times the Designated IS has changed\non this circuit at this level.  If the circuit is\npoint to point, this count is zero.")
isisPacketCounterTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 5, 3))
if mibBuilder.loadTexts: isisPacketCounterTable.setDescription("Information about IS-IS protocol traffic at one level,\non one circuit, in one direction.")
isisPacketCounterEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisPacketCountLevel"), (0, "ISIS-MIB", "isisPacketCountDirection"))
if mibBuilder.loadTexts: isisPacketCounterEntry.setDescription("Information about IS-IS protocol traffic at one level,\non one circuit, in one direction.")
isisPacketCountLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 1), IsisISLevel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisPacketCountLevel.setDescription("The level at which these PDU counts have been collected.")
isisPacketCountDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("sending", 1), ("receiving", 2), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisPacketCountDirection.setDescription("Were we sending or receiving these PDUs?")
isisPacketCountIIHello = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountIIHello.setDescription("The number of IS-IS Hello PDUs seen in this\ndirection at this level.\n\nPoint-to-Point IIH PDUs are counted at\nthe lowest enabled level: at L1 on L1 or L1L2 circuits,\nand at L2 otherwise.")
isisPacketCountISHello = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountISHello.setDescription("The number of ES-IS Hello PDUs seen in this\ndirection.  ISH PDUs are counted at the\nlowest enabled level: at L1 on L1 or L1L2\ncircuits, and at L2 otherwise.")
isisPacketCountESHello = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountESHello.setDescription("The number of ES Hello PDUs seen in this\ndirection.  ESH PDUs are counted at the\nlowest enabled level: at L1 on L1 or L1L2\ncircuits, and at L2 otherwise.")
isisPacketCountLSP = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountLSP.setDescription("The number of IS-IS LSPs seen in this\ndirection at this level.")
isisPacketCountCSNP = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountCSNP.setDescription("The number of IS-IS CSNPs seen in this\ndirection at this level.")
isisPacketCountPSNP = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountPSNP.setDescription("The number of IS-IS PSNPs seen in this\ndirection at this level.")
isisPacketCountUnknown = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 5, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisPacketCountUnknown.setDescription("The number of unknown IS-IS PDUs seen\nat this level.")
isisISAdj = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 6))
isisISAdjTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 1))
if mibBuilder.loadTexts: isisISAdjTable.setDescription("The table of adjacencies to Intermediate Systems.")
isisISAdjEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"))
if mibBuilder.loadTexts: isisISAdjEntry.setDescription("Each entry corresponds to one adjacency to an\nIntermediate System on this system.\n\nDynamically learned rows do not survive an agent reboot.")
isisISAdjIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisISAdjIndex.setDescription("A unique value identifying the IS adjacency from all\nother such adjacencies on this circuit.  This value is\nautomatically assigned by the system when the adjacency\nis created.")
isisISAdjState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,4,2,3,)).subtype(namedValues=NamedValues(("down", 1), ("initializing", 2), ("up", 3), ("failed", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjState.setDescription("The state of the adjacency.")
isisISAdj3WayState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,0,)).subtype(namedValues=NamedValues(("up", 0), ("initializing", 1), ("down", 2), ("failed", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdj3WayState.setDescription("The 3Way state of the adjacency.  These are picked\nto match the historical on-the-wire representation\nof the 3Way state and are not intended to match\nisisISAdjState.")
isisISAdjNeighSNPAAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 4), IsisOSINSAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighSNPAAddress.setDescription("The SNPA address of the neighboring system.")
isisISAdjNeighSysType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(4,1,3,2,)).subtype(namedValues=NamedValues(("l1IntermediateSystem", 1), ("l2IntermediateSystem", 2), ("l1L2IntermediateSystem", 3), ("unknown", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighSysType.setDescription("The type of the neighboring system.")
isisISAdjNeighSysID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 6), IsisSystemID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighSysID.setDescription("The system ID of the neighboring Intermediate\nSystem.")
isisISAdjNbrExtendedCircID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNbrExtendedCircID.setDescription("The 4-byte Extended Circuit ID learned from the\nNeighbor during 3-way handshake, or 0.")
isisISAdjUsage = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 8), IsisLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjUsage.setDescription("How is the adjacency used?  On a point-to-point link,\nthis might be level1and2, but on a LAN, the usage will\nbe level1 on the adjacency between peers at L1,\nand level2 for the adjacency between peers at L2.")
isisISAdjHoldTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 9), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjHoldTimer.setDescription("The holding time, in seconds, for this adjacency.\nThis value is based on received IIH PDUs and\nthe elapsed time since receipt.")
isisISAdjNeighPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 10), IsisISPriority()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjNeighPriority.setDescription("Priority of the neighboring Intermediate System for\nbecoming the Designated Intermediate System.")
isisISAdjLastUpTime = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjLastUpTime.setDescription("When the adjacency most recently entered the state 'up',\nmeasured in hundredths of a second since the last\nre-initialization of the network management subsystem.\nHolds 0 if the adjacency has never been in state 'up'.")
isisISAdjAreaAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 2))
if mibBuilder.loadTexts: isisISAdjAreaAddrTable.setDescription("This table contains the set of Area Addresses of\nneighboring Intermediate Systems as reported in received\nIIH PDUs.")
isisISAdjAreaAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 2, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"), (0, "ISIS-MIB", "isisISAdjAreaAddrIndex"))
if mibBuilder.loadTexts: isisISAdjAreaAddrEntry.setDescription("Each entry contains one Area Address reported by a\nneighboring Intermediate System in its IIH PDUs.\n\nDynamically learned rows do not survive an agent reboot.")
isisISAdjAreaAddrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisISAdjAreaAddrIndex.setDescription("An index for the areas associated with one neighbor.\nThis provides a simple way to walk the table.")
isisISAdjAreaAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 2, 1, 2), IsisOSINSAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjAreaAddress.setDescription("One Area Address as reported in IIH PDUs received from\nthe neighbor.")
isisISAdjIPAddrTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 3))
if mibBuilder.loadTexts: isisISAdjIPAddrTable.setDescription("This table contains the set of IP Addresses of\nneighboring Intermediate Systems as reported in received\nIIH PDUs.")
isisISAdjIPAddrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"), (0, "ISIS-MIB", "isisISAdjIPAddrIndex"))
if mibBuilder.loadTexts: isisISAdjIPAddrEntry.setDescription("Each entry contains one IP Address reported by a\nneighboring Intermediate System in its IIH PDUs.\n\nDynamically learned rows do not survive an agent reboot.")
isisISAdjIPAddrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisISAdjIPAddrIndex.setDescription("An index to this table that identifies the IP addresses\nto which this entry belongs.")
isisISAdjIPAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjIPAddrType.setDescription("The type of one IP Address as reported in IIH PDUs\n\n\n\nreceived from the neighbor.")
isisISAdjIPAddrAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjIPAddrAddress.setDescription("One IP Address as reported in IIH PDUs received from the\nneighbor.\n\nThe type of this address is determined by the value of\nthe isisISAdjIPAddrType object.")
isisISAdjProtSuppTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 6, 4))
if mibBuilder.loadTexts: isisISAdjProtSuppTable.setDescription("This table contains the set of protocols supported by\nneighboring Intermediate Systems as reported in received\nIIH PDUs.")
isisISAdjProtSuppEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 6, 4, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisISAdjIndex"), (0, "ISIS-MIB", "isisISAdjProtSuppProtocol"))
if mibBuilder.loadTexts: isisISAdjProtSuppEntry.setDescription("Each entry contains one protocol supported by a\nneighboring Intermediate System as reported in its IIH\nPDUs.\n\nDynamically learned rows do not survive an agent reboot.")
isisISAdjProtSuppProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 6, 4, 1, 1), IsisSupportedProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisISAdjProtSuppProtocol.setDescription("One supported protocol as reported in IIH PDUs received\nfrom the neighbor.")
isisReachAddr = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 7))
isisRATable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 7, 1))
if mibBuilder.loadTexts: isisRATable.setDescription("The table of Reachable Addresses to NSAPs or Address\nPrefixes.")
isisRAEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisCircIndex"), (0, "ISIS-MIB", "isisRAIndex"))
if mibBuilder.loadTexts: isisRAEntry.setDescription("Each entry defines a configured Reachable Address\nto an NSAP or Address Prefix.\n\nDynamically created rows MUST survive an agent reboot.")
isisRAIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisRAIndex.setDescription("The identifier for this isisRAEntry.  This value must be\nunique amongst all Reachable Addresses on the same parent\nCircuit.")
isisRAExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAExistState.setDescription("The existence state of this Reachable Address.  This\nobject follows the ManualOrAutomatic behaviors.  Support\nfor 'createAndWait' and 'notInService' is not required.\n\nA row entry cannot be modified when the value of this\nobject is 'active'.")
isisRAAdminState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 3), IsisAdminState().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAAdminState.setDescription("The administrative state of the Reachable Address.  This\nobject follows the ManualOrAutomatic behaviors.")
isisRAAddrPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 4), IsisOSINSAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAAddrPrefix.setDescription("The destination of this Reachable Address.  This is an\nAddress Prefix.  This object follows the\nReplaceOnlyWhileDisabled and ManualOrAutomatic\nbehaviors.")
isisRAMapType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,4,)).subtype(namedValues=NamedValues(("none", 1), ("explicit", 2), ("extractIDI", 3), ("extractDSP", 4), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAMapType.setDescription("The type of mapping to be employed to ascertain the SNPA\nAddress that should be used in forwarding PDUs for this\nReachable Address prefix.  This object follows the\nManualOrAutomatic behavior.  The following values of\nmapping type are defined:\n\n    none: The mapping is null because the neighbor SNPA is\n          implicit by nature of the subnetwork (e.g., a\n          point-to-point linkage).\n\n    explicit: The subnetwork addresses in the object\n          isisRASNPAAddress are to be used.\n\n    extractIDI: The SNPA is embedded in the IDI of\n          the destination NSAP Address.  The mapping\n          algorithm extracts the SNPA to be used\n          according to the format and encoding rules of\n          ISO8473/Add2.  This SNPA extraction algorithm can\n          be used in conjunction with Reachable Address\n          prefixes from the X.121, F.69, E.163, and E.164\n\n\n\n          addressing subdomains.\n\n    extractDSP: All, or a suffix, of the SNPA is embedded\n          in the DSP of the destination address.  This SNPA\n          extraction algorithm extracts the embedded\n          subnetwork addressing information by performing a\n          logical AND of the isisRASNPAMask object value\n          with the destination address.  The part of the\n          SNPA extracted from the destination NSAP is\n          appended to the isisRASNPAPrefix object value to\n          form the next hop subnetwork addressing\n          information.")
isisRAMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 6), IsisDefaultMetric().clone('20')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAMetric.setDescription("The metric value for reaching the specified\nprefix over this circuit.  This object follows the\nManualOrAutomatic behavior.")
isisRAMetricType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 7), IsisMetricType().clone('internal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAMetricType.setDescription("Indicates whether the metric is internal or\nexternal.  This object follows the ManualOrAutomatic\nbehavior.")
isisRASNPAAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 8), IsisOSINSAddress().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRASNPAAddress.setDescription("The SNPA Address to which a PDU may be forwarded in\norder to reach a destination that matches the address\nprefix of the Reachable Address.  This object follows the\n\n\n\nManualOrAutomatic behavior.")
isisRASNPAMask = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 9), IsisOSINSAddress().clone(hexValue='00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRASNPAMask.setDescription("A bit mask with 1 bit indicating the positions in the\neffective destination address from which embedded SNPA\ninformation is to be extracted.  For the extraction, the\nfirst octet of the isisRASNPAMask object value is aligned\nwith the first octet (AFI) of the NSAP Address.  If the\nisisRASNPAMask object value and NSAP Address are of\ndifferent lengths, the shorter of the two is logically\npadded with zeros before performing the extraction.  This\nobject follows the ManualOrAutomatic behavior.")
isisRASNPAPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 10), IsisOSINSAddress().clone(hexValue='00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRASNPAPrefix.setDescription("A fixed SNPA prefix for use when the isisRAMapType is\nextractDSP.  The SNPA Address to use is formed by\nconcatenating the fixed SNPA prefix with a variable SNPA\npart that is extracted from the effective destination\naddress.  For Reachable Address prefixes in which the\nentire SNPA is embedded in the DSP, the SNPA Prefix shall\nbe null.  This object follows the ManualOrAutomatic\nbehavior.")
isisRAType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1, 11), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("manual", 1), ("automatic", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisRAType.setDescription("The type of Reachable address.  Those of type\nmanual are created by the network manager.  Those\nof type automatic are created through propagation\nof routing information from another routing\nprotocol (e.g., IDRP). ")
isisIPReachAddr = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 8))
isisIPRATable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 8, 1))
if mibBuilder.loadTexts: isisIPRATable.setDescription("The table of IP Reachable Addresses to networks,\nsubnetworks, or hosts either manually configured or\nlearned from another protocol.")
isisIPRAEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisSysLevelIndex"), (0, "ISIS-MIB", "isisIPRADestType"), (0, "ISIS-MIB", "isisIPRADest"), (0, "ISIS-MIB", "isisIPRADestPrefixLen"), (0, "ISIS-MIB", "isisIPRANextHopIndex"))
if mibBuilder.loadTexts: isisIPRAEntry.setDescription("Each entry defines an IP Reachable Address to a network,\nsubnetwork, or host.\n\nEach IP Reachable Address may have multiple entries in the\ntable, one for each equal cost path to the reachable\naddress.\n\nDynamically created rows MUST survive an agent reboot.\n\nImplementers need to be aware that if the total number\nof elements (octets or sub-identifiers) in\nisisIPRADestr, isisIPRADestPrefixLen, and\nisisIPRANextHopIndex is too great, then OIDs of column\ninstances in this table will have more than 128\nsubidentifiers and cannot be accessed using SNMPv1,\n\n\n\nSNMPv2c, or SNMPv3.")
isisIPRADestType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisIPRADestType.setDescription("The type of this IP Reachable Address.")
isisIPRADest = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisIPRADest.setDescription("The destination of this IP Reachable Address.  This is\na network address, subnetwork address, or host\naddress.\n\nThe type of this address is determined by the value of\nthe isisIPRADestType object.")
isisIPRADestPrefixLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 3), InetAddressPrefixLength()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisIPRADestPrefixLen.setDescription("The length of the IP Netmask for Reachability Address.\n\nThe values for the index objects isisIPRADest and\nisisIPRADestPrefixLen must be consistent.  When the value\nof isisIPRADest (excluding the zone index, if one\nis present) is x, then the bitwise logical-AND\nof x with the value of the mask formed from the\ncorresponding index object isisIPRADestPrefixLen MUST be\nequal to x.  If not, then the index pair is not\nconsistent, and an inconsistentName error must be\nreturned on SET or CREATE requests.")
isisIPRANextHopIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisIPRANextHopIndex.setDescription("Index of next hop.  Used when there are multiple Equal\nCost Multipath alternatives for the same destination.")
isisIPRANextHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 5), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRANextHopType.setDescription("The type of the IP next hop address.")
isisIPRANextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRANextHop.setDescription("The IP next hop to this destination.\n\nThe type of this address is determined by the value of\nthe isisIPRANextHopType object.")
isisIPRAType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("manual", 1), ("automatic", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAType.setDescription("The type of this IP Reachable Address.  Those of type\nmanual are created by the network manager.  Those of type\nautomatic are created through propagation of routing\ninformation from another routing protocol.  This object\nfollows the ManualOrAutomatic behavior.")
isisIPRAExistState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAExistState.setDescription("The state of this IP Reachable Address.  This object\nfollows the ExistenceState and ManualOrAutomatic\nbehaviors.  Support for 'createAndWait' and\n'notInService' is not required.\n\nA row entry cannot be modified when the value of this\nobject is 'active'.")
isisIPRAAdminState = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 9), IsisAdminState().clone('off')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAAdminState.setDescription("The administrative state of the IP Reachable Address.  This\nobject follows the IsisAdminState and ManualOrAutomatic\n\n\n\nbehaviors.")
isisIPRAMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 10), IsisDefaultMetric().clone('10')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAMetric.setDescription("The metric value for reaching the specified\ndestination over this circuit.  This object follows the\nManualOrAutomatic behavior.")
isisIPRAMetricType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 11), IsisMetricType().clone('internal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAMetricType.setDescription("Indicates whether the metric is internal or\nexternal.  This object follows the ManualOrAutomatic\nbehavior.")
isisIPRAFullMetric = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 12), IsisFullMetric().clone('10')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRAFullMetric.setDescription("The wide metric value for reaching the specified\ndestination over this circuit.  This object follows the\nManualOrAutomatic behavior.")
isisIPRASNPAAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 13), IsisOSINSAddress().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: isisIPRASNPAAddress.setDescription("The SNPA Address to which a PDU may be forwarded in\norder to reach a destination that matches this IP\nReachable Address.  This object follows the\nManualOrAutomatic behavior.")
isisIPRASourceType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(7,2,6,1,5,3,4,9,8,10,)).subtype(namedValues=NamedValues(("static", 1), ("other", 10), ("direct", 2), ("ospfv2", 3), ("ospfv3", 4), ("isis", 5), ("rip", 6), ("igrp", 7), ("eigrp", 8), ("bgp", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisIPRASourceType.setDescription("The origin of this route.")
isisLSPDataBase = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 9))
isisLSPSummaryTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 9, 1))
if mibBuilder.loadTexts: isisLSPSummaryTable.setDescription("The table of LSP Headers.")
isisLSPSummaryEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1)).setIndexNames((0, "ISIS-MIB", "isisLSPLevel"), (0, "ISIS-MIB", "isisLSPID"))
if mibBuilder.loadTexts: isisLSPSummaryEntry.setDescription("Each entry provides a summary describing an\nLSP currently stored in the system.\n\nDynamically learned rows will not survive an\nagent reboot.")
isisLSPLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 1), IsisISLevel()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisLSPLevel.setDescription("At which level does this LSP appear?")
isisLSPID = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 2), IsisLinkStatePDUID()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisLSPID.setDescription("The 8-byte LSP ID for this Link State PDU.")
isisLSPSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPSeq.setDescription("The sequence number for this LSP.")
isisLSPZeroLife = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPZeroLife.setDescription("Is this LSP being purged by this system?")
isisLSPChecksum = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 5), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPChecksum.setDescription("The 16-bit Fletcher Checksum for this LSP.")
isisLSPLifetimeRemain = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 6), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPLifetimeRemain.setDescription("The remaining lifetime, in seconds, for this LSP.")
isisLSPPDULength = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 7), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPPDULength.setDescription("The length of this LSP.")
isisLSPAttributes = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 1, 1, 8), IsisUnsigned8TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPAttributes.setDescription("Flags carried by the LSP.")
isisLSPTLVTable = MibTable((1, 3, 6, 1, 2, 1, 138, 1, 9, 2))
if mibBuilder.loadTexts: isisLSPTLVTable.setDescription("The table of LSPs in the database.")
isisLSPTLVEntry = MibTableRow((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1)).setIndexNames((0, "ISIS-MIB", "isisLSPLevel"), (0, "ISIS-MIB", "isisLSPID"), (0, "ISIS-MIB", "isisLSPTLVIndex"))
if mibBuilder.loadTexts: isisLSPTLVEntry.setDescription("Each entry describes a TLV within\nan LSP currently stored in the system.\n\nDynamically learned rows will not survive an\nagent reboot.")
isisLSPTLVIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: isisLSPTLVIndex.setDescription("The index of this TLV in the LSP.  The first TLV has\nindex 1, and the Nth TLV has an index of N.")
isisLSPTLVSeq = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVSeq.setDescription("The sequence number for this LSP.")
isisLSPTLVChecksum = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 3), IsisUnsigned16TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVChecksum.setDescription("The 16-bit Fletcher Checksum for this LSP.")
isisLSPTLVType = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 4), IsisUnsigned8TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVType.setDescription("The type of this TLV.")
isisLSPTLVLen = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 5), IsisUnsigned8TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVLen.setDescription("The length of this TLV.")
isisLSPTLVValue = MibTableColumn((1, 3, 6, 1, 2, 1, 138, 1, 9, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isisLSPTLVValue.setDescription("The value of this TLV.")
isisNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 10))
isisNotificationEntry = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 1, 10, 1))
isisNotificationSysLevelIndex = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 1), IsisLevel()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisNotificationSysLevelIndex.setDescription("The system level for this notification.")
isisNotificationCircIfIndex = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisNotificationCircIfIndex.setDescription("The identifier of this circuit relevant to\nthis notification.")
isisPduLspId = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 3), IsisLinkStatePDUID()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduLspId.setDescription("An Octet String that uniquely identifies\na Link State PDU.")
isisPduFragment = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 4), IsisPDUHeader()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduFragment.setDescription("Holds up to 64 initial bytes of a PDU that\ntriggered the notification.")
isisPduFieldLen = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 5), IsisUnsigned8TC()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduFieldLen.setDescription("Holds the System ID length reported in PDU we received.")
isisPduMaxAreaAddress = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 6), IsisUnsigned8TC()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduMaxAreaAddress.setDescription("Holds the Max Area Addresses reported in a PDU\nwe received.")
isisPduProtocolVersion = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 7), IsisUnsigned8TC()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduProtocolVersion.setDescription("Holds the Protocol version reported in PDU we received.")
isisPduLspSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduLspSize.setDescription("Holds the size of LSP we received that is too\nbig to forward.")
isisPduOriginatingBufferSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 9), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduOriginatingBufferSize.setDescription("Holds the size of isisSysLevelOrigLSPBuffSize advertised\nby the peer in the originatingLSPBufferSize TLV.\nIf the peer does not advertise this TLV, this\nvalue is set to 0.")
isisPduBufferSize = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 10), IsisUnsigned16TC().subtype(subtypeSpec=ValueRangeConstraint(0, 16000))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduBufferSize.setDescription("Holds the size of LSP received from peer.")
isisPduProtocolsSupported = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisPduProtocolsSupported.setDescription("The list of protocols supported by an\nadjacent system.  This may be empty.")
isisAdjState = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(1,4,2,3,)).subtype(namedValues=NamedValues(("down", 1), ("initializing", 2), ("up", 3), ("failed", 4), ))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisAdjState.setDescription("The current state of an adjacency.")
isisErrorOffset = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 13), Unsigned32()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisErrorOffset.setDescription("An offset to a problem in a PDU.  If the problem\nis a malformed TLV, this points to the beginning\nof the TLV.  If the problem is in the header, this\npoints to the byte that is suspicious.")
isisErrorTLVType = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisErrorTLVType.setDescription("The type for a malformed TLV.")
isisNotificationAreaAddress = MibScalar((1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 15), IsisOSINSAddress()).setMaxAccess("notifyonly")
if mibBuilder.loadTexts: isisNotificationAreaAddress.setDescription("An Area Address.")
isisConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 2))
isisCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 2, 1))
isisGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 138, 2, 2))

# Augmentions

# Notifications

isisDatabaseOverload = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 1)).setObjects(*(("ISIS-MIB", "isisSysLevelState"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisDatabaseOverload.setDescription("This notification is generated when the system\nenters or leaves the Overload state.  The number\nof times this has been generated and cleared is kept\ntrack of by isisSysStatLSPDbaseOloads.")
isisManualAddressDrops = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 2)).setObjects(*(("ISIS-MIB", "isisNotificationAreaAddress"), ) )
if mibBuilder.loadTexts: isisManualAddressDrops.setDescription("This notification is generated when one of the\nmanual areaAddresses assigned to this system is\nignored when computing routes.  The object\nisisNotificationAreaAddress describes the area that\nhas been dropped.\n\nThe number of times this event has been generated\nis counted by isisSysStatManAddrDropFromAreas.\n\nThe agent must throttle the generation of\nconsecutive isisManualAddressDrops notifications\nso that there is at least a 5-second gap between\nnotifications of this type.  When notifications\nare throttled, they are dropped, not queued for\nsending at a future time.")
isisCorruptedLSPDetected = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 3)).setObjects(*(("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisCorruptedLSPDetected.setDescription("This notification is generated when we find that\nan LSP that was stored in memory has become\ncorrupted.  The number of times this has been\ngenerated is counted by isisSysCorrLSPs.\n\nWe forward an LSP ID.  We may have independent\nknowledge of the ID, but in some implementations\nthere is a chance that the ID itself will be\ncorrupted.")
isisAttemptToExceedMaxSequence = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 4)).setObjects(*(("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisAttemptToExceedMaxSequence.setDescription("When the sequence number on an LSP we generate\nwraps the 32-bit sequence counter, we purge and\nwait to re-announce this information.  This\nnotification describes that event.  Since these\nshould not be generated rapidly, we generate\nan event each time this happens.\n\nWhile the first 6 bytes of the LSPID are ours,\nthe other two contain useful information.")
isisIDLenMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 5)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFieldLen"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisIDLenMismatch.setDescription("A notification sent when we receive a PDU\nwith a different value for the System ID Length.\nThis notification includes an index to identify\nthe circuit where we saw the PDU and the header of\nthe PDU, which may help a network manager identify\nthe source of the confusion.\n\nThe agent must throttle the generation of\nconsecutive isisIDLenMismatch notifications\nso that there is at least a 5-second gap between\nnotifications of this type.  When notifications\nare throttled, they are dropped, not queued for\nsending at a future time.")
isisMaxAreaAddressesMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 6)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduMaxAreaAddress"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisMaxAreaAddressesMismatch.setDescription("A notification sent when we receive a PDU\nwith a different value for the Maximum Area\nAddresses.  This notification includes the\nheader of the packet, which may help a\nnetwork manager identify the source of the\nconfusion.\n\nThe agent must throttle the generation of\nconsecutive isisMaxAreaAddressesMismatch\nnotifications so that there is at least a 5-second\ngap between notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisOwnLSPPurge = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 7)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisOwnLSPPurge.setDescription("A notification sent when we receive a PDU\nwith our systemID and zero age.  This\nnotification includes the circuit Index\nand router ID from the LSP, if available,\nwhich may help a network manager\nidentify the source of the confusion.")
isisSequenceNumberSkip = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 8)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisSequenceNumberSkip.setDescription("When we receive an LSP with our System ID\nand different contents, we may need to reissue\nthe LSP with a higher sequence number.\n\nWe send this notification if we need to increase\nthe sequence number by more than one.  If two\nIntermediate Systems are configured with the same\nSystem ID, this notification will fire.")
isisAuthenticationTypeFailure = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 9)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisAuthenticationTypeFailure.setDescription("A notification sent when we receive a PDU\nwith the wrong authentication type field.\nThis notification includes the header of the\npacket, which may help a network manager\nidentify the source of the confusion.\n\nThe agent must throttle the generation of\nconsecutive isisAuthenticationTypeFailure\nnotifications so that there is at least a 5-second\ngap between notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisAuthenticationFailure = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 10)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisAuthenticationFailure.setDescription("A notification sent when we receive a PDU\nwith an incorrect authentication information\nfield.  This notification includes the header\nof the packet, which may help a network manager\nidentify the source of the confusion.\n\n\n\nThe agent must throttle the generation of\nconsecutive isisAuthenticationFailure\nnotifications so that there is at least a 5-second\ngap between notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisVersionSkew = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 11)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduProtocolVersion"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisVersionSkew.setDescription("A notification sent when we receive a Hello\nPDU from an IS running a different version\nof the protocol.  This notification includes\nthe header of the packet, which may help a\nnetwork manager identify the source of the\nconfusion.\n\nThe agent must throttle the generation of\nconsecutive isisVersionSkew notifications\nso that there is at least a 5-second gap\nbetween notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisAreaMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 12)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"), ) )
if mibBuilder.loadTexts: isisAreaMismatch.setDescription("A notification sent when we receive a Hello\nPDU from an IS that does not share any\narea address.  This notification includes\nthe header of the packet, which may help a\nnetwork manager identify the source of the\nconfusion.\n\n\n\n\nThe agent must throttle the generation of\nconsecutive isisAreaMismatch notifications\nso that there is at least a 5-second gap\nbetween notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisRejectedAdjacency = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 13)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisRejectedAdjacency.setDescription("A notification sent when we receive a Hello\nPDU from an IS but do not establish an\nadjacency for some reason.\n\nThe agent must throttle the generation of\nconsecutive isisRejectedAdjacency notifications\nso that there is at least a 5-second gap\nbetween notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisLSPTooLargeToPropagate = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 14)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspSize"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisLSPTooLargeToPropagate.setDescription("A notification sent when we attempt to propagate\nan LSP that is larger than the dataLinkBlockSize\nfor the circuit.\n\nThe agent must throttle the generation of\nconsecutive isisLSPTooLargeToPropagate notifications\nso that there is at least a 5-second gap\nbetween notifications of this type.  When\nnotifications are throttled, they are dropped, not\n\n\n\nqueued for sending at a future time.")
isisOrigLSPBuffSizeMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 15)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduBufferSize"), ("ISIS-MIB", "isisPduOriginatingBufferSize"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisOrigLSPBuffSizeMismatch.setDescription("A notification sent when a Level 1 LSP or Level\n2 LSP is received that is larger than the local\nvalue for isisSysLevelOrigLSPBuffSize, or when an\nLSP is received that contains the supported Buffer Size\noption and the value in the PDU option field does\nnot match the local value for isisSysLevelOrigLSPBuffSize.\nWe pass up the size from the option field and the\nsize of the LSP when one of them exceeds our configuration.\n\nThe agent must throttle the generation of\nconsecutive isisOrigLSPBuffSizeMismatch notifications\nso that there is at least a 5-second gap\nbetween notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisProtocolsSupportedMismatch = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 16)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduProtocolsSupported"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisProtocolsSupportedMismatch.setDescription("A notification sent when a non-pseudonode\nsegment 0 LSP is received that has no matching\nprotocols supported.  This may be because the system\ndoes not generate the field, or because there are no\ncommon elements.  The list of protocols supported\nshould be included in the notification: it may be\n\n\n\nempty if the TLV is not supported, or if the\nTLV is empty.\n\nThe agent must throttle the generation of\nconsecutive isisProtocolsSupportedMismatch\nnotifications so that there is at least a 5-second\ngap between notifications of this type.  When\nnotifications are throttled, they are dropped, not\nqueued for sending at a future time.")
isisAdjacencyChange = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 17)).setObjects(*(("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisAdjState"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisAdjacencyChange.setDescription("A notification sent when an adjacency changes\nstate, entering or leaving state up.\nThe first 6 bytes of the isisPduLspId are the\nSystemID of the adjacent IS.\nThe isisAdjState is the new state of the adjacency.")
isisLSPErrorDetected = NotificationType((1, 3, 6, 1, 2, 1, 138, 0, 18)).setObjects(*(("ISIS-MIB", "isisErrorTLVType"), ("ISIS-MIB", "isisErrorOffset"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisLSPErrorDetected.setDescription("This notification is generated when we receive\nan LSP with a parse error.  The isisCircIfIndex\nholds an index of the circuit on which the PDU\narrived.  The isisPduFragment holds the start of the\nLSP, and the isisErrorOffset points to the problem.\n\nIf the problem is a malformed TLV, isisErrorOffset\npoints to the start of the TLV, and isisErrorTLVType\n\n\n\nholds the value of the type.\n\nIf the problem is with the LSP header, isisErrorOffset\npoints to the suspicious byte.\n\nThe number of such LSPs is accumulated in\nisisSysStatLSPErrors.")

# Groups

isisSystemGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 1)).setObjects(*(("ISIS-MIB", "isisSysMaxAge"), ("ISIS-MIB", "isisSysMaxLSPGenInt"), ("ISIS-MIB", "isisSysStatSeqNumSkips"), ("ISIS-MIB", "isisSummAddrMetric"), ("ISIS-MIB", "isisSysLevelOrigLSPBuffSize"), ("ISIS-MIB", "isisSysLevelSPFConsiders"), ("ISIS-MIB", "isisSysStatCorrLSPs"), ("ISIS-MIB", "isisSysLevelTEEnabled"), ("ISIS-MIB", "isisSummAddrExistState"), ("ISIS-MIB", "isisSysLevelSetOverload"), ("ISIS-MIB", "isisSysReceiveLSPBufferSize"), ("ISIS-MIB", "isisSysAdminState"), ("ISIS-MIB", "isisSysVersion"), ("ISIS-MIB", "isisSummAddrFullMetric"), ("ISIS-MIB", "isisSysWaitTime"), ("ISIS-MIB", "isisSysLevelType"), ("ISIS-MIB", "isisRouterID"), ("ISIS-MIB", "isisRouterHostName"), ("ISIS-MIB", "isisSysLevelMinLSPGenInt"), ("ISIS-MIB", "isisSysStatManAddrDropFromAreas"), ("ISIS-MIB", "isisSysStatOwnLSPPurges"), ("ISIS-MIB", "isisSysID"), ("ISIS-MIB", "isisSysProtSupported"), ("ISIS-MIB", "isisSysStatLSPErrors"), ("ISIS-MIB", "isisSysMaxPathSplits"), ("ISIS-MIB", "isisSysStatIDFieldLenMismatches"), ("ISIS-MIB", "isisSysL2toL1Leaking"), ("ISIS-MIB", "isisRedistributeAddrExistState"), ("ISIS-MIB", "isisSysStatAttmptToExMaxSeqNums"), ("ISIS-MIB", "isisSysStatAuthFails"), ("ISIS-MIB", "isisSysStatPartChanges"), ("ISIS-MIB", "isisSysLevelSetOverloadUntil"), ("ISIS-MIB", "isisAreaAddr"), ("ISIS-MIB", "isisSysStatAuthTypeFails"), ("ISIS-MIB", "isisSysNotificationEnable"), ("ISIS-MIB", "isisManAreaAddrExistState"), ("ISIS-MIB", "isisSysLevelMetricStyle"), ("ISIS-MIB", "isisSysLevelState"), ("ISIS-MIB", "isisSysPollESHelloRate"), ("ISIS-MIB", "isisSysStatLSPDbaseOloads"), ("ISIS-MIB", "isisSysStatSPFRuns"), ) )
if mibBuilder.loadTexts: isisSystemGroup.setDescription("The collections of objects used to manage an\nIS-IS router.")
isisCircuitGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 2)).setObjects(*(("ISIS-MIB", "isisCircType"), ("ISIS-MIB", "isisCircLevelMetric"), ("ISIS-MIB", "isisCircAuthFails"), ("ISIS-MIB", "isisCircLANDesISChanges"), ("ISIS-MIB", "isisCircIfIndex"), ("ISIS-MIB", "isisCircIDFieldLenMismatches"), ("ISIS-MIB", "isisCircLevelType"), ("ISIS-MIB", "isisCircLevelDRHelloTimer"), ("ISIS-MIB", "isisCircSmallHellos"), ("ISIS-MIB", "isisCirc3WayEnabled"), ("ISIS-MIB", "isisCircMeshGroupEnabled"), ("ISIS-MIB", "isisCircExtDomain"), ("ISIS-MIB", "isisCircNumAdj"), ("ISIS-MIB", "isisCircLevelMinLSPRetransInt"), ("ISIS-MIB", "isisCircLevelID"), ("ISIS-MIB", "isisCircLevelWideMetric"), ("ISIS-MIB", "isisCircLevelLSPThrottle"), ("ISIS-MIB", "isisCircLevelISPriority"), ("ISIS-MIB", "isisCircAuthTypeFails"), ("ISIS-MIB", "isisCircAdminState"), ("ISIS-MIB", "isisCircLevelPartSNPInterval"), ("ISIS-MIB", "isisCircMaxAreaAddrMismatches"), ("ISIS-MIB", "isisCircPassiveCircuit"), ("ISIS-MIB", "isisCircExistState"), ("ISIS-MIB", "isisCircLevelHelloMultiplier"), ("ISIS-MIB", "isisCircLevelDesIS"), ("ISIS-MIB", "isisCircLevelHelloTimer"), ("ISIS-MIB", "isisCircInitFails"), ("ISIS-MIB", "isisCircLastUpTime"), ("ISIS-MIB", "isisCircLevelIDOctet"), ("ISIS-MIB", "isisCircMeshGroup"), ("ISIS-MIB", "isisCircAdjChanges"), ("ISIS-MIB", "isisCircExtendedCircID"), ("ISIS-MIB", "isisNextCircIndex"), ("ISIS-MIB", "isisCircRejAdjs"), ("ISIS-MIB", "isisCircLevelCSNPInterval"), ) )
if mibBuilder.loadTexts: isisCircuitGroup.setDescription("The collections of objects used to describe an\nIS-IS Circuit.")
isisISAdjGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 3)).setObjects(*(("ISIS-MIB", "isisISAdjUsage"), ("ISIS-MIB", "isisISAdjState"), ("ISIS-MIB", "isisISAdjLastUpTime"), ("ISIS-MIB", "isisISAdjNeighPriority"), ("ISIS-MIB", "isisISAdjNeighSNPAAddress"), ("ISIS-MIB", "isisISAdjNeighSysType"), ("ISIS-MIB", "isisISAdjIPAddrType"), ("ISIS-MIB", "isisISAdjNbrExtendedCircID"), ("ISIS-MIB", "isisISAdjNeighSysID"), ("ISIS-MIB", "isisISAdjAreaAddress"), ("ISIS-MIB", "isisISAdj3WayState"), ("ISIS-MIB", "isisISAdjHoldTimer"), ("ISIS-MIB", "isisISAdjIPAddrAddress"), ("ISIS-MIB", "isisISAdjProtSuppProtocol"), ) )
if mibBuilder.loadTexts: isisISAdjGroup.setDescription("The collections of objects used to manage an\nIS-IS Adjacency.")
isisNotificationObjectGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 4)).setObjects(*(("ISIS-MIB", "isisErrorTLVType"), ("ISIS-MIB", "isisErrorOffset"), ("ISIS-MIB", "isisPduFragment"), ("ISIS-MIB", "isisPduProtocolsSupported"), ("ISIS-MIB", "isisPduProtocolVersion"), ("ISIS-MIB", "isisNotificationAreaAddress"), ("ISIS-MIB", "isisPduFieldLen"), ("ISIS-MIB", "isisPduOriginatingBufferSize"), ("ISIS-MIB", "isisPduBufferSize"), ("ISIS-MIB", "isisAdjState"), ("ISIS-MIB", "isisPduMaxAreaAddress"), ("ISIS-MIB", "isisPduLspSize"), ("ISIS-MIB", "isisPduLspId"), ("ISIS-MIB", "isisNotificationCircIfIndex"), ("ISIS-MIB", "isisNotificationSysLevelIndex"), ) )
if mibBuilder.loadTexts: isisNotificationObjectGroup.setDescription("The objects used to record notification parameters.")
isisNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 5)).setObjects(*(("ISIS-MIB", "isisOwnLSPPurge"), ("ISIS-MIB", "isisProtocolsSupportedMismatch"), ("ISIS-MIB", "isisSequenceNumberSkip"), ("ISIS-MIB", "isisAdjacencyChange"), ("ISIS-MIB", "isisMaxAreaAddressesMismatch"), ("ISIS-MIB", "isisRejectedAdjacency"), ("ISIS-MIB", "isisLSPErrorDetected"), ("ISIS-MIB", "isisOrigLSPBuffSizeMismatch"), ("ISIS-MIB", "isisAreaMismatch"), ("ISIS-MIB", "isisLSPTooLargeToPropagate"), ("ISIS-MIB", "isisDatabaseOverload"), ("ISIS-MIB", "isisAuthenticationFailure"), ("ISIS-MIB", "isisAttemptToExceedMaxSequence"), ("ISIS-MIB", "isisIDLenMismatch"), ("ISIS-MIB", "isisAuthenticationTypeFailure"), ("ISIS-MIB", "isisVersionSkew"), ("ISIS-MIB", "isisManualAddressDrops"), ("ISIS-MIB", "isisCorruptedLSPDetected"), ) )
if mibBuilder.loadTexts: isisNotificationGroup.setDescription("The collections of notifications sent by an IS.")
isisISPDUCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 6)).setObjects(*(("ISIS-MIB", "isisPacketCountUnknown"), ("ISIS-MIB", "isisPacketCountLSP"), ("ISIS-MIB", "isisPacketCountCSNP"), ("ISIS-MIB", "isisPacketCountIIHello"), ("ISIS-MIB", "isisPacketCountESHello"), ("ISIS-MIB", "isisPacketCountISHello"), ("ISIS-MIB", "isisPacketCountPSNP"), ) )
if mibBuilder.loadTexts: isisISPDUCounterGroup.setDescription("The collections of objects used to count protocol PDUs.")
isisRATableGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 7)).setObjects(*(("ISIS-MIB", "isisRAAddrPrefix"), ("ISIS-MIB", "isisRAAdminState"), ("ISIS-MIB", "isisRASNPAAddress"), ("ISIS-MIB", "isisRAMetricType"), ("ISIS-MIB", "isisRAMetric"), ("ISIS-MIB", "isisRASNPAPrefix"), ("ISIS-MIB", "isisRAType"), ("ISIS-MIB", "isisRAExistState"), ("ISIS-MIB", "isisRAMapType"), ("ISIS-MIB", "isisRASNPAMask"), ) )
if mibBuilder.loadTexts: isisRATableGroup.setDescription("The collections of objects used to manage the\n\n\n\nreachable NSAP prefixes.")
isisISIPRADestGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 8)).setObjects(*(("ISIS-MIB", "isisIPRAFullMetric"), ("ISIS-MIB", "isisIPRAAdminState"), ("ISIS-MIB", "isisIPRASourceType"), ("ISIS-MIB", "isisIPRAExistState"), ("ISIS-MIB", "isisIPRAMetric"), ("ISIS-MIB", "isisIPRANextHop"), ("ISIS-MIB", "isisIPRAType"), ("ISIS-MIB", "isisIPRASNPAAddress"), ("ISIS-MIB", "isisIPRAMetricType"), ("ISIS-MIB", "isisIPRANextHopType"), ) )
if mibBuilder.loadTexts: isisISIPRADestGroup.setDescription("The collections of objects used to manage configured\nIP addresses.")
isisLSPGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 138, 2, 2, 9)).setObjects(*(("ISIS-MIB", "isisLSPTLVLen"), ("ISIS-MIB", "isisLSPZeroLife"), ("ISIS-MIB", "isisLSPTLVSeq"), ("ISIS-MIB", "isisLSPSeq"), ("ISIS-MIB", "isisLSPLifetimeRemain"), ("ISIS-MIB", "isisLSPAttributes"), ("ISIS-MIB", "isisLSPTLVChecksum"), ("ISIS-MIB", "isisLSPTLVType"), ("ISIS-MIB", "isisLSPChecksum"), ("ISIS-MIB", "isisLSPPDULength"), ("ISIS-MIB", "isisLSPTLVValue"), ) )
if mibBuilder.loadTexts: isisLSPGroup.setDescription("The collections of objects used to observe the LSP\nDatabase.")

# Compliances

isisCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 138, 2, 1, 1)).setObjects(*(("ISIS-MIB", "isisISAdjGroup"), ("ISIS-MIB", "isisNotificationGroup"), ("ISIS-MIB", "isisNotificationObjectGroup"), ("ISIS-MIB", "isisCircuitGroup"), ("ISIS-MIB", "isisSystemGroup"), ) )
if mibBuilder.loadTexts: isisCompliance.setDescription("The compliance statement for agents that support\nthe IS-IS MIB.\n\nThere are a number of INDEX objects that cannot be\nrepresented in the form of OBJECT clauses in SMIv2,\nbut for which there are compliance requirements.\nThose requirements and similar requirements for\nrelated objects are expressed below, in\npseudo-OBJECT clause form, in this description:\n\n-- OBJECT isisSummAddressType\n-- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n--\n-- DESCRIPTION\n--    The MIB requires support for IPv4 Summary\n--    Addresses and anticipates the support of\n--    IPv6 addresses.\n--\n--\n-- OBJECT isisRedistributeAddrType\n-- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n--\n-- DESCRIPTION\n--    The MIB requires support for IPv4\n--    Redistribution Addresses and anticipates\n--    the support of IPv6 addresses.")
isisAdvancedCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 138, 2, 1, 2)).setObjects(*(("ISIS-MIB", "isisISIPRADestGroup"), ("ISIS-MIB", "isisISPDUCounterGroup"), ("ISIS-MIB", "isisRATableGroup"), ("ISIS-MIB", "isisNotificationObjectGroup"), ("ISIS-MIB", "isisSystemGroup"), ("ISIS-MIB", "isisLSPGroup"), ("ISIS-MIB", "isisISAdjGroup"), ("ISIS-MIB", "isisNotificationGroup"), ("ISIS-MIB", "isisCircuitGroup"), ) )
if mibBuilder.loadTexts: isisAdvancedCompliance.setDescription("The compliance statement for agents that fully\nsupport the IS-IS MIB.\n\nThere are a number of INDEX objects that cannot be\nrepresented in the form of OBJECT clauses in SMIv2,\nbut for which there are compliance requirements.\nThose requirements and similar requirements for\nrelated objects are expressed below, in\npseudo-OBJECT clause form, in this description:\n\n-- OBJECT isisSummAddressType\n-- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n--\n-- DESCRIPTION\n--    The MIB requires support for IPv4 Summary\n--    Addresses and anticipates the support of\n--    IPv6 addresses.\n--\n--\n-- OBJECT isisRedistributeAddrType\n-- SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n--\n-- DESCRIPTION\n--    The MIB requires support for IPv4\n--    Redistribution Addresses and anticipates\n--    the support of IPv6 addresses.")
isisReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 138, 2, 1, 3)).setObjects(*(("ISIS-MIB", "isisISAdjGroup"), ("ISIS-MIB", "isisCircuitGroup"), ("ISIS-MIB", "isisSystemGroup"), ) )
if mibBuilder.loadTexts: isisReadOnlyCompliance.setDescription("When this MIB is implemented without support for\nread-create (i.e., in read-only mode), the\nimplementation can claim read-only compliance.  Such\na device can then be monitored but cannot be\n\n\n\nconfigured with this MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("ISIS-MIB", PYSNMP_MODULE_ID=isisMIB)

# Types
mibBuilder.exportSymbols("ISIS-MIB", IsisAdminState=IsisAdminState, IsisCircuitID=IsisCircuitID, IsisDefaultMetric=IsisDefaultMetric, IsisFullMetric=IsisFullMetric, IsisISLevel=IsisISLevel, IsisISPriority=IsisISPriority, IsisLSPBuffSize=IsisLSPBuffSize, IsisLevel=IsisLevel, IsisLevelState=IsisLevelState, IsisLinkStatePDUID=IsisLinkStatePDUID, IsisMetricStyle=IsisMetricStyle, IsisMetricType=IsisMetricType, IsisOSINSAddress=IsisOSINSAddress, IsisPDUHeader=IsisPDUHeader, IsisSupportedProtocol=IsisSupportedProtocol, IsisSystemID=IsisSystemID, IsisUnsigned16TC=IsisUnsigned16TC, IsisUnsigned8TC=IsisUnsigned8TC, IsisWideMetric=IsisWideMetric)

# Objects
mibBuilder.exportSymbols("ISIS-MIB", isisMIB=isisMIB, isisNotifications=isisNotifications, isisObjects=isisObjects, isisSystem=isisSystem, isisSysObject=isisSysObject, isisSysVersion=isisSysVersion, isisSysLevelType=isisSysLevelType, isisSysID=isisSysID, isisSysMaxPathSplits=isisSysMaxPathSplits, isisSysMaxLSPGenInt=isisSysMaxLSPGenInt, isisSysPollESHelloRate=isisSysPollESHelloRate, isisSysWaitTime=isisSysWaitTime, isisSysAdminState=isisSysAdminState, isisSysL2toL1Leaking=isisSysL2toL1Leaking, isisSysMaxAge=isisSysMaxAge, isisSysReceiveLSPBufferSize=isisSysReceiveLSPBufferSize, isisSysProtSupported=isisSysProtSupported, isisSysNotificationEnable=isisSysNotificationEnable, isisManAreaAddrTable=isisManAreaAddrTable, isisManAreaAddrEntry=isisManAreaAddrEntry, isisManAreaAddr=isisManAreaAddr, isisManAreaAddrExistState=isisManAreaAddrExistState, isisAreaAddrTable=isisAreaAddrTable, isisAreaAddrEntry=isisAreaAddrEntry, isisAreaAddr=isisAreaAddr, isisSummAddrTable=isisSummAddrTable, isisSummAddrEntry=isisSummAddrEntry, isisSummAddressType=isisSummAddressType, isisSummAddress=isisSummAddress, isisSummAddrPrefixLen=isisSummAddrPrefixLen, isisSummAddrExistState=isisSummAddrExistState, isisSummAddrMetric=isisSummAddrMetric, isisSummAddrFullMetric=isisSummAddrFullMetric, isisRedistributeAddrTable=isisRedistributeAddrTable, isisRedistributeAddrEntry=isisRedistributeAddrEntry, isisRedistributeAddrType=isisRedistributeAddrType, isisRedistributeAddrAddress=isisRedistributeAddrAddress, isisRedistributeAddrPrefixLen=isisRedistributeAddrPrefixLen, isisRedistributeAddrExistState=isisRedistributeAddrExistState, isisRouterTable=isisRouterTable, isisRouterEntry=isisRouterEntry, isisRouterSysID=isisRouterSysID, isisRouterLevel=isisRouterLevel, isisRouterHostName=isisRouterHostName, isisRouterID=isisRouterID, isisSysLevel=isisSysLevel, isisSysLevelTable=isisSysLevelTable, isisSysLevelEntry=isisSysLevelEntry, isisSysLevelIndex=isisSysLevelIndex, isisSysLevelOrigLSPBuffSize=isisSysLevelOrigLSPBuffSize, isisSysLevelMinLSPGenInt=isisSysLevelMinLSPGenInt, isisSysLevelState=isisSysLevelState, isisSysLevelSetOverload=isisSysLevelSetOverload, isisSysLevelSetOverloadUntil=isisSysLevelSetOverloadUntil, isisSysLevelMetricStyle=isisSysLevelMetricStyle, isisSysLevelSPFConsiders=isisSysLevelSPFConsiders, isisSysLevelTEEnabled=isisSysLevelTEEnabled, isisCirc=isisCirc, isisNextCircIndex=isisNextCircIndex, isisCircTable=isisCircTable, isisCircEntry=isisCircEntry, isisCircIndex=isisCircIndex, isisCircIfIndex=isisCircIfIndex, isisCircAdminState=isisCircAdminState, isisCircExistState=isisCircExistState, isisCircType=isisCircType, isisCircExtDomain=isisCircExtDomain, isisCircLevelType=isisCircLevelType, isisCircPassiveCircuit=isisCircPassiveCircuit, isisCircMeshGroupEnabled=isisCircMeshGroupEnabled, isisCircMeshGroup=isisCircMeshGroup, isisCircSmallHellos=isisCircSmallHellos, isisCircLastUpTime=isisCircLastUpTime, isisCirc3WayEnabled=isisCirc3WayEnabled, isisCircExtendedCircID=isisCircExtendedCircID, isisCircLevelValues=isisCircLevelValues, isisCircLevelTable=isisCircLevelTable, isisCircLevelEntry=isisCircLevelEntry, isisCircLevelIndex=isisCircLevelIndex, isisCircLevelMetric=isisCircLevelMetric, isisCircLevelWideMetric=isisCircLevelWideMetric, isisCircLevelISPriority=isisCircLevelISPriority, isisCircLevelIDOctet=isisCircLevelIDOctet, isisCircLevelID=isisCircLevelID, isisCircLevelDesIS=isisCircLevelDesIS, isisCircLevelHelloMultiplier=isisCircLevelHelloMultiplier, isisCircLevelHelloTimer=isisCircLevelHelloTimer, isisCircLevelDRHelloTimer=isisCircLevelDRHelloTimer, isisCircLevelLSPThrottle=isisCircLevelLSPThrottle, isisCircLevelMinLSPRetransInt=isisCircLevelMinLSPRetransInt, isisCircLevelCSNPInterval=isisCircLevelCSNPInterval, isisCircLevelPartSNPInterval=isisCircLevelPartSNPInterval, isisCounters=isisCounters, isisSystemCounterTable=isisSystemCounterTable, isisSystemCounterEntry=isisSystemCounterEntry, isisSysStatLevel=isisSysStatLevel, isisSysStatCorrLSPs=isisSysStatCorrLSPs, isisSysStatAuthTypeFails=isisSysStatAuthTypeFails, isisSysStatAuthFails=isisSysStatAuthFails, isisSysStatLSPDbaseOloads=isisSysStatLSPDbaseOloads, isisSysStatManAddrDropFromAreas=isisSysStatManAddrDropFromAreas, isisSysStatAttmptToExMaxSeqNums=isisSysStatAttmptToExMaxSeqNums, isisSysStatSeqNumSkips=isisSysStatSeqNumSkips, isisSysStatOwnLSPPurges=isisSysStatOwnLSPPurges, isisSysStatIDFieldLenMismatches=isisSysStatIDFieldLenMismatches, isisSysStatPartChanges=isisSysStatPartChanges, isisSysStatSPFRuns=isisSysStatSPFRuns, isisSysStatLSPErrors=isisSysStatLSPErrors, isisCircuitCounterTable=isisCircuitCounterTable, isisCircuitCounterEntry=isisCircuitCounterEntry, isisCircuitType=isisCircuitType, isisCircAdjChanges=isisCircAdjChanges, isisCircNumAdj=isisCircNumAdj, isisCircInitFails=isisCircInitFails, isisCircRejAdjs=isisCircRejAdjs, isisCircIDFieldLenMismatches=isisCircIDFieldLenMismatches, isisCircMaxAreaAddrMismatches=isisCircMaxAreaAddrMismatches, isisCircAuthTypeFails=isisCircAuthTypeFails, isisCircAuthFails=isisCircAuthFails, isisCircLANDesISChanges=isisCircLANDesISChanges, isisPacketCounterTable=isisPacketCounterTable, isisPacketCounterEntry=isisPacketCounterEntry, isisPacketCountLevel=isisPacketCountLevel, isisPacketCountDirection=isisPacketCountDirection, isisPacketCountIIHello=isisPacketCountIIHello, isisPacketCountISHello=isisPacketCountISHello)
mibBuilder.exportSymbols("ISIS-MIB", isisPacketCountESHello=isisPacketCountESHello, isisPacketCountLSP=isisPacketCountLSP, isisPacketCountCSNP=isisPacketCountCSNP, isisPacketCountPSNP=isisPacketCountPSNP, isisPacketCountUnknown=isisPacketCountUnknown, isisISAdj=isisISAdj, isisISAdjTable=isisISAdjTable, isisISAdjEntry=isisISAdjEntry, isisISAdjIndex=isisISAdjIndex, isisISAdjState=isisISAdjState, isisISAdj3WayState=isisISAdj3WayState, isisISAdjNeighSNPAAddress=isisISAdjNeighSNPAAddress, isisISAdjNeighSysType=isisISAdjNeighSysType, isisISAdjNeighSysID=isisISAdjNeighSysID, isisISAdjNbrExtendedCircID=isisISAdjNbrExtendedCircID, isisISAdjUsage=isisISAdjUsage, isisISAdjHoldTimer=isisISAdjHoldTimer, isisISAdjNeighPriority=isisISAdjNeighPriority, isisISAdjLastUpTime=isisISAdjLastUpTime, isisISAdjAreaAddrTable=isisISAdjAreaAddrTable, isisISAdjAreaAddrEntry=isisISAdjAreaAddrEntry, isisISAdjAreaAddrIndex=isisISAdjAreaAddrIndex, isisISAdjAreaAddress=isisISAdjAreaAddress, isisISAdjIPAddrTable=isisISAdjIPAddrTable, isisISAdjIPAddrEntry=isisISAdjIPAddrEntry, isisISAdjIPAddrIndex=isisISAdjIPAddrIndex, isisISAdjIPAddrType=isisISAdjIPAddrType, isisISAdjIPAddrAddress=isisISAdjIPAddrAddress, isisISAdjProtSuppTable=isisISAdjProtSuppTable, isisISAdjProtSuppEntry=isisISAdjProtSuppEntry, isisISAdjProtSuppProtocol=isisISAdjProtSuppProtocol, isisReachAddr=isisReachAddr, isisRATable=isisRATable, isisRAEntry=isisRAEntry, isisRAIndex=isisRAIndex, isisRAExistState=isisRAExistState, isisRAAdminState=isisRAAdminState, isisRAAddrPrefix=isisRAAddrPrefix, isisRAMapType=isisRAMapType, isisRAMetric=isisRAMetric, isisRAMetricType=isisRAMetricType, isisRASNPAAddress=isisRASNPAAddress, isisRASNPAMask=isisRASNPAMask, isisRASNPAPrefix=isisRASNPAPrefix, isisRAType=isisRAType, isisIPReachAddr=isisIPReachAddr, isisIPRATable=isisIPRATable, isisIPRAEntry=isisIPRAEntry, isisIPRADestType=isisIPRADestType, isisIPRADest=isisIPRADest, isisIPRADestPrefixLen=isisIPRADestPrefixLen, isisIPRANextHopIndex=isisIPRANextHopIndex, isisIPRANextHopType=isisIPRANextHopType, isisIPRANextHop=isisIPRANextHop, isisIPRAType=isisIPRAType, isisIPRAExistState=isisIPRAExistState, isisIPRAAdminState=isisIPRAAdminState, isisIPRAMetric=isisIPRAMetric, isisIPRAMetricType=isisIPRAMetricType, isisIPRAFullMetric=isisIPRAFullMetric, isisIPRASNPAAddress=isisIPRASNPAAddress, isisIPRASourceType=isisIPRASourceType, isisLSPDataBase=isisLSPDataBase, isisLSPSummaryTable=isisLSPSummaryTable, isisLSPSummaryEntry=isisLSPSummaryEntry, isisLSPLevel=isisLSPLevel, isisLSPID=isisLSPID, isisLSPSeq=isisLSPSeq, isisLSPZeroLife=isisLSPZeroLife, isisLSPChecksum=isisLSPChecksum, isisLSPLifetimeRemain=isisLSPLifetimeRemain, isisLSPPDULength=isisLSPPDULength, isisLSPAttributes=isisLSPAttributes, isisLSPTLVTable=isisLSPTLVTable, isisLSPTLVEntry=isisLSPTLVEntry, isisLSPTLVIndex=isisLSPTLVIndex, isisLSPTLVSeq=isisLSPTLVSeq, isisLSPTLVChecksum=isisLSPTLVChecksum, isisLSPTLVType=isisLSPTLVType, isisLSPTLVLen=isisLSPTLVLen, isisLSPTLVValue=isisLSPTLVValue, isisNotification=isisNotification, isisNotificationEntry=isisNotificationEntry, isisNotificationSysLevelIndex=isisNotificationSysLevelIndex, isisNotificationCircIfIndex=isisNotificationCircIfIndex, isisPduLspId=isisPduLspId, isisPduFragment=isisPduFragment, isisPduFieldLen=isisPduFieldLen, isisPduMaxAreaAddress=isisPduMaxAreaAddress, isisPduProtocolVersion=isisPduProtocolVersion, isisPduLspSize=isisPduLspSize, isisPduOriginatingBufferSize=isisPduOriginatingBufferSize, isisPduBufferSize=isisPduBufferSize, isisPduProtocolsSupported=isisPduProtocolsSupported, isisAdjState=isisAdjState, isisErrorOffset=isisErrorOffset, isisErrorTLVType=isisErrorTLVType, isisNotificationAreaAddress=isisNotificationAreaAddress, isisConformance=isisConformance, isisCompliances=isisCompliances, isisGroups=isisGroups)

# Notifications
mibBuilder.exportSymbols("ISIS-MIB", isisDatabaseOverload=isisDatabaseOverload, isisManualAddressDrops=isisManualAddressDrops, isisCorruptedLSPDetected=isisCorruptedLSPDetected, isisAttemptToExceedMaxSequence=isisAttemptToExceedMaxSequence, isisIDLenMismatch=isisIDLenMismatch, isisMaxAreaAddressesMismatch=isisMaxAreaAddressesMismatch, isisOwnLSPPurge=isisOwnLSPPurge, isisSequenceNumberSkip=isisSequenceNumberSkip, isisAuthenticationTypeFailure=isisAuthenticationTypeFailure, isisAuthenticationFailure=isisAuthenticationFailure, isisVersionSkew=isisVersionSkew, isisAreaMismatch=isisAreaMismatch, isisRejectedAdjacency=isisRejectedAdjacency, isisLSPTooLargeToPropagate=isisLSPTooLargeToPropagate, isisOrigLSPBuffSizeMismatch=isisOrigLSPBuffSizeMismatch, isisProtocolsSupportedMismatch=isisProtocolsSupportedMismatch, isisAdjacencyChange=isisAdjacencyChange, isisLSPErrorDetected=isisLSPErrorDetected)

# Groups
mibBuilder.exportSymbols("ISIS-MIB", isisSystemGroup=isisSystemGroup, isisCircuitGroup=isisCircuitGroup, isisISAdjGroup=isisISAdjGroup, isisNotificationObjectGroup=isisNotificationObjectGroup, isisNotificationGroup=isisNotificationGroup, isisISPDUCounterGroup=isisISPDUCounterGroup, isisRATableGroup=isisRATableGroup, isisISIPRADestGroup=isisISIPRADestGroup, isisLSPGroup=isisLSPGroup)

# Compliances
mibBuilder.exportSymbols("ISIS-MIB", isisCompliance=isisCompliance, isisAdvancedCompliance=isisAdvancedCompliance, isisReadOnlyCompliance=isisReadOnlyCompliance)
