# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-ATM-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:48 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( atmInterfaceConfEntry, atmVclEntry, atmVplEntry, ) = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry", "atmVclEntry", "atmVplEntry")
( ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "ifIndex")
( InetAddressIPv4, InetAddressIPv6, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4", "InetAddressIPv6")
( jnxMibs, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")
( TextualConvention, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention")

# Types

class JnxAtmFlags(Bits):
    namedValues = NamedValues(("inverseArpEnabled", 0), ("ilmiEnabled", 1), ("oamEnabled", 2), ("shapingEnabled", 3), ("passiveOam", 4), ("multicast", 5), ("closed", 6), ("down", 7), ("active", 8), ("cosEnabled", 9), )
    

# Objects

jnxAtm = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 10)).setRevisions(("2004-01-06 00:00","2003-12-04 00:00","2003-12-04 00:00","2003-09-17 00:00","2002-07-04 00:00","2002-01-23 00:00","2001-07-08 00:00",))
if mibBuilder.loadTexts: jnxAtm.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxAtm.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxAtm.setDescription("The Juniper enterprise MIB for ATM interfaces and VCs")
jnxAtmIfTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1))
if mibBuilder.loadTexts: jnxAtmIfTable.setDescription("This table contains config and stats parameters, one entry per\nphysical interface (ATM port).")
jnxAtmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1))
if mibBuilder.loadTexts: jnxAtmIfEntry.setDescription("This entry contains additional ATM interface config and stats\nobjects, not covered in standard mibs. Each entry is an extension\nof atmInterfaceConfEntry defined in ATM-MIB.")
jnxAtmIfPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(6,3,4,1,2,5,)).subtype(namedValues=NamedValues(("other", 1), ("oc3", 2), ("oc12", 3), ("t3", 4), ("e3", 5), ("oc48", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfPortType.setDescription("The physical port type.")
jnxAtmIfEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("atmPvc", 2), ("atmCccCellRelay", 3), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfEncaps.setDescription("ATM physical link layer encapsulation.")
jnxAtmIfLpBackInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("noLoopBack", 1), ("localLoopBack", 2), ("remoteLoopBack", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfLpBackInfo.setDescription("Loop back config and type.")
jnxAtmIfScrambleEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfScrambleEnable.setDescription("Shows whether scrambling is enabled or disabled")
jnxAtmIfTxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfTxCellCount.setDescription("The number of ATM cells transmitted by the interface.\nIncludes Idle cells transmitted.")
jnxAtmIfRxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfRxCellCount.setDescription("The number of ATM cells received by the interface.\nExcludes Idle cells received.")
jnxAtmIfTxIdleCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfTxIdleCellCount.setDescription("The number of idle cells sent by the port. When the ATM interface\nhas nothing to send, it sends idle cells to fill the time slot.")
jnxAtmIfUncorrHCSErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfUncorrHCSErrs.setDescription("The number of uncorrectable cell Header Check Sequence (HCS) Errors\nthat occurred.")
jnxAtmIfCorrHCSErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfCorrHCSErrs.setDescription("The number of correctable cell Header Check Sequence (HCS) Errors\nthat occurred.")
jnxAtmIfTxCellFIFOOverRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfTxCellFIFOOverRuns.setDescription("The number of overruns in the Transmit FIFO.")
jnxAtmIfRxCellFIFOOverRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfRxCellFIFOOverRuns.setDescription("The number of overruns in the Receive FIFO.")
jnxAtmIfRxCellFIFOUnderRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfRxCellFIFOUnderRuns.setDescription("The number of underruns in the receive FIFO.")
jnxAtmIfInInvalidVCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInInvalidVCCells.setDescription("The number of Cells that arrived for non existent VC.")
jnxAtmIfInNoBufferOAMCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInNoBufferOAMCells.setDescription("The number of received OAM cells or raw cells dropped because \nno buffers were available to handle them.")
jnxAtmIfInNoBufDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInNoBufDropPkts.setDescription("The number of AAL5 packets dropped because there was no enough\nbuffer to handle them.")
jnxAtmIfOutVCQueueDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfOutVCQueueDrops.setDescription("The number of packets dropped because of queue limits on each VC.")
jnxAtmIfInBadCrcs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInBadCrcs.setDescription("The total number of incoming CRC errors.")
jnxAtmIfInLenErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInLenErrPkts.setDescription("The number of AAL5 packets dropped because their length was incorrect.")
jnxAtmIfInTimeoutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 19), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfInTimeoutPkts.setDescription("The number of AAL5 packets dropped because of reassembly timeout.")
jnxAtmIfL2CircuitMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 1, 1, 20), Integer().subtype(subtypeSpec=SingleValueConstraint(2,5,6,3,4,1,)).subtype(namedValues=NamedValues(("notApplicable", 1), ("none", 2), ("aal5", 3), ("cell", 4), ("uniTrunk", 5), ("nniTrunk", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmIfL2CircuitMode.setDescription("The layer 2 circuit mode of this Atm interface.  Note, this\napplies only to interfaces on AtmII pics.")
jnxAtmVCTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2))
if mibBuilder.loadTexts: jnxAtmVCTable.setDescription("A table of all p2p/p2mp/multicast VC entries.")
jnxAtmVCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1))
if mibBuilder.loadTexts: jnxAtmVCEntry.setDescription("Special Cases: \n- No traffic Stats for multicast VCs. (0 by default).\n- Multipoint Destination IP Address for a p2p vc is \n  invalid (0.0.0.0 by default).\n- When the encapsulation type for the logical interface \n  (to which VC belongs) is 'atmCccCellRelay', only \n  Generic VC Info is valid.\n- If OAM is disabled (indicated in jnxAtmVCFlags),\n  then all the OAM config & F5 stats info is invalid.\n  (zeroed by default).")
jnxAtmVCConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(4,1,2,3,)).subtype(namedValues=NamedValues(("other", 1), ("p2p", 2), ("p2mp", 3), ("multicast", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCConnType.setDescription("The type of connection.  The type 'other' means vc type is unknown\nor is not one of the other types.")
jnxAtmVCEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(7,1,6,9,5,2,8,3,4,)).subtype(namedValues=NamedValues(("other", 1), ("atmCccCellRelay", 2), ("atmCccVcMux", 3), ("atmCiscoNlpid", 4), ("atmNlpid", 5), ("atmSnap", 6), ("atmVcMux", 7), ("atmTccVcMux", 8), ("atmTccSnap", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCEncapsulation.setDescription("The atm encapsulation type associated with the VC. \natmCccCellRelay : ATM Cell Relay for CCC\natmCccVcMux     : ATM VC for CCC\natmCiscoNlpid   : Cisco-compatible ATM NLPID encapsulation\natmNlpid        : ATM NLPID encapsulation\natmSnap         : ATM LLC/SNAP encapsulation\natmVcMux        : ATM VC multiplexing\natmTccVcMux     : TCC (Translational Cross Connection)\n                  over ATM VC MUX encapsulation \natmTccSnap      : TCC (Translational Cross Connection)\n                  over ATM LLC/SNAP encapsulation")
jnxAtmVCMpDestIPv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 3), InetAddressIPv4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCMpDestIPv4Addr.setDescription("This object is meaningful only if jnxAtmVCConnType value is \n'p2mp' (point-to-multipoint). For a p2mp VC, it's the multipoint \n destination IPv4 address. When the VC connection type is other\n than p2mp OR when the multipoint destination address type is of\n IPv6, this object returns 0.0.0.0 by default.")
jnxAtmVCMpDestIPv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 4), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCMpDestIPv6Addr.setDescription("This object is meaningful only if jnxAtmVCConnType value is \n'p2mp' (point-to-multipoint). For a p2mp VC, it's the multipoint \n destination IPv6 address. When the VC connection type is other\n than p2mp OR when the multipoint destination address type is of\n IPv4, this object returns all the bytes of addr filled with 0.")
jnxAtmVCFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 5), JnxAtmFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCFlags.setDescription("Flags related to the VC.")
jnxAtmVCTotalDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCTotalDownTime.setDescription("The total VC down time in seconds ever since the system rebooted.")
jnxAtmVCInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInBytes.setDescription("The number of bytes received on the VC.")
jnxAtmVCOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutBytes.setDescription("The number of bytes sent out on the VC.")
jnxAtmVCInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInPkts.setDescription("The number of packets received on the VC.")
jnxAtmVCOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutPkts.setDescription("The number of packets sent out on the VC.")
jnxAtmVCTailQueuePktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCTailQueuePktDrops.setDescription("The number of packets dropped due to bandwidth constraints. \nIndicates that packets were queued to send out at a rate faster \nthan allowed.")
jnxAtmVCOAMPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOAMPeriod.setDescription("This time interval indicates how often the F5 cells are sent to\nknow the status of the VC.")
jnxAtmVCOAMUpCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOAMUpCellCount.setDescription("The minimum number of loopback cells to be received to declare \nthat the VC is up.")
jnxAtmVCOAMDownCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOAMDownCellCount.setDescription("The minimum number of loopback cells to be received to declare \nthat the VC is down. This object would have zero value if OAM is\nnot enabled. (indicated in jnxAtmVCFlags)")
jnxAtmVCInOAMF5LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInOAMF5LoopCells.setDescription("The number of OAM F5 loopback cells received. This object would \nhave zero value if OAM (as indicated in jnxAtmVCFlags) is not \nenabled.")
jnxAtmVCOutOAMF5LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5LoopCells.setDescription("The number of OAM F5 loopback cells sent. This object would have\nzero value if OAM (as indicated in jnxAtmVCFlags) is not \nenabled.")
jnxAtmVCInOAMF5RDICells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInOAMF5RDICells.setDescription("The number of OAM F5 cells received, with RDI(Remote Defect \nIndication) bit set. This object would have zero value if OAM \n(as indicated in jnxAtmVCFlags) is not enabled.")
jnxAtmVCOutOAMF5RDICells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5RDICells.setDescription("The number of OAM F5 cells transmitted, with RDI(Remote Defect\nIndication) bit set. This object would have zero value if OAM \n(as indicated in jnxAtmVCFlags) is not enabled.")
jnxAtmVCInOAMF5AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCInOAMF5AISCells.setDescription("The number of OAM F5 cells received, with AIS(Alarm Indication\nSignal) bit set. This object would have zero value if OAM (as \nindicated in jnxAtmVCFlags) is not enabled.")
jnxAtmVCOutOAMF5AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVCOutOAMF5AISCells.setDescription("The number of OAM F5 cells transmitted, with AIS (Alarm\nIndication Signal) bit set. This object would have zero\nvalue if OAM (as indicated in jnxAtmVCFlags) is not\nenabled.")
jnxAtmVpTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3))
if mibBuilder.loadTexts: jnxAtmVpTable.setDescription("The table of ATM VPs. This table augments atmVplTable\ndefined in standard ATM mib.")
jnxAtmVpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1))
if mibBuilder.loadTexts: jnxAtmVpEntry.setDescription("Each entry represents config, status and statistics info related\nto an ATM VP configured. This entry augments the atmVplEntry\ndefined in standard ATM mib (RFC 2515). So ifIndex and VPI are the\nindices to this table.\n\nCaveats:\n- Traffic stats are available per VP tunnel, only if shaping is\n  configured on the VP. Object 'jnxAtmVpFlags' can be used to\n  determine if shaping is enabled.\n\n- When no OAM is configured, OAM config and OAM stat objects'\n  values are invalid (zero by default). Object 'jnxAtmVpFlags'\n  contains info on whether OAM is configured or not.\n\n- For atm-1 VPs, the only valid object is jnxAtmVpFlags.")
jnxAtmVpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 1), Bits().subtype(namedValues=NamedValues(("active", 0), ("down", 1), ("oamEnabled", 2), ("shapingEnabled", 3), ("passiveOam", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpFlags.setDescription("The flags associated with this VP.")
jnxAtmVpTotalDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpTotalDownTime.setDescription("The total VP downtime in seconds, ever since the system rebooted.")
jnxAtmVpOamPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOamPeriod.setDescription("This time interval indicates how often the OAM F4 cells are sent\nto determine the status of the VP. The value of this object is zero\nwhen OAM is not enabled on the VP. Object 'jnxAtmVpFlags' can be used\nto determine if OAM is enabled.")
jnxAtmVpOamUpCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOamUpCellCount.setDescription("The minimum number of consecutive loopback cells to be received to\ndeclare that the VP is up. The value of this object is zero when\nOAM is not enabled on the VP. Object 'jnxAtmVpFlags' can be used to\ndetermine if OAM is enabled.")
jnxAtmVpOamDownCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOamDownCellCount.setDescription("The minimum number of consecutive loopback cells to be received to\ndeclare that the VP is down. The value of this object is zero when\nOAM is not enabled on the VP. Object 'jnxAtmVpFlags' can be used to\ndetermine if OAM is enabled.")
jnxAtmVpInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInBytes.setDescription("The number of bytes received on the VP.")
jnxAtmVpOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutBytes.setDescription("The number of bytes sent out on the VP.")
jnxAtmVpInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInPkts.setDescription("The number of packets received on the VP.")
jnxAtmVpOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutPkts.setDescription("The number of packets sent out on the VP.")
jnxAtmVpInOamF4Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4Cells.setDescription("The number of OAM F4 cells received on the VP.")
jnxAtmVpOutOamF4Cells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutOamF4Cells.setDescription("The number of OAM F4 cells transmitted on the VP.")
jnxAtmVpInOamF4LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4LoopCells.setDescription("The number of OAM F4 loopback cells received on the VP.")
jnxAtmVpOutOamF4LoopCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutOamF4LoopCells.setDescription("The number of OAM F4 cells transmitted on the VP.")
jnxAtmVpInOamF4RdiCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4RdiCells.setDescription("The number of OAM F4 RDI cells received on the VP.")
jnxAtmVpOutOamF4RdiCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpOutOamF4RdiCells.setDescription("The number of OAM F4 RDI cells transmitted on the VP.")
jnxAtmVpInOamF4AisCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmVpInOamF4AisCells.setDescription("The number of OAM F4 AIS cells received on the VP.")
jnxAtmTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4))
if mibBuilder.loadTexts: jnxAtmTrunkTable.setDescription("A table of all ATM Trunk entries.")
jnxAtmTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: jnxAtmTrunkEntry.setDescription("Special Cases: \n- When the encapsulation type for the logical interface \n  (to which Trunk belongs) is 'atmCccCellRelay', only \n  Generic Trunk Info is valid.")
jnxAtmTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkId.setDescription("The identifier for this ATM Trunk.")
jnxAtmTrunkConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("other", 1), ("p2p", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkConnType.setDescription("The type of connection.  The type 'other' means trunk type is \nunknown or is not one of the other types.")
jnxAtmTrunkEncapsulation = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("other", 1), ("atmCccCellRelay", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkEncapsulation.setDescription("The atm encapsulation type associated with the VC or Trunk. \natmCccCellRelay : ATM Cell Relay for CCC")
jnxAtmTrunkFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 4), JnxAtmFlags()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkFlags.setDescription("Flags related to the Trunk.")
jnxAtmTrunkTotalDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkTotalDownTime.setDescription("The total Trunk down time in seconds ever since the system rebooted.")
jnxAtmTrunkInBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkInBytes.setDescription("The number of bytes received on the Trunk.")
jnxAtmTrunkOutBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkOutBytes.setDescription("The number of bytes sent out on the Trunk.")
jnxAtmTrunkInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkInPkts.setDescription("The number of packets received on the Trunk.")
jnxAtmTrunkOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkOutPkts.setDescription("The number of packets sent out on the Trunk.")
jnxAtmTrunkTailQueuePktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkTailQueuePktDrops.setDescription("The number of packets dropped due to bandwidth constraints. \nIndicates that packets were queued to send out at a rate faster \nthan allowed.")
jnxAtmTrunkInOAMF4AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkInOAMF4AISCells.setDescription("The number of OAM F4 cells received, with AIS(Alarm Indication\nSignal) bit set.")
jnxAtmTrunkOutOAMF4AISCells = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 10, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxAtmTrunkOutOAMF4AISCells.setDescription("The number of OAM F4 cells sent, with AIS(Alarm Indication\nSignal) bit set.")

# Augmentions
atmInterfaceConfEntry, = mibBuilder.importSymbols("ATM-MIB", "atmInterfaceConfEntry")
atmInterfaceConfEntry.registerAugmentions(("JUNIPER-ATM-MIB", "jnxAtmIfEntry"))
jnxAtmIfEntry.setIndexNames(*atmInterfaceConfEntry.getIndexNames())
atmVclEntry, = mibBuilder.importSymbols("ATM-MIB", "atmVclEntry")
atmVclEntry.registerAugmentions(("JUNIPER-ATM-MIB", "jnxAtmVCEntry"))
jnxAtmVCEntry.setIndexNames(*atmVclEntry.getIndexNames())
atmVplEntry, = mibBuilder.importSymbols("ATM-MIB", "atmVplEntry")
atmVplEntry.registerAugmentions(("JUNIPER-ATM-MIB", "jnxAtmVpEntry"))
jnxAtmVpEntry.setIndexNames(*atmVplEntry.getIndexNames())

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-ATM-MIB", PYSNMP_MODULE_ID=jnxAtm)

# Types
mibBuilder.exportSymbols("JUNIPER-ATM-MIB", JnxAtmFlags=JnxAtmFlags)

# Objects
mibBuilder.exportSymbols("JUNIPER-ATM-MIB", jnxAtm=jnxAtm, jnxAtmIfTable=jnxAtmIfTable, jnxAtmIfEntry=jnxAtmIfEntry, jnxAtmIfPortType=jnxAtmIfPortType, jnxAtmIfEncaps=jnxAtmIfEncaps, jnxAtmIfLpBackInfo=jnxAtmIfLpBackInfo, jnxAtmIfScrambleEnable=jnxAtmIfScrambleEnable, jnxAtmIfTxCellCount=jnxAtmIfTxCellCount, jnxAtmIfRxCellCount=jnxAtmIfRxCellCount, jnxAtmIfTxIdleCellCount=jnxAtmIfTxIdleCellCount, jnxAtmIfUncorrHCSErrs=jnxAtmIfUncorrHCSErrs, jnxAtmIfCorrHCSErrs=jnxAtmIfCorrHCSErrs, jnxAtmIfTxCellFIFOOverRuns=jnxAtmIfTxCellFIFOOverRuns, jnxAtmIfRxCellFIFOOverRuns=jnxAtmIfRxCellFIFOOverRuns, jnxAtmIfRxCellFIFOUnderRuns=jnxAtmIfRxCellFIFOUnderRuns, jnxAtmIfInInvalidVCCells=jnxAtmIfInInvalidVCCells, jnxAtmIfInNoBufferOAMCells=jnxAtmIfInNoBufferOAMCells, jnxAtmIfInNoBufDropPkts=jnxAtmIfInNoBufDropPkts, jnxAtmIfOutVCQueueDrops=jnxAtmIfOutVCQueueDrops, jnxAtmIfInBadCrcs=jnxAtmIfInBadCrcs, jnxAtmIfInLenErrPkts=jnxAtmIfInLenErrPkts, jnxAtmIfInTimeoutPkts=jnxAtmIfInTimeoutPkts, jnxAtmIfL2CircuitMode=jnxAtmIfL2CircuitMode, jnxAtmVCTable=jnxAtmVCTable, jnxAtmVCEntry=jnxAtmVCEntry, jnxAtmVCConnType=jnxAtmVCConnType, jnxAtmVCEncapsulation=jnxAtmVCEncapsulation, jnxAtmVCMpDestIPv4Addr=jnxAtmVCMpDestIPv4Addr, jnxAtmVCMpDestIPv6Addr=jnxAtmVCMpDestIPv6Addr, jnxAtmVCFlags=jnxAtmVCFlags, jnxAtmVCTotalDownTime=jnxAtmVCTotalDownTime, jnxAtmVCInBytes=jnxAtmVCInBytes, jnxAtmVCOutBytes=jnxAtmVCOutBytes, jnxAtmVCInPkts=jnxAtmVCInPkts, jnxAtmVCOutPkts=jnxAtmVCOutPkts, jnxAtmVCTailQueuePktDrops=jnxAtmVCTailQueuePktDrops, jnxAtmVCOAMPeriod=jnxAtmVCOAMPeriod, jnxAtmVCOAMUpCellCount=jnxAtmVCOAMUpCellCount, jnxAtmVCOAMDownCellCount=jnxAtmVCOAMDownCellCount, jnxAtmVCInOAMF5LoopCells=jnxAtmVCInOAMF5LoopCells, jnxAtmVCOutOAMF5LoopCells=jnxAtmVCOutOAMF5LoopCells, jnxAtmVCInOAMF5RDICells=jnxAtmVCInOAMF5RDICells, jnxAtmVCOutOAMF5RDICells=jnxAtmVCOutOAMF5RDICells, jnxAtmVCInOAMF5AISCells=jnxAtmVCInOAMF5AISCells, jnxAtmVCOutOAMF5AISCells=jnxAtmVCOutOAMF5AISCells, jnxAtmVpTable=jnxAtmVpTable, jnxAtmVpEntry=jnxAtmVpEntry, jnxAtmVpFlags=jnxAtmVpFlags, jnxAtmVpTotalDownTime=jnxAtmVpTotalDownTime, jnxAtmVpOamPeriod=jnxAtmVpOamPeriod, jnxAtmVpOamUpCellCount=jnxAtmVpOamUpCellCount, jnxAtmVpOamDownCellCount=jnxAtmVpOamDownCellCount, jnxAtmVpInBytes=jnxAtmVpInBytes, jnxAtmVpOutBytes=jnxAtmVpOutBytes, jnxAtmVpInPkts=jnxAtmVpInPkts, jnxAtmVpOutPkts=jnxAtmVpOutPkts, jnxAtmVpInOamF4Cells=jnxAtmVpInOamF4Cells, jnxAtmVpOutOamF4Cells=jnxAtmVpOutOamF4Cells, jnxAtmVpInOamF4LoopCells=jnxAtmVpInOamF4LoopCells, jnxAtmVpOutOamF4LoopCells=jnxAtmVpOutOamF4LoopCells, jnxAtmVpInOamF4RdiCells=jnxAtmVpInOamF4RdiCells, jnxAtmVpOutOamF4RdiCells=jnxAtmVpOutOamF4RdiCells, jnxAtmVpInOamF4AisCells=jnxAtmVpInOamF4AisCells, jnxAtmTrunkTable=jnxAtmTrunkTable, jnxAtmTrunkEntry=jnxAtmTrunkEntry, jnxAtmTrunkId=jnxAtmTrunkId, jnxAtmTrunkConnType=jnxAtmTrunkConnType, jnxAtmTrunkEncapsulation=jnxAtmTrunkEncapsulation, jnxAtmTrunkFlags=jnxAtmTrunkFlags, jnxAtmTrunkTotalDownTime=jnxAtmTrunkTotalDownTime, jnxAtmTrunkInBytes=jnxAtmTrunkInBytes, jnxAtmTrunkOutBytes=jnxAtmTrunkOutBytes, jnxAtmTrunkInPkts=jnxAtmTrunkInPkts, jnxAtmTrunkOutPkts=jnxAtmTrunkOutPkts, jnxAtmTrunkTailQueuePktDrops=jnxAtmTrunkTailQueuePktDrops, jnxAtmTrunkInOAMF4AISCells=jnxAtmTrunkInOAMF4AISCells, jnxAtmTrunkOutOAMF4AISCells=jnxAtmTrunkOutOAMF4AISCells)

