# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-PW-TDM-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:55 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( jnxMibs, jnxPwTdmMibRoot, ) = mibBuilder.importSymbols("JUNIPER-SMI", "jnxMibs", "jnxPwTdmMibRoot")
( jnxVpnPwIndex, jnxVpnPwVpnName, jnxVpnPwVpnType, ) = mibBuilder.importSymbols("JUNIPER-VPN-MIB", "jnxVpnPwIndex", "jnxVpnPwVpnName", "jnxVpnPwVpnType")
( PerfCurrentCount, PerfIntervalCount, ) = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfCurrentCount", "PerfIntervalCount")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, transmission, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "transmission")
( RowStatus, StorageType, TextualConvention, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TextualConvention", "TimeStamp", "TruthValue")

# Types

class JnxPwCfgIndexOrzero(TextualConvention, Unsigned32):
    displayHint = "d"
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(0,4294967295)
    
class JnxPwTDMCfgIndex(Unsigned32):
    subtypeSpec = Unsigned32.subtypeSpec+ValueRangeConstraint(1,4294967295)
    

# Objects

jnxPWTdmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1)).setRevisions(("2007-04-03 00:00",))
if mibBuilder.loadTexts: jnxPWTdmMIB.setOrganization("Pseudo-Wire Emulation Edge-to-Edge (PWE3)\nWorking Group")
if mibBuilder.loadTexts: jnxPWTdmMIB.setContactInfo("        Orly Nicklass\nPostal: RAD Data Communications\n        24 Raoul Wallenberg St., Bldg C\n        Tel Aviv 69719, Israel\n        Email: orly_n@rad.com\n\nThe PWE3 Working Group (email distribution pwe3@ietf.org,\nhttp://www.ietf.org/html.charters/pwe3-charter.html)")
if mibBuilder.loadTexts: jnxPWTdmMIB.setDescription("This MIB contains managed object definitions for\nencapsulating TDM (T1,E1, T3, E3, NxDS0) as\npseudo-wires over packet-switching networks (PSN).\n\nThis MIB supplements the PW-STD-MIB as in: Zelig, D.,\nNadeau,T. 'Pseudo Wire (PW) Management Information Base'.\nThe PW-STD-MIB contains structures and MIB associations\ngeneric to Pseudo-Wire (PW) emulation. PW-specific\nMIBs (such as this) contain config and stats for specific\nPW types.\n\nCopyright (C) The IETF Trust (2007). This version\nof this MIB module is part of RFC yyyy; see the RFC\nitself for full legal notices.\n-- RFC Ed.: replace yyyy with actual RFC number & remove this\nnote")
jnxpwTDMObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1))
jnxpwTDMTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1))
if mibBuilder.loadTexts: jnxpwTDMTable.setDescription("This table contains basic information including ifIndex,\nand pointers to entries in the relevant TDM config\ntables for this TDM PW.")
jnxpwTDMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwTDMEntry.setDescription("This table is indexed by the same index that was\ncreated for the associated entry in the PW Table\n(in the PW-STD-MIB).\n\n  - The PwIndex.\n\nAn entry is created in this table by the agent for every\nentry in the pwTable with a pwType equal to one of the\nfollowing:\ne1Satop(17), t1Satop(18), e3Satop(19), t3Satop(20),\nbasicCesPsn(21), basicTdmIp(22),  tdmCasCesPsn(23),\ntdmCasTdmIp(24).\nUnless otherwise specified, all RW objects in this table\nMUST NOT be changed after row activation (see [PWMIB])\nand should remain unchanged after reboot.")
jnxpwTDMRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 1), Integer32().clone(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMRate.setDescription("The parameter represents the bit-rate of the TDM service\nin multiples of the 'basic' 64 Kbit/s rate [TDMCP-EXT].\nIt complements the definition of pwType used in\nPW-STD-MIB.\nFor structure-agnostic the following should be used:\na) Satop E1 - 32\nb) Satop T1 emulation:\n   i)   MUST be set to 24 in the basic emulation mode\n   ii)  MUST be set to 25 for the 'Octet-aligned T1'\n        emulation mode\nc) Satop E3 - 535\nd) Satop T3 - 699\nFor all kinds of structure-aware emulation, this parameter\nMUST be set to N where N is the number of DS0 channels\nin the corresponding attachment circuit.")
jnxpwTDMIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMIfIndex.setDescription("This is a unique index within the ifTable. It represents\nthe interface index of the full link or the interface\nindex for the bundle holding the group of\ntime slots to be transmitted via this PW connection.\n\nA value of zero indicates an interface index that has yet\nto be determined.\nOnce set, if the TDM ifIndex is (for some reason) later\nremoved, the agent SHOULD delete the associated PW rows\n(e.g., this pwTDMTable entry). If the agent does not\ndelete the rows,  the agent MUST set this object to\nzero.")
jnxpwGenTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 3), JnxPwCfgIndexOrzero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwGenTDMCfgIndex.setDescription("Index to the generic parameters in the TDM configuration\ntable that appears in this MIB module. It is likely that\nmultiple TDM PWs of the same characteristic will share\na single TDM Cfg entry.")
jnxpwRelTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 4), JnxPwCfgIndexOrzero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwRelTDMCfgIndex.setDescription("Index to the relevant TDM configuration table entry\nthat appears in one of the related MIB modules\nsuch as TDMoIP or CESoPSN. It is likely that\nmultiple TDM PWs of the same characteristic will share\na single configuration entry of the relevant type.\nThe value 0 implies no entry in other related MIB")
jnxpwTDMConfigError = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 5), Bits().subtype(namedValues=NamedValues(("notApplicable", 0), ("tdmTypeIncompatible", 1), ("peerRtpIncompatible", 2), ("peerPayloadSizeIncompatible", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMConfigError.setDescription("Any of the bits are set if the local configuration is\nnot compatible with the peer configuration as available\nfrom the various parameters options. Setting is done based\non signaling, or else value (0) will be set.\n\n-tdmTypeIncompatible bit is set if the local configuration\nis not carrying the same TDM type as the peer configuration.\n\n-peerRtpIncompatible bit is set if the local configuration\nis configured to send RTP packets for this PW, and the\nremote is not capable of accepting RTP packets.\n\n-peerPayloadSizeIncompatible bit is set if the local\nconfiguration is not carrying the same Payload Size as the\npeer configuration.  ")
jnxpwTDMTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 900))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMTimeElapsed.setDescription("The number of seconds, including partial seconds,\nthat have elapsed since the beginning of the current\nmeasurement period. If, for some reason, such as an\nadjustment in the system's time-of-day clock, the\ncurrent interval exceeds the maximum value, the\nagent will return the maximum value.")
jnxpwTDMValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMValidIntervals.setDescription("The number of previous 15-minute intervals for which data\nwas collected.\nAn agent with TDM capability must be capable of supporting\nat least n intervals. The minimum value of n is 4, The\ndefault of n is 32 and the maximum value of n is 96.\nThe value will be n unless the measurement was (re-)\nstarted within the last (n*15) minutes, in which case\nthe value will be the number of complete 15 minute\nintervals for which the agent has at least some data.\nIn certain cases(e.g., in the case where the agent is\na proxy) it is possible that some intervals are unavailable.\nIn this case, this interval is the maximum interval number\nfor which data is available. ")
jnxpwTDMValidDayIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMValidDayIntervals.setDescription("The number of previous days for which data\nwas collected.\nAn agent with TDM capability must be capable of supporting\nat least n intervals. The minimum value of n is 1, The\ndefault of n is 1 and the maximum value of n is 30.")
jnxpwTDMLastEsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMLastEsTimeStamp.setDescription("The value of sysUpTime at the most recent occasion at\nwhich the TDM PW entered the ES or SES state.")
jnxpwTDMCfgIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgIndexNext.setDescription("This object contains the value to be used for\npwTDMCfgIndex when creating entries in the\npwTDMCfgTable. The value 0 indicates that no\nunassigned entries are available.  To obtain the\nvalue of pwTDMCfgIndexNext for a new entry in the\npwTDMCfgTable, the manager issues a management\nprotocol retrieval operation. The agent will\ndetermine through its local policy when this\nindex value will be made available for reuse.")
jnxpwTDMCfgTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3))
if mibBuilder.loadTexts: jnxpwTDMCfgTable.setDescription("This table contains a set of parameters that may be\nreferenced by one or more TDM PWs in pwTDMTable.")
jnxpwTDMCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwTDMCfgEntry.setDescription("These parameters define the characteristics of a\nTDM PW. They are grouped here to ease NMS burden.\nOnce an entry is created here it may be re-used\nby many PWs.\nUnless otherwise specified, all objects in this table\nMUST NOT be changed after row activation (see [PWMIB])\nif the row index is in used by an entry in pwTDMTable.\nRows should remain unchanged after reboot.")
jnxpwTDMCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 1), JnxPwTDMCfgIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwTDMCfgIndex.setDescription("Index to an entry in this table. The value is a copy of the\nassigned pwTDMCfgIndexNext")
jnxpwTDMCfgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 2), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgRowStatus.setDescription("Object used for creating, modifying, and deleting\na row from this table. The following objects should not be\nmodified if the entry is in used and the status is active:\npwTDMCfgPayloadSize, pwTDMCfgRtpHdrUsed,\npwTDMCfgJtrBfrDepth, and pwTDMCfgPayloadSuppression.\nThe row should not be deleted if the entry is in used")
jnxpwTDMCfgPayloadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPayloadSize.setDescription("The value of this object indicates the PayLoad Size (in bytes)\nto be defined during the PW setUp. Upon TX, implementation\nmust be capable of carrying that amount of bytes.\nUpon RX, when the LEN field is set to 0, the payload of\npacket  MUST assume this size, and if the actual\npacket size is inconsistent with this length,\nthe packet MUST be considered to be malformed. ")
jnxpwTDMCfgPktReorder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPktReorder.setDescription("If set True: as CE bound packets are queued in the\njitter buffer, out of order packets are re-ordered. The\nmaximum sequence number differential (i.e., the range in\nwhich re-sequencing can occur) is dependant on the depth\nof the jitter buffer. See pwTDMCfgJtrBfrDepth.\n\nNOTE: Some implementations may not support this feature.\nThe agent is then required to set this to False.")
jnxpwTDMCfgRtpHdrUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 6), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgRtpHdrUsed.setDescription("If set to False: an RTP header is not pre-pended to the\nTDM packet.")
jnxpwTDMCfgJtrBfrDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 7), Unsigned32().clone(3000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgJtrBfrDepth.setDescription("The size of this buffer SHOULD be locally\nconfigured to allow accommodation to the PSN-specific packet\ndelay variation.\n\nIf configured to a value not supported by the\nimplementation, the agent MUST return an error code\n'jtrBfrDepth' in 'pwTDMConfigError '\n\nNOTE: jitter buffers are a limited resource to\nbe managed. The actual size should be at least twice as big\nas the value of pwTDMCfgJtrBfrDepth ")
jnxpwTDMCfgPayloadSuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("enable", 1), ("disable", 2), )).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPayloadSuppression.setDescription("Selecting 'enable' means: Payload suppression is allowed.\nPayload MAY be omitted in order to conserve bandwidth.\nSelecting 'disable' means: no suppresion under any\ncondition.\nObject  MAY be changed at any time.")
jnxpwTDMCfgConsecPktsInSynch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 9), Unsigned32().clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgConsecPktsInSynch.setDescription("The number of consecutive packets with sequential\nsequence numbers that are required to exit the\nLOPS state.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgConsecMissPktsOutSynch = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 10), Unsigned32().clone(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgConsecMissPktsOutSynch.setDescription("The number of consecutive missing packets that are\nrequired to enter the LOPS state.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgSetUp2SynchTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 11), Unsigned32().clone(5000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgSetUp2SynchTimeOut.setDescription("The amount of time the host should wait before declaring the\npseudo wire in down state,  if the number of consecutive\nTDM packets that have been received after changing the\nadminstrative status to up and after finalization of\nsignaling (if supported) between the two PEs is smaller\nthan pwTDMCfgConsecPktsInSynch. Once the the pw has\nOperStatus of 'up' this parameter is no longer valid. This\nparameter is defined to ensure that the host does not\nprematurely inform failure of the pw. In particular pw 'down'\nnotifications should not be sent before expiration of this\ntimer. This parameter is valid only after adminisrative\nchanges of the status of the pw. If the pw fails due to\nnetwork impairments a 'down' notification should be sent.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgPktReplacePolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 12), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("allOnes", 1), ("implementationSpecific", 2), ("filler", 3), )).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPktReplacePolicy.setDescription("This parameter determines the value to be played when CE bound\npackets have over/underflow the jitter buffer, or are missing\nfor any reason. This byte pattern is sent(played)on\nthe TDM line. Selecting implementationSpecific(2) implies\nagent specific algorithm. Selecting filler(3) requires setting\nof pwTDMCfgPktFiller.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgAvePktLossTimeWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgAvePktLossTimeWindow.setDescription("The length of time over which the average packet\nloss rate should be computed to detect Excessive packet\nloss rate.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgExcessivePktLossThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgExcessivePktLossThreshold.setDescription("Excessive packet loss rate is detected by computing the\naverage packetloss rate over a pwTDMCfgAvePktLossTimeWindow\namount of time and comparing it with this threshold value.\nThe rate is expressed in precentage.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 15), Unsigned32().clone(2500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgAlarmThreshold.setDescription("Alarms are only reported when the defect state persists\nfor the length of time specified by this object.\nThe object's unit is millisec.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgClearAlarmThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 16), Unsigned32().clone(10000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgClearAlarmThreshold.setDescription("Alarm MUST be cleared after the corresponding defect is\nundetected for the amount of time specified by this object.\nThe object's unit is millisec.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgMissingPktsToSes = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 17), Unsigned32().clone(30)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgMissingPktsToSes.setDescription("Percent of missing packets detected (consecutive or not)\nwithin a 1 second window to cause a Severely Error\nSecond (SES) to be counted.\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgTimestampMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 18), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("notApplicable", 1), ("absolute", 2), ("differential", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgTimestampMode.setDescription("Timestamp generation MAY be used in one of the following\nmodes:\n1. Absolute mode: the PSN-bound IWF sets timestamps\n using the clock recovered from the incoming TDM attachment\n circuit. As a consequence, the timestamps are closely\n correlated with the sequence numbers. All TDM implementations\n that support usage of the RTP header MUST support this mode.\n2. Differential mode: Both IWFs have access to a common high-\n quality timing source, and this source is used for timestamp\n generation. Support of this mode is OPTIONAL.\n Object  MAY be changed when the related PW is\n defined as not active.")
jnxpwTDMCfgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 19), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgStorageType.setDescription("This variable indicates the storage type for this\nrow.")
jnxpwTDMCfgPktFiller = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgPktFiller.setDescription("Filler byte pattern played out on the TDM\ninterface if pwTDMCfgPktReplacePolicy\nwas set to filler(3).\nObject  MAY be changed when the related PW is\ndefined as not active.")
jnxpwTDMCfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 3, 1, 21), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMCfgName.setDescription("A descriptive string, prefereably unique name, to an entry\nin this table.\nObject  MAY be changed at any time.")
jnxpwTDMPerfCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5))
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentTable.setDescription("The current 15 minute interval counts are in\nthis table.\n\nThis table provides per TDM PW performance information.")
jnxpwTDMPerfCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"))
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentEntry.setDescription("An entry in this table is created by the agent for every\npwTDMTable entry. After 15 minutes, the contents of this\ntable entry are copied to a new entry in the\npwTDMPerfInterval table and the counts in this entry\nare reset to zero.")
jnxpwTDMPerfCurrentMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 1), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMissingPkts.setDescription("Number of missing packets (as detected via control word\nsequence number gaps).")
jnxpwTDMPerfCurrentPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 2), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentPktsReOrder.setDescription("Number of packets detected out of sequence (via control\nword sequence number), but successfully re-ordered.\nNote: some implementations may not support this Feature.")
jnxpwTDMPerfCurrentJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 3), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentJtrBfrUnderruns.setDescription("Number of times a packet needed to be played\nout and the jitter buffer was empty.")
jnxpwTDMPerfCurrentMisOrderDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 4), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMisOrderDropped.setDescription("Number of packets detected out of order(via control word\nsequence numbers), and could not be re-ordered, or could\nnot fit in the jitter buffer.")
jnxpwTDMPerfCurrentMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 5), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentMalformedPkt.setDescription("Number of packets detected with unexpected size, or\nbad headers' stack")
jnxpwTDMPerfCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 6), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentESs.setDescription("The counter associated with the number of Error\nSeconds encountered. Any malformed packet, seq. error, LOPS\nand similar are considered as error second")
jnxpwTDMPerfCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 7), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentSESs.setDescription("The counter associated with the number of\nSeverely Error Seconds encountered. ")
jnxpwTDMPerfCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 8), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentUASs.setDescription("The counter associated with the number of\nUnavailable Seconds encountered. Any consequtive\nten seconds of SES are counted as one UAS")
jnxpwTDMPerfCurrentFC = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 5, 1, 9), PerfCurrentCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentFC.setDescription("TDM Failure Counts (FC-TDM). The number of TDM failure\nevents. A failure event begins when the LOPS failure\nis declared, and ends when the failure is cleared. A\nfailure event that begins in one period and ends in\nanother period is counted only in the period in which\nit begins.")
jnxpwTDMPerfIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6))
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalTable.setDescription("This table provides performance information per TDM PW\nsimilar to the pwTDMPerfCurrentTable above. However,\nthese counts represent historical 15 minute intervals.\nTypically, this table will have a maximum of 96 entries\nfor a 24 hour period, but is not limited to this. ")
jnxpwTDMPerfIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"), (0, "JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalNumber"))
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalEntry.setDescription("An entry in this table is created by the agent for\nevery pwTDMPerfCurrentEntry that is 15 minutes old.\nThe contents of the Current entry are copied to the new\nentry here. The Current entry, then resets its counts\nto zero for the next current 15 minute interval. ")
jnxpwTDMPerfIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 1), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalNumber.setDescription("A number (normally between 1 and 96 to cover a 24 hour\nperiod) which identifies the interval for which the set\nof statistics is available. The interval identified by 1\nis the most recently completed 15 minute interval, and\nthe interval identified by N is the interval immediately\npreceding the one identified by N-1. The minimum range of\nN is 1 through 4. The default range is 1 through 32. The\nmaximum value of N is 1 through 96.")
jnxpwTDMPerfIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalValidData.setDescription("This variable indicates if the data for this interval\nis valid.")
jnxpwTDMPerfIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalDuration.setDescription("The duration of a particular interval in seconds,\nAdjustments in the system's time-of-day clock, may\ncause the interval to be greater or less than, the\nnormal value. Therefore this actual interval value\nis provided.")
jnxpwTDMPerfIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 4), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMissingPkts.setDescription("Number of missing packets (as detected via control\nword sequence number gaps).")
jnxpwTDMPerfIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 5), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalPktsReOrder.setDescription("Number of packets detected out of sequence (via control\nword sequence number), but successfully re-ordered.\nNote: some implementations may not support this\nFeature.")
jnxpwTDMPerfIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 6), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalJtrBfrUnderruns.setDescription("Number of times a packet needed to be played\nout and the jitter buffer was empty.")
jnxpwTDMPerfIntervalMisOrderDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 7), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMisOrderDropped.setDescription("Number of packets detected out of order(via control word\nsequence numbers), and could not be re-ordered, or could\nnot fit in the jitter buffer.")
jnxpwTDMPerfIntervalMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 8), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalMalformedPkt.setDescription("Number of packets detected with unexpected size, or\nbad headers' stack")
jnxpwTDMPerfIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 9), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalESs.setDescription("The counter associated with the number of Error\nSeconds encountered.")
jnxpwTDMPerfIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 10), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalSESs.setDescription("The counter associated with the number of\nSeverely Error Seconds encountered.")
jnxpwTDMPerfIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 11), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalUASs.setDescription("The counter associated with the number of\nUnavailable Seconds encountered.")
jnxpwTDMPerfIntervalFC = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 6, 1, 12), PerfIntervalCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalFC.setDescription("TDM Failure Counts (FC-TDM). The number of TDM failure\nevents. A failure event begins when the LOPS failure\nis declared, and ends when the failure is cleared. A\nfailure event that begins in one period and ends in\nanother period is counted only in the period in which\nit begins.")
jnxpwTDMPerf1DayIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7))
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalTable.setDescription("This table provides performance information per TDM PW\nsimilar to the pwTDMPerfIntervalTable above. However,\nthese counters represent historical 1 day intervals up to\none full month. The table consists of real time data, as\nsuch it is not persistence across re-boot.")
jnxpwTDMPerf1DayIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1)).setIndexNames((0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnType"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwVpnName"), (0, "JUNIPER-VPN-MIB", "jnxVpnPwIndex"), (0, "JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalNumber"))
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalEntry.setDescription("An entry is created in this table by the agent\nfor every entry in the pwTDMTable table.")
jnxpwTDMPerf1DayIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 1), Unsigned32()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalNumber.setDescription("The number of interval, where 1 indicates current day\nmeasured period and 2 and above indicate previous days\nrespectively")
jnxpwTDMPerf1DayIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalValidData.setDescription("This variable indicates if the data for this interval\nis valid.")
jnxpwTDMPerf1DayIntervalDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalDuration.setDescription("The duration of a particular interval in seconds,\nAdjustments in the system's time-of-day clock, may\ncause the interval to be greater or less than, the\nnormal value. Therefore this actual interval value\nis provided.")
jnxpwTDMPerf1DayIntervalMissingPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMissingPkts.setDescription("Number of missing packets (as detected via control word\nsequence number gaps).")
jnxpwTDMPerf1DayIntervalPktsReOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalPktsReOrder.setDescription("Number of packets detected out of sequence (via control\nword sequence number), but successfully re-ordered.\nNote: some implementations may not support this\nfeature.")
jnxpwTDMPerf1DayIntervalJtrBfrUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalJtrBfrUnderruns.setDescription("Number of times a packet needed to be played\nout and the jitter buffer was empty.")
jnxpwTDMPerf1DayIntervalMisOrderDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMisOrderDropped.setDescription("Number of packets detected out of order(via control word\nsequence numbers), and could not be re-ordered, or could\nnot fit in the jitter buffer.")
jnxpwTDMPerf1DayIntervalMalformedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalMalformedPkt.setDescription("Number of packets detected with unexpected size, or\nbad headers' stack.")
jnxpwTDMPerf1DayIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalESs.setDescription("The counter associated with the number of Error\nSeconds encountered.")
jnxpwTDMPerf1DayIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalSESs.setDescription("The counter associated with the number of Severely\nError Seconds.")
jnxpwTDMPerf1DayIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalUASs.setDescription("The counter associated with the number of\nUnAvailable Seconds.\n\nNOTE: When first entering the UAS state, the number\nof SES To UAS is added to this object, then as each\nadditional UAS occurs, this object increments by one.")
jnxpwTDMPerf1DayIntervalFC = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 1, 7, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalFC.setDescription("TDM Failure Counts (FC-TDM). The number of TDM failure\nevents. A failure event begins when the LOPS failure\nis declared, and ends when the failure is cleared.")
jnxpwTDMNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 2))
jnxpwTDMConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3))
jnxpwTDMGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1))
jnxpwTDMCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 2))

# Augmentions

# Groups

jnxpwTDMGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 1)).setObjects(*(("JUNIPER-PW-TDM-MIB", "jnxpwTDMConfigError"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPktReorder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgName"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgAlarmThreshold"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgRtpHdrUsed"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgSetUp2SynchTimeOut"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgConsecPktsInSynch"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgTimestampMode"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgAvePktLossTimeWindow"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgConsecMissPktsOutSynch"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMIfIndex"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPayloadSize"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMRate"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMValidDayIntervals"), ("JUNIPER-PW-TDM-MIB", "jnxpwGenTDMCfgIndex"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMTimeElapsed"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPktFiller"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgClearAlarmThreshold"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgMissingPktsToSes"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMLastEsTimeStamp"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPayloadSuppression"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgRowStatus"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgIndexNext"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgStorageType"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgPktReplacePolicy"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgExcessivePktLossThreshold"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMValidIntervals"), ("JUNIPER-PW-TDM-MIB", "jnxpwRelTDMCfgIndex"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMCfgJtrBfrDepth"), ) )
if mibBuilder.loadTexts: jnxpwTDMGroup.setDescription("Collection of objects for basic TDM PW config and\nstatus.")
jnxpwTDMPerfCurrentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 2)).setObjects(*(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentUASs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentJtrBfrUnderruns"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentSESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentMissingPkts"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentFC"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentMisOrderDropped"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentMalformedPkt"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentPktsReOrder"), ) )
if mibBuilder.loadTexts: jnxpwTDMPerfCurrentGroup.setDescription("Collection of current statistics objects for TDM PWs.")
jnxpwTDMPerfIntervalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 3)).setObjects(*(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalPktsReOrder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalFC"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalMissingPkts"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalUASs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalSESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalDuration"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalMalformedPkt"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalValidData"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalJtrBfrUnderruns"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalMisOrderDropped"), ) )
if mibBuilder.loadTexts: jnxpwTDMPerfIntervalGroup.setDescription("Collection of Interval statistics objects for TDM PWs.")
jnxpwTDMPerf1DayIntervalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 1, 4)).setObjects(*(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalFC"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalESs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalPktsReOrder"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalMissingPkts"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalDuration"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalMisOrderDropped"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalUASs"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalJtrBfrUnderruns"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalValidData"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalMalformedPkt"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalSESs"), ) )
if mibBuilder.loadTexts: jnxpwTDMPerf1DayIntervalGroup.setDescription("Collection of Daily statistics objects for TDM PWs.")

# Compliances

jnxpwTDMModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2636, 3, 54, 1, 3, 2, 1)).setObjects(*(("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerf1DayIntervalGroup"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMGroup"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfCurrentGroup"), ("JUNIPER-PW-TDM-MIB", "jnxpwTDMPerfIntervalGroup"), ) )
if mibBuilder.loadTexts: jnxpwTDMModuleCompliance.setDescription("The compliance statement for agent that support TDM PW\nover  PSN operation.")

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-PW-TDM-MIB", PYSNMP_MODULE_ID=jnxPWTdmMIB)

# Types
mibBuilder.exportSymbols("JUNIPER-PW-TDM-MIB", JnxPwCfgIndexOrzero=JnxPwCfgIndexOrzero, JnxPwTDMCfgIndex=JnxPwTDMCfgIndex)

# Objects
mibBuilder.exportSymbols("JUNIPER-PW-TDM-MIB", jnxPWTdmMIB=jnxPWTdmMIB, jnxpwTDMObjects=jnxpwTDMObjects, jnxpwTDMTable=jnxpwTDMTable, jnxpwTDMEntry=jnxpwTDMEntry, jnxpwTDMRate=jnxpwTDMRate, jnxpwTDMIfIndex=jnxpwTDMIfIndex, jnxpwGenTDMCfgIndex=jnxpwGenTDMCfgIndex, jnxpwRelTDMCfgIndex=jnxpwRelTDMCfgIndex, jnxpwTDMConfigError=jnxpwTDMConfigError, jnxpwTDMTimeElapsed=jnxpwTDMTimeElapsed, jnxpwTDMValidIntervals=jnxpwTDMValidIntervals, jnxpwTDMValidDayIntervals=jnxpwTDMValidDayIntervals, jnxpwTDMLastEsTimeStamp=jnxpwTDMLastEsTimeStamp, jnxpwTDMCfgIndexNext=jnxpwTDMCfgIndexNext, jnxpwTDMCfgTable=jnxpwTDMCfgTable, jnxpwTDMCfgEntry=jnxpwTDMCfgEntry, jnxpwTDMCfgIndex=jnxpwTDMCfgIndex, jnxpwTDMCfgRowStatus=jnxpwTDMCfgRowStatus, jnxpwTDMCfgPayloadSize=jnxpwTDMCfgPayloadSize, jnxpwTDMCfgPktReorder=jnxpwTDMCfgPktReorder, jnxpwTDMCfgRtpHdrUsed=jnxpwTDMCfgRtpHdrUsed, jnxpwTDMCfgJtrBfrDepth=jnxpwTDMCfgJtrBfrDepth, jnxpwTDMCfgPayloadSuppression=jnxpwTDMCfgPayloadSuppression, jnxpwTDMCfgConsecPktsInSynch=jnxpwTDMCfgConsecPktsInSynch, jnxpwTDMCfgConsecMissPktsOutSynch=jnxpwTDMCfgConsecMissPktsOutSynch, jnxpwTDMCfgSetUp2SynchTimeOut=jnxpwTDMCfgSetUp2SynchTimeOut, jnxpwTDMCfgPktReplacePolicy=jnxpwTDMCfgPktReplacePolicy, jnxpwTDMCfgAvePktLossTimeWindow=jnxpwTDMCfgAvePktLossTimeWindow, jnxpwTDMCfgExcessivePktLossThreshold=jnxpwTDMCfgExcessivePktLossThreshold, jnxpwTDMCfgAlarmThreshold=jnxpwTDMCfgAlarmThreshold, jnxpwTDMCfgClearAlarmThreshold=jnxpwTDMCfgClearAlarmThreshold, jnxpwTDMCfgMissingPktsToSes=jnxpwTDMCfgMissingPktsToSes, jnxpwTDMCfgTimestampMode=jnxpwTDMCfgTimestampMode, jnxpwTDMCfgStorageType=jnxpwTDMCfgStorageType, jnxpwTDMCfgPktFiller=jnxpwTDMCfgPktFiller, jnxpwTDMCfgName=jnxpwTDMCfgName, jnxpwTDMPerfCurrentTable=jnxpwTDMPerfCurrentTable, jnxpwTDMPerfCurrentEntry=jnxpwTDMPerfCurrentEntry, jnxpwTDMPerfCurrentMissingPkts=jnxpwTDMPerfCurrentMissingPkts, jnxpwTDMPerfCurrentPktsReOrder=jnxpwTDMPerfCurrentPktsReOrder, jnxpwTDMPerfCurrentJtrBfrUnderruns=jnxpwTDMPerfCurrentJtrBfrUnderruns, jnxpwTDMPerfCurrentMisOrderDropped=jnxpwTDMPerfCurrentMisOrderDropped, jnxpwTDMPerfCurrentMalformedPkt=jnxpwTDMPerfCurrentMalformedPkt, jnxpwTDMPerfCurrentESs=jnxpwTDMPerfCurrentESs, jnxpwTDMPerfCurrentSESs=jnxpwTDMPerfCurrentSESs, jnxpwTDMPerfCurrentUASs=jnxpwTDMPerfCurrentUASs, jnxpwTDMPerfCurrentFC=jnxpwTDMPerfCurrentFC, jnxpwTDMPerfIntervalTable=jnxpwTDMPerfIntervalTable, jnxpwTDMPerfIntervalEntry=jnxpwTDMPerfIntervalEntry, jnxpwTDMPerfIntervalNumber=jnxpwTDMPerfIntervalNumber, jnxpwTDMPerfIntervalValidData=jnxpwTDMPerfIntervalValidData, jnxpwTDMPerfIntervalDuration=jnxpwTDMPerfIntervalDuration, jnxpwTDMPerfIntervalMissingPkts=jnxpwTDMPerfIntervalMissingPkts, jnxpwTDMPerfIntervalPktsReOrder=jnxpwTDMPerfIntervalPktsReOrder, jnxpwTDMPerfIntervalJtrBfrUnderruns=jnxpwTDMPerfIntervalJtrBfrUnderruns, jnxpwTDMPerfIntervalMisOrderDropped=jnxpwTDMPerfIntervalMisOrderDropped, jnxpwTDMPerfIntervalMalformedPkt=jnxpwTDMPerfIntervalMalformedPkt, jnxpwTDMPerfIntervalESs=jnxpwTDMPerfIntervalESs, jnxpwTDMPerfIntervalSESs=jnxpwTDMPerfIntervalSESs, jnxpwTDMPerfIntervalUASs=jnxpwTDMPerfIntervalUASs, jnxpwTDMPerfIntervalFC=jnxpwTDMPerfIntervalFC, jnxpwTDMPerf1DayIntervalTable=jnxpwTDMPerf1DayIntervalTable, jnxpwTDMPerf1DayIntervalEntry=jnxpwTDMPerf1DayIntervalEntry, jnxpwTDMPerf1DayIntervalNumber=jnxpwTDMPerf1DayIntervalNumber, jnxpwTDMPerf1DayIntervalValidData=jnxpwTDMPerf1DayIntervalValidData, jnxpwTDMPerf1DayIntervalDuration=jnxpwTDMPerf1DayIntervalDuration, jnxpwTDMPerf1DayIntervalMissingPkts=jnxpwTDMPerf1DayIntervalMissingPkts, jnxpwTDMPerf1DayIntervalPktsReOrder=jnxpwTDMPerf1DayIntervalPktsReOrder, jnxpwTDMPerf1DayIntervalJtrBfrUnderruns=jnxpwTDMPerf1DayIntervalJtrBfrUnderruns, jnxpwTDMPerf1DayIntervalMisOrderDropped=jnxpwTDMPerf1DayIntervalMisOrderDropped, jnxpwTDMPerf1DayIntervalMalformedPkt=jnxpwTDMPerf1DayIntervalMalformedPkt, jnxpwTDMPerf1DayIntervalESs=jnxpwTDMPerf1DayIntervalESs, jnxpwTDMPerf1DayIntervalSESs=jnxpwTDMPerf1DayIntervalSESs, jnxpwTDMPerf1DayIntervalUASs=jnxpwTDMPerf1DayIntervalUASs, jnxpwTDMPerf1DayIntervalFC=jnxpwTDMPerf1DayIntervalFC, jnxpwTDMNotifications=jnxpwTDMNotifications, jnxpwTDMConformance=jnxpwTDMConformance, jnxpwTDMGroups=jnxpwTDMGroups, jnxpwTDMCompliances=jnxpwTDMCompliances)

# Groups
mibBuilder.exportSymbols("JUNIPER-PW-TDM-MIB", jnxpwTDMGroup=jnxpwTDMGroup, jnxpwTDMPerfCurrentGroup=jnxpwTDMPerfCurrentGroup, jnxpwTDMPerfIntervalGroup=jnxpwTDMPerfIntervalGroup, jnxpwTDMPerf1DayIntervalGroup=jnxpwTDMPerf1DayIntervalGroup)

# Compliances
mibBuilder.exportSymbols("JUNIPER-PW-TDM-MIB", jnxpwTDMModuleCompliance=jnxpwTDMModuleCompliance)
