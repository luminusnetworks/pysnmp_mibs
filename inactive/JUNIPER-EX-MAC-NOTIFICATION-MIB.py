# PySNMP SMI module. Autogenerated from smidump -f python JUNIPER-EX-MAC-NOTIFICATION-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:49 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( jnxMacNotificationRoot, ) = mibBuilder.importSymbols("JUNIPER-EX-SMI", "jnxMacNotificationRoot")
( Bits, Counter64, Integer32, ModuleIdentity, MibIdentifier, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter64", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32")
( TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue")

# Objects

jnxMacNotificationMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1)).setRevisions(("2010-04-28 00:00","2010-02-09 00:00","2009-05-27 00:00","2009-01-20 00:00",))
if mibBuilder.loadTexts: jnxMacNotificationMIB.setOrganization("Juniper Networks, Inc.")
if mibBuilder.loadTexts: jnxMacNotificationMIB.setContactInfo("Juniper Technical Assistance Center\nJuniper Networks, Inc.\n1194 N. Mathilda Avenue\nSunnyvale, CA 94089\nE-mail: support@juniper.net")
if mibBuilder.loadTexts: jnxMacNotificationMIB.setDescription("This MIB module is for configuration of the MAC notification\nfeature. MAC notification is a mechanism to inform monitoring\ndevices when there are MAC addresses learnt or removed from\nthe forwarding database of the monitored devices.")
jnxMacNotificationMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1))
jnxMacNotificationMIBGlobalObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1))
jnxMacGlobalFeatureEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMacGlobalFeatureEnabled.setDescription("Indicates whether the MAC notification feature is currently \nrunning in the device.\n\nSetting this object to false(2) disables the MAC notification\nfeature globally.\n\nSetting this object to true(1) will start the MAC notification\nfeature running in the device. If the feature is already\nrunning, setting to true(1) has no effect. ")
jnxMacNotificationInterval = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(30)).setMaxAccess("readonly").setUnits("seconds")
if mibBuilder.loadTexts: jnxMacNotificationInterval.setDescription("This object specifies the maximum interval of time between\njnxMacChangedNotifications being generated by the device.\nIf the value of jnxNotificationsEnabled is true(1), the\ndevice will send out the generated jnxMacChangedNotifications\nand archive the MAC change notification events in the\njnxMacHistoryTable. If the value of jnxNotificationEnabled is\nfalse(2), the device will not send out the generated\njnxMacChangedNotifications but it will archive these events\nin the jnxMacHistoryTable.   \n\nIf the value of this object is equal to 0, the device will \ngenerate jnxMacChangedNotifications and archive the MAC \nchange notification events in the jnxMacHistoryTable as soon as\nthere is MAC address learnt or removed by the device.\n\nIf the value of this object is greater than 0, the device will\nwait for a period of time equal to the value of this object\nbefore generate the jnxMacChangedNotifications and archive\nthe MAC change notification events in the jnxMacHistoryTable.")
jnxMacAddressesLearnt = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMacAddressesLearnt.setDescription("Indicates the number of MAC addresses learnt by the\ndevice.")
jnxMacAddressesRemoved = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMacAddressesRemoved.setDescription("Indicates the number of MAC addresses removed from the\nforwarding database.")
jnxMacNotificationsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMacNotificationsEnabled.setDescription("Indicates whether jnxMacChangedNotification notifications\nwill or will not be sent when there are MAC addresses\nlearnt or removed from the device's forwarding database. \nDisabling notifications does not prevent the MAC address\ninfo from being added to the jnxMacHistoryTable.")
jnxMacNotificationsSent = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMacNotificationsSent.setDescription("Indicates the number of jnxMacChangedNotifications sent out\nby the device.")
jnxMacHistTableMaxLength = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 500)).clone(256)).setMaxAccess("readonly").setUnits("entries")
if mibBuilder.loadTexts: jnxMacHistTableMaxLength.setDescription("The upper limit on the number of entries that the\njnxMacHistoryTable may contain.  A value of 0 will\nprevent any history from being retained. When this\ntable is full, the oldest entry will be deleted and\na new one will be created.")
jnxMacHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 8))
if mibBuilder.loadTexts: jnxMacHistoryTable.setDescription("This table will archive the MAC change notification events \ngenerated by this device. The MAC change notification\nevents are archived here even if jnxMacChangesNotifications \nare not actually sent.")
jnxMacHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 8, 1)).setIndexNames((0, "JUNIPER-EX-MAC-NOTIFICATION-MIB", "jnxHistIndex"))
if mibBuilder.loadTexts: jnxMacHistoryEntry.setDescription("A MAC change notification message that was previously\ngenerated by this device.  Each entry is indexed by a message\nindex.")
jnxHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: jnxHistIndex.setDescription("An index that uniquely identifies a MAC change notification\nevent previously generated by the device. This index starts at\n1 and increases by one when a MAC change notification is \ngenerated.  When it reaches the maximum value, the agent wraps\nthe value back to 1.")
jnxHistMacChangedMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxHistMacChangedMsg.setDescription("This object contains the information of a MAC change\nnotification event. It consists of several tuples packed\ntogether in the format of '<tuple1><tuple2>...'.\n\nEach tuple consist of 13 octets in the format of\n'<operation><VLAN><MAC><dot1dBasePort>' where \n\n<operation> is of size 1 octet and supports the following values\n  0 - End of MIB object.\n  1 - MAC learnt.\n  2 - MAC removed.\n  3 - MAC updated.\n\n<VLAN> is VLAN number of the VLAN which the MAC address is\nbelonged to and has size of 2 octet.\n\n<MAC> is the Layer2 Mac Address and has size of 6 octets.\n\n<dot1dBasePort> is the value of dot1dBasePort for the\ninterface from which the MAC address is learnt and has size\nof 4 octets.")
jnxHistTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 8, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxHistTimestamp.setDescription("The value of sysUpTime when the jnxMacChangedNotification\ncontaining the information denoted by the jnxHistMacChangedMsg\nobject in this entry was generated.")
jnxMacAddressesUpdated = MibScalar((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 1, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: jnxMacAddressesUpdated.setDescription("Indicates the number of MAC addresses updated by the\ndevice.")
jnxMacNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 2))
jnxMacNotificationsPrefix = ObjectIdentity((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 2, 0))
if mibBuilder.loadTexts: jnxMacNotificationsPrefix.setDescription("All Mac Notifications are registered\nunder this branch.")

# Augmentions

# Notifications

jnxMacChangedNotification = NotificationType((1, 3, 6, 1, 4, 1, 2636, 3, 40, 1, 7, 2, 0, 1)).setObjects(*(("JUNIPER-EX-MAC-NOTIFICATION-MIB", "jnxHistMacChangedMsg"), ("JUNIPER-EX-MAC-NOTIFICATION-MIB", "jnxHistTimestamp"), ) )
if mibBuilder.loadTexts: jnxMacChangedNotification.setDescription("This notification is generated when there is enough MAC\naddress information to fully occupy a maximum size SNMP trap\nmessage. This notification is also generated when there\nis at least one MAC address changed or removed and the amount\nof time elapsed from the previous notification is greater\nthan the maximum wait time denoted by\njnxNotificationInterval object.\n\nIf there are more MAC addresses information than can fit into\none cmmHistTrapContent object, then multiple notifications\nwill be generated.")

# Exports

# Module identity
mibBuilder.exportSymbols("JUNIPER-EX-MAC-NOTIFICATION-MIB", PYSNMP_MODULE_ID=jnxMacNotificationMIB)

# Objects
mibBuilder.exportSymbols("JUNIPER-EX-MAC-NOTIFICATION-MIB", jnxMacNotificationMIB=jnxMacNotificationMIB, jnxMacNotificationMIBObjects=jnxMacNotificationMIBObjects, jnxMacNotificationMIBGlobalObjects=jnxMacNotificationMIBGlobalObjects, jnxMacGlobalFeatureEnabled=jnxMacGlobalFeatureEnabled, jnxMacNotificationInterval=jnxMacNotificationInterval, jnxMacAddressesLearnt=jnxMacAddressesLearnt, jnxMacAddressesRemoved=jnxMacAddressesRemoved, jnxMacNotificationsEnabled=jnxMacNotificationsEnabled, jnxMacNotificationsSent=jnxMacNotificationsSent, jnxMacHistTableMaxLength=jnxMacHistTableMaxLength, jnxMacHistoryTable=jnxMacHistoryTable, jnxMacHistoryEntry=jnxMacHistoryEntry, jnxHistIndex=jnxHistIndex, jnxHistMacChangedMsg=jnxHistMacChangedMsg, jnxHistTimestamp=jnxHistTimestamp, jnxMacAddressesUpdated=jnxMacAddressesUpdated, jnxMacNotifications=jnxMacNotifications, jnxMacNotificationsPrefix=jnxMacNotificationsPrefix)

# Notifications
mibBuilder.exportSymbols("JUNIPER-EX-MAC-NOTIFICATION-MIB", jnxMacChangedNotification=jnxMacChangedNotification)

